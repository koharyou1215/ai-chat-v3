/**
 * Stable Diffusion Image Generation Service
 * ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’è€ƒæ…®ã—ãŸç”»åƒç”Ÿæˆã®çµ±åˆã‚µãƒ¼ãƒ“ã‚¹
 */

import { Character } from '@/types/core/character.types';
import { UnifiedMessage } from '@/types/memory';
import { TrackerPromptMapper } from './tracker-prompt-mapper';
import { ContextAnalyzer } from './context-analyzer';

// TrackerValueSimple is just the actual value, not the full TrackerValue interface
type TrackerValueSimple = string | number | boolean;

interface SDGenerationParams {
  prompt: string;
  negative_prompt: string;
  width: number;
  height: number;
  steps: number;
  cfg_scale: number;
  sampler_name: string;
  seed: number;
  restore_faces: boolean;
  enable_hr: boolean;
  hr_scale?: number;
  hr_upscaler?: string;
  denoising_strength?: number;
}

interface SDResponse {
  images: string[]; // Base64 encoded images
  parameters: SDGenerationParams;
  info: string;
}

export class SDImageGenerator {
  private baseUrl: string;
  private apiKey?: string;

  constructor(baseUrl: string = 'http://localhost:7860', apiKey?: string) {
    this.baseUrl = baseUrl;
    this.apiKey = apiKey;
  }

  /**
   * ãƒãƒ£ãƒƒãƒˆã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰ç”»åƒã‚’ç”Ÿæˆ
   */
  async generateFromChat(
    character: Character,
    messages: UnifiedMessage[],
    trackers: Array<{
      name: string;
      value: TrackerValueSimple;
      type: 'numeric' | 'state' | 'boolean' | 'text';
    }>,
    customPrompt?: string
  ): Promise<string> {
    // 1. ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰
    const { prompt, negativePrompt } = this.buildPrompt(
      character,
      messages,
      trackers,
      customPrompt
    );

    console.log('ğŸ“¸ Generated Prompt:', prompt);
    console.log('ğŸš« Negative Prompt:', negativePrompt);

    // 2. SD APIã«é€ä¿¡
    const params: SDGenerationParams = {
      prompt,
      negative_prompt: negativePrompt,
      width: 768,
      height: 1024,
      steps: 25,
      cfg_scale: 7.5,
      sampler_name: 'DPM++ 2M Karras',
      seed: -1,
      restore_faces: true,
      enable_hr: false
    };

    const response = await this.callSDAPI(params);

    // ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®æ¤œè¨¼
    if (!response.images || response.images.length === 0) {
      throw new Error('No images generated by SD API');
    }

    const base64Image = response.images[0];
    console.log('ğŸ¨ Returning base64 image, length:', base64Image.length);

    return base64Image; // æœ€åˆã®ç”»åƒã‚’è¿”ã™
  }

  /**
   * å„ªå…ˆåº¦ä»˜ããƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ§‹ç¯‰
   */
  private buildPrompt(
    character: Character,
    messages: UnifiedMessage[],
    trackers: Array<{
      name: string;
      value: TrackerValueSimple;
      type: 'numeric' | 'state' | 'boolean' | 'text';
    }>,
    customPrompt?: string
  ): { prompt: string; negativePrompt: string } {
    // 1. ãƒˆãƒ©ãƒƒã‚«ãƒ¼ã‹ã‚‰ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆè¦ç´ ã‚’å–å¾—
    const trackerPrompts = TrackerPromptMapper.generateIntegratedPrompt(trackers);

    // 2. ãƒãƒ£ãƒƒãƒˆæ–‡è„ˆã‚’åˆ†æ
    const context = ContextAnalyzer.analyzeRecentMessages(messages, character);

    // 3. ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼åŸºæœ¬æƒ…å ±
    const characterBase = this.extractCharacterPrompts(character);

    // 4. å„ªå…ˆåº¦ä»˜ãã§çµ±åˆ
    const layers = {
      // æœ€å„ªå…ˆï¼šãƒˆãƒ©ãƒƒã‚«ãƒ¼ã®criticalçŠ¶æ…‹ï¼ˆæ‹˜æŸã€æˆ¦é—˜ãªã©ï¼‰
      critical: [
        ...trackerPrompts.critical,
        ...(context.action.filter(a => a.includes('restrained') || a.includes('fighting')))
      ],

      // é«˜å„ªå…ˆï¼šç¾åœ¨ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã¨æ„Ÿæƒ…
      high: [
        ...trackerPrompts.high,
        ...context.action.filter(a => !a.includes('restrained') && !a.includes('fighting')),
        ...context.emotion
      ],

      // ä¸­å„ªå…ˆï¼šã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ç‰¹å¾´
      medium: [
        ...trackerPrompts.medium,
        ...characterBase.appearance,
        ...context.interaction
      ],

      // ä½å„ªå…ˆï¼šç’°å¢ƒã¨åŸºæœ¬è¨­å®š
      low: [
        ...trackerPrompts.low,
        ...context.environment,
        ...characterBase.style
      ]
    };

    // 5. çŸ›ç›¾ã‚’è§£æ±º
    const resolved = this.resolveLayerContradictions(layers);

    // 6. ã‚«ã‚¹ã‚¿ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãŒã‚ã‚‹å ´åˆã¯æœ€å„ªå…ˆã§è¿½åŠ 
    if (customPrompt) {
      resolved.unshift(customPrompt);
    }

    // 7. å“è³ªã‚¿ã‚°ã‚’è¿½åŠ 
    const qualityTags = [
      'masterpiece',
      'best quality',
      'ultra-detailed',
      'high resolution'
    ];

    // 8. æœ€çµ‚ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ§‹ç¯‰
    const finalPrompt = [
      ...qualityTags,
      ...resolved
    ].join(', ');

    // 9. ãƒã‚¬ãƒ†ã‚£ãƒ–ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ§‹ç¯‰
    const negativePrompt = [
      'worst quality',
      'low quality',
      'normal quality',
      'lowres',
      'bad anatomy',
      'bad hands',
      'error',
      'missing fingers',
      'extra digit',
      'fewer digits',
      'cropped',
      'jpeg artifacts',
      'signature',
      'watermark',
      'username',
      'blurry',
      ...trackerPrompts.negative
    ].join(', ');

    return {
      prompt: finalPrompt,
      negativePrompt
    };
  }

  /**
   * ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼æƒ…å ±ã‹ã‚‰ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆè¦ç´ ã‚’æŠ½å‡º
   */
  private extractCharacterPrompts(character: Character): {
    appearance: string[];
    style: string[];
  } {
    const appearance: string[] = [];
    const style: string[] = [];

    // å¤–è¦‹æƒ…å ±ã‚’è§£æ
    if (character.appearance) {
      // é«ªè‰²
      const hairMatch = character.appearance.match(/(é»’|èŒ¶|é‡‘|èµ¤|é’|ç·‘|ç´«|ç™½|éŠ€|ãƒ”ãƒ³ã‚¯)é«ª/);
      if (hairMatch) {
        const colorMap: Record<string, string> = {
          'é»’': 'black hair',
          'èŒ¶': 'brown hair',
          'é‡‘': 'blonde hair',
          'èµ¤': 'red hair',
          'é’': 'blue hair',
          'ç·‘': 'green hair',
          'ç´«': 'purple hair',
          'ç™½': 'white hair',
          'éŠ€': 'silver hair',
          'ãƒ”ãƒ³ã‚¯': 'pink hair'
        };
        appearance.push(colorMap[hairMatch[1]] || 'hair');
      }

      // é«ªå‹
      if (character.appearance.includes('ãƒ­ãƒ³ã‚°')) appearance.push('long hair');
      if (character.appearance.includes('ã‚·ãƒ§ãƒ¼ãƒˆ')) appearance.push('short hair');
      if (character.appearance.includes('ãƒ„ã‚¤ãƒ³ãƒ†ãƒ¼ãƒ«')) appearance.push('twintails');
      if (character.appearance.includes('ãƒãƒ‹ãƒ¼ãƒ†ãƒ¼ãƒ«')) appearance.push('ponytail');

      // ç›®ã®è‰²
      const eyeMatch = character.appearance.match(/(é’|èµ¤|ç·‘|ç´«|èŒ¶|é»’|é‡‘)ã„?ç›®/);
      if (eyeMatch) {
        const colorMap: Record<string, string> = {
          'é’': 'blue eyes',
          'èµ¤': 'red eyes',
          'ç·‘': 'green eyes',
          'ç´«': 'purple eyes',
          'èŒ¶': 'brown eyes',
          'é»’': 'black eyes',
          'é‡‘': 'golden eyes'
        };
        appearance.push(colorMap[eyeMatch[1]] || 'eyes');
      }

      // ä½“å‹
      if (character.appearance.includes('ã‚¹ãƒ¬ãƒ³ãƒ€ãƒ¼')) appearance.push('slender');
      if (character.appearance.includes('å·¨ä¹³')) appearance.push('large breasts');
      if (character.appearance.includes('è²§ä¹³')) appearance.push('flat chest');
      if (character.appearance.includes('å°æŸ„')) appearance.push('petite', 'small body');
      if (character.appearance.includes('é«˜èº«é•·')) appearance.push('tall');
    }

    // ã‚¿ã‚°ã‹ã‚‰è¿½åŠ æƒ…å ±
    if (character.tags) {
      for (const tag of character.tags) {
        switch (tag.toLowerCase()) {
          case 'ã‚¢ã‚¤ãƒ‰ãƒ«':
            style.push('idol', 'stage costume');
            break;
          case 'é­”æ³•å°‘å¥³':
            style.push('magical girl', 'frilly dress');
            break;
          case 'æˆ¦å£«':
            style.push('warrior', 'armor');
            break;
          case 'ãƒ¡ã‚¤ãƒ‰':
            style.push('maid', 'maid outfit');
            break;
          case 'å­¦ç”Ÿ':
            style.push('school uniform', 'student');
            break;
        }
      }
    }

    return { appearance, style };
  }

  /**
   * ãƒ¬ã‚¤ãƒ¤ãƒ¼é–“ã®çŸ›ç›¾ã‚’è§£æ±º
   */
  private resolveLayerContradictions(layers: {
    critical: string[];
    high: string[];
    medium: string[];
    low: string[];
  }): string[] {
    const result: string[] = [];
    const used = new Set<string>();

    // å„ªå…ˆåº¦é †ã«å‡¦ç†
    for (const priority of ['critical', 'high', 'medium', 'low'] as const) {
      for (const prompt of layers[priority]) {
        // é‡è¤‡ãƒã‚§ãƒƒã‚¯
        if (!used.has(prompt)) {
          result.push(prompt);
          used.add(prompt);
        }
      }
    }

    return result;
  }

  /**
   * Stable Diffusion APIã‚’å‘¼ã³å‡ºã—
   */
  private async callSDAPI(params: SDGenerationParams): Promise<SDResponse> {
    try {
      console.log('ğŸ¨ Calling SD API via Next.js route');
      console.log('ğŸ“ Request params:', {
        ...params,
        prompt: params.prompt.substring(0, 100) + '...' // Log truncated prompt
      });

      // Next.js APIãƒ«ãƒ¼ãƒˆã‚’çµŒç”±ã—ã¦SD APIã‚’å‘¼ã³å‡ºã™ï¼ˆCORSå›é¿ï¼‰
      // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’120ç§’ã«è¨­å®š
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 120000); // 120ç§’

      let response;
      try {
        response = await fetch('/api/sd/generate', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(params),
          signal: controller.signal
        });
      } catch (fetchError: unknown) {
        clearTimeout(timeoutId);
        if (fetchError instanceof Error && fetchError.name === 'AbortError') {
          throw new Error('SD API request timed out after 120 seconds. Please check if Stable Diffusion is running and responsive.');
        }
        throw fetchError;
      }

      clearTimeout(timeoutId);

      if (!response.ok) {
        let errorMessage = `SD API Error: ${response.status}`;
        try {
          const errorData = await response.json();
          console.error('âŒ SD API Error Response:', errorData);
          if (errorData && errorData.error) {
            errorMessage = errorData.error;
          }
        } catch (jsonError) {
          // ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒJSONã§ãªã„å ´åˆã€ã¾ãŸã¯ãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼ã®å ´åˆ
          console.error('âŒ Failed to parse error response:', jsonError);
          try {
            const errorText = await response.text();
            if (errorText) {
              errorMessage = `SD API Error: ${errorText}`;
            }
          } catch (textError) {
            console.error('âŒ Failed to read error response:', textError);
          }
        }
        throw new Error(errorMessage);
      }

      const result = await response.json();
      console.log('âœ… SD API Success, received response');

      // SDãƒ¬ã‚¹ãƒãƒ³ã‚¹æ§‹é€ ã‚’ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ã«å‡ºåŠ›
      console.log('ğŸ” SD Response structure:', {
        hasImages: !!result.images,
        imagesCount: result.images?.length,
        firstImagePreview: result.images?.[0]?.substring(0, 50) + '...',
        hasParameters: !!result.parameters,
        hasInfo: !!result.info
      });

      // imagesãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒå­˜åœ¨ã—ãªã„å ´åˆã®äº’æ›æ€§å‡¦ç†
      if (!result.images && result.image) {
        console.warn('ğŸ”„ Converting single image to images array');
        result.images = [result.image];
      }

      if (!result.images || result.images.length === 0) {
        console.error('âŒ No images in SD response:', result);
        throw new Error('SD API returned no images');
      }

      return result;
    } catch (error) {
      console.error('âŒ SD API Call Failed:', error);

      if (error instanceof TypeError && error.message.includes('fetch')) {
        throw new Error('Cannot connect to Stable Diffusion API. Please ensure SD WebUI is running with --api flag');
      }

      if (error instanceof Error) {
        // ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ãã®ã¾ã¾ä½¿ç”¨
        throw error;
      }

      throw new Error('Unknown error occurred while generating image');
    }
  }

  /**
   * ç”»åƒç”Ÿæˆã®é€²æ—ã‚’å–å¾—
   */
  async getProgress(): Promise<{
    progress: number;
    eta_relative: number;
    state: {
      skipped: boolean;
      interrupted: boolean;
      job: string;
      job_count: number;
      job_no: number;
      sampling_step: number;
      sampling_steps: number;
    };
  }> {
    const endpoint = `${this.baseUrl}/sdapi/v1/progress`;
    const response = await fetch(endpoint);

    if (!response.ok) {
      throw new Error(`SD API Error: ${response.status}`);
    }

    return response.json();
  }

  /**
   * åˆ©ç”¨å¯èƒ½ãªãƒ¢ãƒ‡ãƒ«ã‚’å–å¾—
   */
  async getModels(): Promise<Array<{ title: string; model_name: string; hash: string }>> {
    const endpoint = `${this.baseUrl}/sdapi/v1/sd-models`;
    const response = await fetch(endpoint);

    if (!response.ok) {
      throw new Error(`SD API Error: ${response.status}`);
    }

    return response.json();
  }

  /**
   * ç¾åœ¨ã®ãƒ¢ãƒ‡ãƒ«ã‚’åˆ‡ã‚Šæ›¿ãˆ
   */
  async switchModel(modelName: string): Promise<void> {
    const endpoint = `${this.baseUrl}/sdapi/v1/options`;

    const response = await fetch(endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        sd_model_checkpoint: modelName
      })
    });

    if (!response.ok) {
      throw new Error(`SD API Error: ${response.status}`);
    }
  }
}