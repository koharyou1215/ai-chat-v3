'use client';
import React, { useState, useEffect, useRef, useMemo } from 'react';
// „Ç∑„É≥„Éó„É´„Å™„Çπ„Éî„Éä„Éº
const Spinner: React.FC<{ label?: string }> = ({ label }) => (
  <div style={{ position: 'absolute', inset: 0, display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 20, pointerEvents: 'none' }}>
    <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-blue-400" />
    {label && <span className="ml-3 text-white/80 text-xs bg-black/40 px-2 py-1 rounded">{label}</span>}
  </div>
);
import { motion, AnimatePresence, TargetAndTransition } from 'framer-motion';
import { RefreshCw, Copy, Volume2, Pause, Edit, CornerUpLeft, X, MoreVertical, MoreHorizontal } from 'lucide-react';
import { UnifiedMessage } from '@/types';
import { useAppStore } from '@/store';
import { cn } from '@/lib/utils';
import { replaceVariablesInMessage, getVariableContext } from '@/utils/variable-replacer';
import { RichMessage } from './RichMessage';
import { MessageEffects } from './MessageEffects';
import { HologramMessage, ParticleText } from './AdvancedEffects';
import { EmotionDisplay, EmotionReactions } from '@/components/emotion/EmotionDisplay';
import { EmotionResult } from '@/services/emotion/EmotionAnalyzer';
import { useAudioPlayback } from '@/hooks/useAudioPlayback';

interface MessageBubbleProps {
  message: UnifiedMessage;
  previousMessage?: UnifiedMessage;
  isLatest: boolean;
  isGroupChat?: boolean;
}

export const MessageBubble: React.FC<MessageBubbleProps> = React.memo(({ 
  message, 
  previousMessage: _previousMessage,
  isLatest,
  isGroupChat = false
}) => {
  // „É≠„Éº„Éá„Ç£„É≥„Ç∞„ÉªÂÜçÁîüÁä∂ÊÖã
  const [isRegenerating, setIsRegenerating] = useState(false);
  const [isContinuing, setIsContinuing] = useState(false);
  const { isSpeaking, handleSpeak } = useAudioPlayback({ message, isLatest });
  
  // **Zustand„Çπ„Éà„Ç¢„Åã„Çâ„ÅÆÂèñÂæó„ÇíÊúÄÈÅ©Âåñ**
  const characters = useAppStore(state => state.characters);
  const getSelectedPersona = useAppStore(state => state.getSelectedPersona);
  const _deleteMessage = useAppStore(state => state.deleteMessage);
  const regenerateLastMessage = useAppStore(state => state.regenerateLastMessage);
  const is_generating = useAppStore(state => state.is_generating); // „ÇΩ„É≠„ÉÅ„É£„ÉÉ„ÉàÁîüÊàêÁä∂ÊÖã
  const group_generating = useAppStore(state => state.group_generating); // „Ç∞„É´„Éº„Éó„ÉÅ„É£„ÉÉ„ÉàÁîüÊàêÁä∂ÊÖã
  // Lazy imports handled within functions where they're needed
  const trackerManagers = useAppStore(state => state.trackerManagers);
  const activeSessionId = useAppStore(state => state.active_session_id);
  const rollbackSession = useAppStore(state => state.rollbackSession); // Êñ∞„Åó„ÅÑ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíÂèñÂæó
  const rollbackGroupSession = useAppStore(state => state.rollbackGroupSession); // „Ç∞„É´„Éº„ÉóÁî®„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíÂèñÂæó
  const activeCharacterId = useAppStore(state => state.active_character_id);
  const _clearActiveConversation = useAppStore(state => state.clearActiveConversation);
  const _clearLayer = useAppStore(state => state.clearLayer);
  const _addMessageToLayers = useAppStore(state => state.addMessageToLayers);

  const isUser = message.role === 'user';
  const persona = getSelectedPersona();
  const character = characters.get(message.character_id || '');
  
  // Â§âÊï∞ÁΩÆÊèõ„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„ÇíÂèñÂæó
  const variableContext = getVariableContext(useAppStore.getState);
  
  // „É°„ÉÉ„Çª„Éº„Ç∏ÂÜÖÂÆπ„ÅÆÂ§âÊï∞ÁΩÆÊèõ
  const processedContent = replaceVariablesInMessage(message.content, variableContext);

  // üé≠ „Ç∞„É´„Éº„Éó„ÉÅ„É£„ÉÉ„ÉàÂØæÂøú„ÅÆÊîπÂñÑ„Åï„Çå„Åü„Ç≠„É£„É©„ÇØ„Çø„ÉºÊÉÖÂ†±ÂèñÂæó
  const { avatarUrl, displayName, initial, characterColor } = useMemo(() => {
    if (isUser) {
      return {
        avatarUrl: persona?.avatar_url,
        displayName: persona?.name,
        initial: persona?.name?.[0] || 'U',
        characterColor: '#3b82f6' // „É¶„Éº„Ç∂„ÉºÁî®ÈùíËâ≤
      };
    }
    
    // „Ç∞„É´„Éº„Éó„ÉÅ„É£„ÉÉ„ÉàÔºö„É°„ÉÉ„Çª„Éº„Ç∏„Å´Âüã„ÇÅËæº„Åæ„Çå„Åü„Ç≠„É£„É©„ÇØ„Çø„ÉºÊÉÖÂ†±„ÇíÂÑ™ÂÖà‰ΩøÁî®
    if (isGroupChat && (message.character_name || message.character_avatar)) {
      const name = message.character_name || character?.name || 'AI';
      const avatar = message.character_avatar || character?.avatar_url;
      const colorHash = message.character_id ? message.character_id.slice(-6) : 'purple';
      const color = `#${colorHash.padEnd(6, '0').slice(0, 6)}`;
      
      return {
        avatarUrl: avatar,
        displayName: name,
        initial: name[0]?.toUpperCase() || 'A',
        characterColor: color
      };
    }
    
    // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºöÈÄöÂ∏∏„ÅÆ„Ç≠„É£„É©„ÇØ„Çø„ÉºÂèñÂæó
    const name = character?.name || 'AI';
    return {
      avatarUrl: character?.avatar_url,
      displayName: name,
      initial: name[0]?.toUpperCase() || 'A',
      characterColor: '#8b5cf6' // „Éá„Éï„Ç©„É´„ÉàÁ¥´Ëâ≤
    };
  }, [isUser, persona, character, isGroupChat, message.character_name, message.character_avatar, message.character_id]);
  
  // --- „Ç¢„ÇØ„Ç∑„Éß„É≥„Éè„É≥„Éâ„É©Áæ§ ---
  // ÂÜçÁîüÊàêÊú¨ÂÆüË£ÖÔºà„ÇΩ„É≠„Éª„Ç∞„É´„Éº„ÉóÂàÜÈõ¢Ôºâ
  const handleRegenerate = async () => {
    setIsRegenerating(true);
    try {
      const state = useAppStore.getState();
      if (state.is_group_mode && state.active_group_session_id) {
        // „Ç∞„É´„Éº„Éó„ÉÅ„É£„ÉÉ„ÉàÁî®ÂÜçÁîüÊàê
        await state.regenerateLastGroupMessage();
      } else {
        // „ÇΩ„É≠„ÉÅ„É£„ÉÉ„ÉàÁî®ÂÜçÁîüÊàê
        await regenerateLastMessage();
      }
    } finally {
      setIsRegenerating(false);
    }
  };
  // Á∂ö„Åç„ÇíÂá∫ÂäõÊú¨ÂÆüË£ÖÔºà„ÇΩ„É≠„Éª„Ç∞„É´„Éº„ÉóÂàÜÈõ¢Ôºâ
  const handleContinue = async () => {
    setIsContinuing(true);
    try {
      const state = useAppStore.getState();
      if (state.is_group_mode && state.active_group_session_id) {
        // „Ç∞„É´„Éº„Éó„ÉÅ„É£„ÉÉ„ÉàÁî®Á∂ö„Åç„ÇíÁîüÊàê
        await state.continueLastGroupMessage();
      } else {
        // „ÇΩ„É≠„ÉÅ„É£„ÉÉ„ÉàÁî®Á∂ö„Åç„ÇíÁîüÊàêÔºàÊó¢Â≠ò„ÅÆË§áÈõë„Å™ÂÆüË£Ö„ÇíÁ∂≠ÊåÅÔºâ
        const session = state.sessions.get(activeSessionId || '');
        if (!session) return;
        const trackerManager = trackerManagers.get(activeSessionId || '');
        // ÊúÄÂæå„ÅÆAI„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÊé¢„Åô
        const lastAiMsg = [...session.messages].reverse().find(m => m.role === 'assistant');
        if (!lastAiMsg) {
          alert('AI„É°„ÉÉ„Çª„Éº„Ç∏„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
          return;
        }
        // „Éó„É≠„É≥„Éó„Éà„ÇíÂÜçÊßãÁØâ„Åó„ÄÅAIÂøúÁ≠î„ÅÆ„ÅøÁîüÊàê
        const { promptBuilderService } = await import('@/services/prompt-builder.service');
        const { apiManager } = await import('@/services/api-manager');
        
        const systemPrompt = await promptBuilderService.buildPrompt(
          session,
          lastAiMsg.content,
          trackerManager
        );
        const aiResponseContent = await apiManager.generateMessage(
          systemPrompt,
          lastAiMsg.content,
          session.messages.slice(-10).filter(msg => msg.role === 'user' || msg.role === 'assistant').map(msg => ({ role: msg.role as 'user' | 'assistant', content: msg.content }))
        );
        // AI„É°„ÉÉ„Çª„Éº„Ç∏„ÇíËøΩÂä†
        const newMessage = {
          ...lastAiMsg,
          id: `ai-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
          content: aiResponseContent,
          regeneration_count: (lastAiMsg.regeneration_count || 0) + 1
        };
        useAppStore.setState(state => {
          const updatedSession = {
            ...session,
            messages: [...session.messages, newMessage],
            message_count: session.message_count + 1,
            updated_at: new Date().toISOString(),
          };
          return {
            sessions: new Map(state.sessions).set(session.id, updatedSession)
          };
        });
      }
    } finally {
      setIsContinuing(false);
    }
  };
  const handleCopy = () => {
    navigator.clipboard.writeText(processedContent);
  };

  const [isEditing, setIsEditing] = useState(false);
  const [editText, setEditText] = useState(processedContent);
  const [showEditOptions, setShowEditOptions] = useState(false);
  
  const handleEdit = () => {
    setIsEditing(true);
    setEditText(processedContent);
  };
  
  const handleSaveEdit = async (shouldRegenerate = false) => {
    if (editText.trim() === '') return;
    
    const session = useAppStore.getState().sessions.get(activeSessionId || '');
    if (!session) return;
    
    const updatedMessages = session.messages.map(msg => 
      msg.id === message.id 
        ? { 
            ...msg, 
            content: editText.trim(),
            updated_at: new Date().toISOString(),
            edit_history: [
              ...msg.edit_history,
              {
                previous_content: message.content,
                edited_at: new Date().toISOString(),
                edit_reason: 'user_edit'
              }
            ]
          }
        : msg
    );
    
    useAppStore.setState(state => ({
      sessions: new Map(state.sessions).set(session.id, {
        ...session,
        messages: updatedMessages,
        updated_at: new Date().toISOString(),
      })
    }));
    
    setIsEditing(false);
    
    // Á∑®ÈõÜÂæå„Å´ÂÜçÁîüÊàê„Åô„ÇãÂ†¥Âêà
    if (shouldRegenerate) {
      // Á∑®ÈõÜ„Åï„Çå„Åü„É°„ÉÉ„Çª„Éº„Ç∏‰ª•Èôç„ÇíÂâäÈô§„Åó„Å¶„Åã„ÇâÂÜçÁîüÊàê
      const messageIndex = session.messages.findIndex(msg => msg.id === message.id);
      if (messageIndex !== -1) {
        const truncatedMessages = updatedMessages.slice(0, messageIndex + 1);
        
        useAppStore.setState(state => ({
          sessions: new Map(state.sessions).set(session.id, {
            ...session,
            messages: truncatedMessages,
            message_count: truncatedMessages.length,
            updated_at: new Date().toISOString(),
          })
        }));
        
        // ÂÜçÁîüÊàê„ÇíÂÆüË°å
        try {
          await useAppStore.getState().regenerateLastMessage();
        } catch (error) {
          console.error('ÂÜçÁîüÊàê„Ç®„É©„Éº:', error);
        }
      }
    }
  };
  
  const handleCancelEdit = () => {
    setIsEditing(false);
    setEditText(processedContent);
  };
  // „Åì„Åì„Åæ„ÅßÊàª„ÇãÊú¨ÂÆüË£Ö (Êñ∞„Åó„ÅÑ„É≠„ÉÉ„ÇØ„Å´Êõ¥Êñ∞)
  const handleRollback = () => {
    if (!message.id) {
      alert('„É°„ÉÉ„Çª„Éº„Ç∏ID„ÅåÂèñÂæó„Åß„Åç„Åæ„Åõ„Çì');
      return;
    }
    
    const confirmMessage = isGroupChat
      ? '„Åì„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„Åæ„Åß„Ç∞„É´„Éº„Éó„ÉÅ„É£„ÉÉ„Éà„ÅÆÂ±•Ê≠¥„ÇíÊàª„Åó„Åæ„Åô„ÅãÔºü'
      : '„Åì„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„Åæ„Åß‰ºöË©±Â±•Ê≠¥„ÇíÊàª„Åó„Åæ„Åô„ÅãÔºü\nÔºà„É°„É¢„É™„ÇÑ„Ç≠„É£„É©„ÇØ„Çø„Éº„ÅÆÈñ¢‰øÇÂÄ§„ÇÇ„Åì„ÅÆÊôÇÁÇπ„ÅÆÁä∂ÊÖã„Å´Ëøë„Å•„Åè„Çà„ÅÜ„Å´„É™„Çª„ÉÉ„Éà„Åï„Çå„Åæ„ÅôÔºâ';
      
    if (confirm(confirmMessage)) {
      if (isGroupChat) {
        rollbackGroupSession(message.id);
      } else {
        rollbackSession(message.id);
      }
      alert('„Åì„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„Åæ„ÅßÂ∑ª„ÅçÊàª„Åó„Åæ„Åó„Åü');
    }
  };
  /*
  // „Ç™„Éº„É´„ÇØ„É™„Ç¢Êú¨ÂÆüË£Ö
  const handleClearAll = () => {
    // „ÉÅ„É£„ÉÉ„ÉàÂ±•Ê≠¥„ÇØ„É™„Ç¢
    clearActiveConversation();
    // „É°„É¢„É™„É¨„Ç§„É§„ÉºÂÖ®„ÇØ„É™„Ç¢
    ['immediate_memory','working_memory','episodic_memory','semantic_memory','permanent_memory'].forEach(layer => {
      clearLayer(layer);
    });
    // „Éà„É©„ÉÉ„Ç´„ÉºÔºöÁèæÂú®„ÅÆ„Ç≠„É£„É©„ÇØ„Çø„Éº„ÅÆ„Åø„É™„Çª„ÉÉ„Éà
    if (activeSessionId && trackerManagers.has(activeSessionId) && activeCharacterId) {
      const manager = trackerManagers.get(activeSessionId);
      if (manager) {
        manager.initializeTrackerSet(activeCharacterId, []); // „Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Ç≠„É£„É©„ÅÆ„ÅøÂàùÊúüÂåñ
      }
    }
    alert('„Åì„ÅÆ„Ç≠„É£„É©„ÇØ„Çø„Éº„ÅÆ„ÉÅ„É£„ÉÉ„Éà„Éª„É°„É¢„É™„Éª„Éà„É©„ÉÉ„Ç´„Éº„ÇíÂÖ®„Å¶„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åó„Åü');
  };
  */

  // ÂÄãÂà•„É°„ÉÉ„Çª„Éº„Ç∏ÂâäÈô§Ê©üËÉΩ
  const handleDeleteMessage = () => {
    if (!confirm('„Åì„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü')) return;
    
    const session = useAppStore.getState().sessions.get(activeSessionId || '');
    if (!session) return;
    
    const updatedMessages = session.messages.filter(msg => msg.id !== message.id);
    
    useAppStore.setState(state => ({
      sessions: new Map(state.sessions).set(session.id, {
        ...session,
        messages: updatedMessages,
        message_count: updatedMessages.length,
        updated_at: new Date().toISOString(),
      })
    }));
    
    // „É°„É¢„É™„É¨„Ç§„É§„Éº„Åã„Çâ„ÇÇÂâäÈô§„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÈô§ÂéªÔºàÁ∞°ÊòìÁâàÔºâ
    // TODO: „Çà„ÇäÁ≤æÂØÜ„Å™„É°„É¢„É™ÁÆ°ÁêÜ„ÅåÂøÖË¶Å„Å™Â†¥Âêà„ÅØÊã°Âºµ
    alert('„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂâäÈô§„Åó„Åæ„Åó„Åü');
  };
  
  // „É°„Éã„É•„ÉºË°®Á§∫‰ΩçÁΩÆ„ÇíÁ¢∫Ë™çÔºà‰∏ä„Åã‰∏ã„ÅãÔºâ
  const checkMenuPosition = () => {
    if (messageRef.current) {
      const rect = messageRef.current.getBoundingClientRect();
      const windowHeight = window.innerHeight;
      const spaceBelow = windowHeight - rect.bottom;
      const menuHeight = 60; // „É°„Éã„É•„Éº„ÅÆ„Åä„Åä„Çà„Åù„ÅÆÈ´ò„Åï
      
      setMenuPosition(spaceBelow < menuHeight ? 'top' : 'bottom');
    }
  };
  const [showActions, setShowActions] = useState(false);
  const [formattedTimestamp, setFormattedTimestamp] = useState('');
  const [effectTrigger, setEffectTrigger] = useState('');
  const [effectPosition, setEffectPosition] = useState({ x: 0, y: 0 });
  const [menuPosition, setMenuPosition] = useState<'bottom' | 'top'>('bottom');
  const messageRef = useRef<HTMLDivElement>(null);
  const [detectedEmotion, setDetectedEmotion] = useState<EmotionResult | null>(null);
  const { effectSettings } = useAppStore();
  
  // „Ç®„Éï„Çß„ÇØ„Éà„ÅÆ„Éà„É™„Ç¨„ÉºË®≠ÂÆö
  useEffect(() => {
    if (effectSettings.particleEffects && isLatest && effectTrigger !== message.content) {
      setEffectTrigger(message.content);
      // ‰ΩçÁΩÆ„ÅØÁîªÈù¢‰∏≠Â§Æ‰ªòËøë„Å´Ë®≠ÂÆö
      setEffectPosition({
        x: window.innerWidth / 2,
        y: window.innerHeight / 2
      });
    }
  }, [message.content, isLatest, effectSettings.particleEffects, effectTrigger]);

  
  useEffect(() => {
    if (typeof window !== 'undefined') {
      const { languageSettings } = useAppStore.getState();
      const locale = languageSettings?.language === 'ja' ? 'ja-JP' : 
                    languageSettings?.language === 'zh' ? 'zh-CN' :
                    languageSettings?.language === 'ko' ? 'ko-KR' : 'en-US';
      
      setFormattedTimestamp(
        new Date(message.created_at).toLocaleTimeString(locale, {
          hour: '2-digit',
          minute: '2-digit',
          hour12: languageSettings?.timeFormat === '12' || false,
          timeZone: languageSettings?.timezone || 'Asia/Tokyo'
        })
      );
    }
  }, [message.created_at]);
  

  // ÂãïÁöÑÁµµÊñáÂ≠ó„ÅÆÊ±∫ÂÆö
  const getDynamicEmoji = () => {
    const emotion = message.expression?.emotion;
    if (!emotion) return 'ü§î'; // „Éá„Éï„Ç©„É´„Éà

    const emojiMap: { [key: string]: string[] } = {
      happy: ['üòä', 'üòÑ', 'üòÉ', 'üôÇ', 'üòå', '‚ò∫Ô∏è'],
      love: ['üòç', 'ü•∞', 'üíï', '‚ù§Ô∏è', 'üòò', 'üíñ'],
      sad: ['üò¢', 'üòû', 'üòî', 'üòü', 'üòø', 'üíî'],
      excited: ['ü§©', 'üòÜ', 'üéâ', '‚ú®', 'üî•', '‚ö°'],
      angry: ['üò†', 'üò°', 'üí¢', 'üëø', 'üò§', 'üî¥'],
      surprised: ['üò≤', 'üòÆ', 'üòØ', 'ü§Ø', 'üòµ', 'üôÄ'],
      thinking: ['ü§î', 'üí≠', 'üßê', 'üí°', 'ü§Ø', 'üéØ'],
      confused: ['üòï', 'ü§®', 'üòµ‚Äçüí´', 'üò∂', 'üôÑ', '‚ùì'],
      neutral: ['üòê', 'üòë', 'üôÇ', 'üòä', 'ü§î', 'üòå']
    };

    const emojis = emojiMap[emotion.primary] || emojiMap.neutral;
    const intensity = emotion.score ?? emotion.intensity ?? 0.5;
    const index = Math.floor(intensity * emojis.length);
    
    return emojis[Math.min(index, emojis.length - 1)];
  };

  // ÊÑüÊÉÖ„Å´Âü∫„Å•„Åè„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÂäπÊûúÔºàÂÆâÂÖ®„Å™ÂÆüË£ÖÔºâ
  const getEmotionAnimation = (): TargetAndTransition => {
    const emotion = message.expression?.emotion;
    if (!emotion || !effectSettings.emotionBasedStyling || effectSettings.effectQuality === 'low') return {};

    // „Çª„Éº„Éï„É¢„Éº„ÉâÊ§úÂá∫
    const safeMode = typeof window !== 'undefined' && localStorage.getItem('safe-mode') === 'true';
    if (safeMode) return {};

    // ÁÑ°Èôê„É´„Éº„Éó„ÇíÈÅø„Åë„Å¶ÈôêÂÆöÂõûÊï∞„ÅÆ„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
    const animationMap: { [key: string]: TargetAndTransition } = {
      happy: { 
        scale: [1, 1.01, 1], 
        transition: { duration: 2, repeat: 2, repeatType: 'reverse' as const, ease: 'easeInOut' } 
      },
      love: { 
        scale: [1, 1.015, 1], 
        transition: { duration: 3, repeat: 1, repeatType: 'reverse' as const, ease: 'easeInOut' }
      },
      excited: { 
        y: [0, -1, 0], 
        transition: { duration: 1.5, repeat: 1, repeatType: 'reverse' as const, ease: 'easeInOut' }
      },
      sad: { 
        opacity: [1, 0.9, 1], 
        transition: { duration: 2.5, repeat: 1, repeatType: 'reverse' as const, ease: 'easeInOut' } 
      }
    };

    return animationMap[emotion.primary] || {};
  };

  return (
    <>
      <motion.div
        ref={messageRef}
        initial={isLatest ? { opacity: 0, y: 20 } : false}
        animate={{ opacity: 1, y: 0 }}
        exit={{ opacity: 0, y: -20 }}
        className={cn(
          'flex gap-3',
          isUser ? 'justify-end' : 'justify-start'
        )}
        // „É°„Éã„É•„Éº„ÅØ„ÇØ„É™„ÉÉ„ÇØ„ÅßË°®Á§∫/ÈùûË°®Á§∫„ÇíÂàá„ÇäÊõø„Åà„Çã„ÅÆ„Åß„ÄÅ„Éê„Éñ„É´Ëá™‰Ωì„ÅØ„Çø„ÉÉ„ÉÅ„Ç§„Éô„É≥„Éà„ÇíÂá¶ÁêÜ„Åó„Å™„ÅÑ
        style={{ position: 'relative' }}
      >
      {/* „Ç¢„Éê„Çø„Éº */}
      {!isUser && (character || (isGroupChat && message.character_name)) && (
        <motion.div
          initial={isLatest ? { scale: 0 } : false}
          animate={{ scale: 1 }}
          className="flex-shrink-0"
        >
          <div className="flex flex-col items-center">
            <div 
              className="w-10 h-10 rounded-full flex items-center justify-center ring-2 ring-opacity-60"
              style={{
                background: isGroupChat && characterColor 
                  ? (() => {
                      const color = characterColor.replace('#', '');
                      const r = parseInt(color.slice(0, 2), 16);
                      const g = parseInt(color.slice(2, 4), 16);
                      const b = parseInt(color.slice(4, 6), 16);
                      return `linear-gradient(135deg, rgba(${r}, ${g}, ${b}, 0.9) 0%, rgba(${Math.min(r + 40, 255)}, ${Math.min(g + 30, 255)}, ${Math.min(b + 50, 255)}, 0.9) 100%)`;
                    })()
                  : 'linear-gradient(135deg, rgba(168, 85, 247, 0.9) 0%, rgba(236, 72, 153, 0.9) 100%)',
                boxShadow: `0 0 0 2px ${isGroupChat && characterColor ? characterColor + '60' : 'rgba(168, 85, 247, 0.6)'}`
              }}
            >
              {avatarUrl ? (
                // eslint-disable-next-line @next/next/no-img-element
                <img 
                  src={avatarUrl} 
                  alt={displayName}
                  className="w-full h-full rounded-full object-cover"
                />
              ) : (
                <span className="text-white text-sm font-bold">
                  {initial}
                </span>
              )}
            </div>
            {/* üé≠ ÊîπÂñÑ„Åï„Çå„Åü„Ç∞„É´„Éº„Éó„ÉÅ„É£„ÉÉ„Éà„Ç≠„É£„É©„ÇØ„Çø„ÉºÂêçË°®Á§∫ */}
            {isGroupChat && displayName && !isUser && (
              <motion.div
                initial={isLatest ? { opacity: 0, y: -5 } : false}
                animate={{ opacity: 1, y: 0 }}
                className="mt-1 text-center"
              >
                <span 
                  className="text-xs font-medium px-2 py-1 rounded-full bg-black/20 border max-w-[80px] truncate inline-block"
                  style={{ 
                    borderColor: characterColor + '40',
                    color: characterColor,
                    backgroundColor: characterColor + '15'
                  }}
                  title={displayName}
                >
                  {displayName}
                </span>
              </motion.div>
            )}
          </div>
        </motion.div>
      )}

      {isUser && persona && (
         <motion.div
          initial={isLatest ? { scale: 0 } : false}
          animate={{ scale: 1 }}
          className="flex-shrink-0"
        >
          <div 
            className="w-10 h-10 rounded-full flex items-center justify-center ring-2 ring-blue-400 ring-opacity-60"
            style={{
              background: isGroupChat 
                ? 'linear-gradient(135deg, rgba(37, 99, 235, 0.9) 0%, rgba(6, 182, 212, 0.9) 100%)'
                : 'linear-gradient(135deg, rgba(59, 130, 246, 0.9) 0%, rgba(6, 182, 212, 0.9) 100%)',
            }}
          >
            {avatarUrl ? (
              // eslint-disable-next-line @next/next/no-img-element
              <img 
                src={avatarUrl} 
                alt={displayName}
                className="w-full h-full rounded-full object-cover"
              />
            ) : (
              <span className="text-white text-sm font-bold">
                {initial}
              </span>
            )}
          </div>
        </motion.div>
      )}

      {/* „É°„ÉÉ„Çª„Éº„Ç∏Êú¨‰Ωì */}
      <div className={cn(
        'group relative max-w-[70%] transition-all duration-200',
        isUser && 'items-end'
      )}>
        {/* „É≠„Éº„Éá„Ç£„É≥„Ç∞„ÉªÂÜçÁîü„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ */}
        {(isRegenerating || isContinuing || isSpeaking) && (
          <Spinner label={isRegenerating ? 'ÂÜçÁîüÊàê‰∏≠...' : isContinuing ? 'Á∂ö„Åç„ÇíÂá∫Âäõ‰∏≠...' : 'Èü≥Â£∞ÂÜçÁîü‰∏≠...'} />
        )}
        {/* „É°„ÉÉ„Çª„Éº„Ç∏„Éê„Éñ„É´ */}
        <motion.div
          className={cn(
            'relative px-4 py-3 rounded-2xl',
            effectSettings.bubbleBlur ? 'backdrop-blur-md' : '',
          )}
          style={{
            background: isUser 
              ? `linear-gradient(135deg, rgba(37, 99, 235, ${(100 - effectSettings.bubbleOpacity) / 100}) 0%, rgba(6, 182, 212, ${(100 - effectSettings.bubbleOpacity) / 100}) 100%)` // ÈÄèÊòéÂ∫¶„Çí‰øÆÊ≠£
              : isGroupChat && characterColor && characterColor !== '#8b5cf6'
                ? (() => {
                    const color = characterColor.replace('#', '');
                    const r = parseInt(color.slice(0, 2), 16);
                    const g = parseInt(color.slice(2, 4), 16);
                    const b = parseInt(color.slice(4, 6), 16);
                    const opacity = (100 - effectSettings.bubbleOpacity) / 100; // ÈÄèÊòéÂ∫¶„Çí‰øÆÊ≠£: bubbleOpacity„ÅåÈ´ò„ÅÑ„Åª„Å©ÈÄèÊòé„Å´
                    return `linear-gradient(135deg, rgba(${r}, ${g}, ${b}, ${opacity}) 0%, rgba(${Math.min(r + 30, 255)}, ${Math.min(g + 20, 255)}, ${Math.min(b + 40, 255)}, ${opacity}) 100%)`;
                  })()
                : `linear-gradient(135deg, rgba(168, 85, 247, ${(100 - effectSettings.bubbleOpacity) / 100}) 0%, rgba(236, 72, 153, ${(100 - effectSettings.bubbleOpacity) / 100}) 100%)`, // ÈÄèÊòéÂ∫¶„Çí‰øÆÊ≠£
            borderColor: isUser 
              ? 'rgba(255, 255, 255, 0.2)' 
              : isGroupChat && characterColor 
                ? `${characterColor}40` // ÈÄèÊòéÂ∫¶„ÇíÂ∞ë„Åó‰∏ä„Åí„Çã
                : 'rgba(255, 255, 255, 0.2)',
            boxShadow: isUser 
              ? '0 0 30px rgba(59, 130, 246, 0.1)' // ÂΩ±„ÇíÂ∞ë„ÅóÂº±„ÇÅ„Çã
              : isGroupChat && characterColor
                ? `0 0 30px ${characterColor}20` // ÂΩ±„ÇíÂ∞ë„ÅóÂº±„ÇÅ„Çã
                : '0 0 30px rgba(168, 85, 247, 0.1)' // ÂΩ±„ÇíÂ∞ë„ÅóÂº±„ÇÅ„Çã
          }}
          animate={
            !isUser && 
            effectSettings.emotionBasedStyling && 
            !effectSettings.typewriterEffect && 
            !effectSettings.particleEffects 
              ? getEmotionAnimation()
              : {}
          }
        >
          {/* ÈáçË¶ÅÂ∫¶„Ç§„É≥„Ç∏„Ç±„Éº„Çø„Éº */}
          {message.memory.importance.score > 0.8 && (
            <motion.div
              initial={isLatest ? { scale: 0 } : false}
              animate={{ scale: 1 }}
              className="absolute -top-2 -right-2 w-4 h-4 bg-yellow-500 rounded-full"
              title="ÈáçË¶Å„Å™„É°„ÉÉ„Çª„Éº„Ç∏"
            />
          )}

          {/* 3D„Éõ„É≠„Ç∞„É©„É†„É°„ÉÉ„Çª„Éº„Ç∏ - AI„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆ„Åø */}
          {!isUser && effectSettings.hologramMessages && isLatest ? (
            <HologramMessage text={processedContent} />
          ) : (
            <>
              {/* ÁîªÂÉèË°®Á§∫ */}
              {message.image_url && (
                <div className="mb-3">
                  {/* eslint-disable-next-line @next/next/no-img-element */}
                  <img
                    src={message.image_url}
                    alt="Attached image"
                    className="max-w-full max-h-64 rounded-lg object-contain"
                  />
                </div>
              )}

              {/* „É°„ÉÉ„Çª„Éº„Ç∏„ÉÜ„Ç≠„Çπ„Éà - Á∑®ÈõÜ„É¢„Éº„Éâ„Å®ÈÄöÂ∏∏Ë°®Á§∫ */}
              {isEditing ? (
                <div className="space-y-2">
                  <textarea
                    value={editText}
                    onChange={(e) => setEditText(e.target.value)}
                    className="w-full bg-black/20 text-white/90 border border-purple-400/30 rounded p-2 min-h-[100px] resize-none focus:outline-none focus:border-purple-400/60"
                    placeholder="„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÁ∑®ÈõÜ..."
                  />
                  <div className="flex gap-2 justify-end">
                    <button
                      onClick={handleCancelEdit}
                      className="px-3 py-1 bg-gray-600 hover:bg-gray-700 text-white text-sm rounded transition-colors"
                    >
                      „Ç≠„É£„É≥„Çª„É´
                    </button>
                    <button
                      onClick={() => setShowEditOptions(true)}
                      className="px-3 py-1 bg-blue-600 hover:bg-blue-700 text-white text-sm rounded transition-colors"
                    >
                      ‰øùÂ≠ò
                    </button>
                  </div>
                  
                  {/* Á∑®ÈõÜ„Ç™„Éó„Ç∑„Éß„É≥ÈÅ∏Êäû */}
                  {showEditOptions && (
                    <div className="mt-2 p-3 bg-black/30 rounded border border-purple-400/30">
                      <p className="text-sm text-white/70 mb-2">Á∑®ÈõÜÂæå„ÅÆÂãï‰Ωú„ÇíÈÅ∏Êäû:</p>
                      <div className="flex gap-2">
                        <button
                          onClick={() => {
                            handleSaveEdit(false);
                            setShowEditOptions(false);
                          }}
                          className="px-3 py-1 bg-blue-600 hover:bg-blue-700 text-white text-sm rounded transition-colors"
                        >
                          ‰øùÂ≠ò„ÅÆ„Åø
                        </button>
                        <button
                          onClick={() => {
                            handleSaveEdit(true);
                            setShowEditOptions(false);
                          }}
                          className="px-3 py-1 bg-green-600 hover:bg-green-700 text-white text-sm rounded transition-colors"
                        >
                          ‰øùÂ≠ò„Åó„Å¶ÂÜçÁîüÊàê
                        </button>
                        <button
                          onClick={() => setShowEditOptions(false)}
                          className="px-2 py-1 bg-gray-600 hover:bg-gray-700 text-white text-sm rounded transition-colors"
                        >
                          √ó
                        </button>
                      </div>
                    </div>
                  )}
                </div>
              ) : (
                <>
                  {!isUser && (effectSettings.colorfulBubbles || effectSettings.fontEffects || effectSettings.typewriterEffect) ? (
                    <RichMessage
                      key={`${message.id}-${processedContent.length}`} // key„ÇíËøΩÂä†„Åó„Å¶ÂÜç„É¨„É≥„ÉÄ„É™„É≥„Ç∞„ÇíÂà∂Âæ°
                      content={processedContent}
                      role={message.role as 'user' | 'assistant'}
                      characterColor='#8b5cf6'
                      enableEffects={isLatest && effectSettings.typewriterEffect} // „Çø„Ç§„Éó„É©„Ç§„Çø„ÉºÂäπÊûú„ÅÆÊù°‰ª∂„ÇíÊòéÁ¢∫Âåñ
                      typingSpeed={isLatest && effectSettings.typewriterEffect ? 30 : 0}
                    />
                  ) : isUser && (effectSettings.colorfulBubbles || effectSettings.fontEffects) ? (
                    <RichMessage
                      key={`${message.id}-${processedContent.length}`} // key„ÇíËøΩÂä†„Åó„Å¶ÂÜç„É¨„É≥„ÉÄ„É™„É≥„Ç∞„ÇíÂà∂Âæ°
                      content={processedContent}
                      role={message.role as 'user' | 'assistant'}
                      characterColor='#3b82f6'
                      enableEffects={false} // „É¶„Éº„Ç∂„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÅØ„Çø„Ç§„Éó„É©„Ç§„Çø„ÉºÂäπÊûúÁÑ°Âäπ
                      typingSpeed={0}
                    />
                  ) : (
                    <div className="text-white/90 whitespace-pre-wrap select-none">
                      {processedContent}
                    </div>
                  )}
                </>
              )}
            </>
          )}

          {/* „Éë„Éº„ÉÜ„Ç£„ÇØ„É´„ÉÜ„Ç≠„Çπ„Éà„Ç®„Éï„Çß„ÇØ„Éà - AI„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆ„Åø */}
          {!isUser && effectSettings.particleText && isLatest && (
            <ParticleText 
              text={processedContent} 
              trigger={effectTrigger.length > 0}
            />
          )}

          {/* ÊÑüÊÉÖÂàÜÊûêË°®Á§∫ - AI„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆ„Åø */}
          {!isUser && effectSettings.realtimeEmotion && (
            <div className="mt-2">
              <EmotionDisplay
                message={processedContent}
                onEmotionDetected={(emotion) => {
                  setDetectedEmotion(emotion);
                  // „Ç®„Éï„Çß„ÇØ„Éà„Éà„É™„Ç¨„Éº„ÅÆÊõ¥Êñ∞
                  if (emotion.intensity > 0.7) {
                    setEffectTrigger(processedContent);
                  }
                }}
              />
            </div>
          )}

          {/* ÊÑüÊÉÖ„Çø„Ç∞ÔºàÂãïÁöÑÁµµÊñáÂ≠ó‰ªò„ÅçÔºâ */}
          {!effectSettings.realtimeEmotion && message.expression?.emotion && (
            <div className="mt-2 flex gap-1">
              <motion.span 
                className="text-xs px-2 py-0.5 bg-white/10 rounded-full text-white/70 flex items-center gap-1"
                animate={effectSettings.emotionBasedStyling && effectSettings.effectQuality !== 'low' ? {} : {}}
              >
                <span className="text-sm">{getDynamicEmoji()}</span>
                <span>{message.expression.emotion.primary}</span>
                {(message.expression.emotion.score ?? message.expression.emotion.intensity) && (
                  <span className="text-xs opacity-60">
                    ({Math.round((message.expression.emotion.score ?? message.expression.emotion.intensity) * 100)}%)
                  </span>
                )}
              </motion.span>
            </div>
          )}
          
          {/* „Çø„Ç§„É†„Çπ„Çø„É≥„Éó„Å®„É°„Éã„É•„Éº„Éú„Çø„É≥ */}
          <div className="flex items-center justify-between mt-1">
            <div className="text-xs text-white/40">
              {formattedTimestamp}
            </div>
            {/* „Ç±„Éê„Éñ„É°„Éã„É•„Éº„Éú„Çø„É≥ */}
            <button
              onClick={(e) => {
                e.stopPropagation();
                checkMenuPosition();
                setShowActions(!showActions);
              }}
              className="ml-2 p-1 rounded-full hover:bg-white/10 transition-colors opacity-100 md:opacity-0 md:group-hover:opacity-100"
              title="„É°„Éã„É•„Éº„ÇíË°®Á§∫"
            >
              <MoreVertical className="w-3 h-3 text-white/60" />
            </button>
          </div>
        </motion.div>

        {/* „É¢„Éê„Ç§„É´ÂØæÂøú„Ç¢„ÇØ„Ç∑„Éß„É≥„É°„Éã„É•„Éº - „Éê„Éñ„É´‰∏ãÈÉ®„Å´ÈÖçÁΩÆ */}
        <AnimatePresence>
          {showActions && (
            <motion.div
              initial={{ opacity: 0, y: -10 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: -10 }}
              className={cn(
                'absolute left-1/2 -translate-x-1/2 z-50',
                'bg-slate-800/95 backdrop-blur-sm rounded-lg border border-purple-400/20 shadow-lg',
                'p-1 flex gap-1 justify-center',
                'max-w-[calc(100vw-2rem)] overflow-hidden',
                menuPosition === 'bottom' ? 'top-full mt-2' : 'bottom-full mb-2'
              )}
              style={{
                scrollbarWidth: 'none',
                msOverflowStyle: 'none'
              }}
            >
              <ActionButton icon={Copy} onClick={handleCopy} title="„Ç≥„Éî„Éº" compact />
              <ActionButton icon={isSpeaking ? Pause : Volume2} onClick={handleSpeak} title={isSpeaking ? "ÂÅúÊ≠¢" : "Èü≥Â£∞ÂÜçÁîü"} compact />
              <ActionButton icon={Edit} onClick={handleEdit} title="„ÉÅ„É£„ÉÉ„ÉàÁ∑®ÈõÜ" compact />
              <ActionButton icon={X} onClick={handleDeleteMessage} title="„Åì„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂâäÈô§" compact />
              <ActionButton icon={RefreshCw} onClick={handleRegenerate} title="ÂÜçÁîüÊàê" compact disabled={isRegenerating || is_generating || group_generating} />
              <ActionButton icon={MoreHorizontal} onClick={handleContinue} title="Á∂ö„Åç„ÇíÂá∫Âäõ" compact disabled={isContinuing || is_generating || group_generating} />
              <ActionButton icon={CornerUpLeft} onClick={handleRollback} title="„Åì„Åì„Åæ„ÅßÊàª„Çã" compact />
            </motion.div>
          )}
        </AnimatePresence>
      </div>

        {/* „Éë„Éº„ÉÜ„Ç£„ÇØ„É´„Ç®„Éï„Çß„ÇØ„Éà */}
        {effectSettings.particleEffects && effectTrigger && (
          <MessageEffects
            trigger={effectTrigger}
            position={effectPosition}
          />
        )}

        {/* ÊÑüÊÉÖ„É™„Ç¢„ÇØ„Ç∑„Éß„É≥ - AI„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆ„Åø */}
        {!isUser && detectedEmotion && effectSettings.autoReactions && (
          <EmotionReactions
            emotion={detectedEmotion}
            onReactionTriggered={(reaction) => {
              // „É™„Ç¢„ÇØ„Ç∑„Éß„É≥„Å´Âøú„Åò„Å¶ËøΩÂä†„ÅÆ„Ç®„Éï„Çß„ÇØ„Éà„ÇíÂÆüË°å
              if (reaction.type === 'visual') {
                setEffectTrigger(prev => prev + 'üéâ');
              }
            }}
          />
        )}
      </motion.div>
    </>
  );
});

MessageBubble.displayName = 'MessageBubble';

const ActionButton: React.FC<{
  icon: React.ElementType;
  onClick: () => void;
  title: string;
  compact?: boolean;
  disabled?: boolean;
}> = ({ icon: Icon, onClick, title, compact = false, disabled = false }) => (
  <motion.button
    whileHover={{ scale: disabled ? 1 : 1.1 }}
    whileTap={{ scale: disabled ? 1 : 0.95 }}
    onClick={onClick}
    disabled={disabled}
    className={cn(
      "bg-white/10 backdrop-blur-sm rounded-lg hover:bg-white/20 transition-colors",
      compact ? "p-1" : "p-2",
      disabled && "opacity-50 cursor-not-allowed"
    )}
    title={title}
  >
    <Icon className={cn("text-white/70", compact ? "w-3 h-3" : "w-4 h-4")} />
  </motion.button>
);
