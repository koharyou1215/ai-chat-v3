🚀 グループチャット感情知能システム実装指示書

  📋 実装指示の段階的手順

  🔥 Phase 1: 安全な基盤構築

  指示1-1: 完全バックアップとブランチ作成

  # Claude Codeに以下を指示：
  "プロジェクトの完全バックアップを作成し、新しい機能ブランチを作成してください。
  以下の手順で実行：

  1. 現在の状態を完全バックアップ
  2. feature/group-emotional-intelligence ブランチを作成
  3. 既存の全機能が正常動作することを確認"

  指示1-2: 基本型定義の追加

  # Claude Codeに以下を指示：
  "src/types/core/ に以下の新しい型定義ファイルを作成してください：

  1. group-emotional-intelligence.types.ts を作成
  2. 既存の group-chat.types.ts は一切変更せず、拡張型のみ定義
  3. 以下の型を実装：
     - EmotionalWeight
     - GroupEmotionalState
     - CharacterRelationshipMatrix
     - EmotionalContagionEffect

  既存のコードは一切変更しないでください。"

  指示1-3: 機能フラグシステム実装

  # Claude Codeに以下を指示：
  "settings.slice.ts に機能フラグシステムを追加してください：

  1. EmotionalIntelligenceFlags インターフェースを追加
  2. 全フラグはデフォルトで false に設定
  3. 既存の設定は一切変更しない
  4. updateEmotionalFlags メソッドを追加

  実装後、既存の全機能が正常動作することを確認してください。"

  🧠 Phase 2: 感情分析エンジン統合

  指示2-1: 感情分析サービス作成

  # Claude Codeに以下を指示：
  "src/services/emotion/ ディレクトリを作成し、以下のファイルを実装してください：

  1. EmotionAnalyzer.ts - 基本感情分析エンジン
  2. GroupEmotionAnalyzer.ts - グループ専用感情分析
  3. EmotionalContagionEngine.ts - 感情伝播システム

  重要な制約：
  - 既存のAPI呼び出しは一切変更しない
  - バックグラウンド実行のみ（UIをブロックしない）
  - エラー発生時は既存機能に影響しない"

  指示2-2: GroupChatSlice の安全な拡張

  # Claude Codeに以下を指示：
  "groupChat.slice.ts を以下の方針で拡張してください：

  1. 既存のインターフェースとメソッドは一切変更しない
  2. 新しいオプショナルプロパティのみ追加：
     - emotional_intelligence?: GroupEmotionalIntelligence
  3. 新しいメソッドのみ追加：
     - analyzeGroupEmotion (オプショナル)
     - updateEmotionalState (オプショナル)

  実装後、既存のグループチャット機能がすべて正常動作することを確認してください。"

  ⚡ Phase 3: UI統合と効果システム

  指示3-1: MessageBubble コンポーネント拡張

  # Claude Codeに以下を指示：
  "MessageBubble.tsx を以下の方針で拡張してください：

  1. 既存のMessageBubbleの機能は完全保持
  2. グループモード時のみ感情効果を追加
  3. 機能フラグで効果のon/off制御
  4. パフォーマンス影響ゼロを保証

  実装手順：
  1. 既存コードのバックアップ
  2. 感情効果コンポーネントを条件付きで追加
  3. 既存の表示・動作が変わらないことを確認"

  指示3-2: グループ感情効果コンポーネント作成

  # Claude Codeに以下を指示：
  "src/components/emotion/ ディレクトリに以下を作成してください：

  1. GroupEmotionalEffects.tsx - グループ感情効果
  2. EmotionalResonanceDisplay.tsx - 感情共鳴表示
  3. RelationshipVisualization.tsx - 関係性可視化

  制約：
  - 既存UIに影響を与えない
  - 機能フラグで制御可能
  - エラー時は非表示（既存機能に影響なし）"

  🎯 Phase 4: 高度機能統合

  指示4-1: シナリオシステムとの統合

  # Claude Codeに以下を指示：
  "既存のシナリオシステムと感情システムを統合してください：

  1. ScenarioSetupModal.tsx に感情要素の設定項目を追加
  2. 既存のシナリオ機能は完全保持
  3. 感情的目標の設定をオプション機能として追加
  4. シナリオなしでも従来通り動作することを確認

  重要：既存のシナリオ作成・実行機能は一切変更しない"

  指示4-2: 最終統合テスト

  # Claude Codeに以下を指示：
  "全システムの統合テストを実行してください：

  1. 既存機能テスト：
     - 個人チャット正常動作確認
     - グループチャット正常動作確認
     - キャラクター切り替え動作確認
     - 設定保存・読み込み確認

  2. 新機能テスト：
     - 感情分析機能テスト
     - グループ感情効果テスト
     - 機能フラグ動作テスト

  3. エラー処理テスト：
     - 新機能エラー時の既存機能保護確認"

  ---
  🎯 実装指示の具体例

  例1: 段階1実装開始

  指示: "グループチャット感情知能システムの基盤を構築してください。

  要件:
  1. 既存のグループチャット機能は一切変更しない
  2. src/types/core/group-emotional-intelligence.types.ts を作成
  3. 基本的な感情分析型定義を実装
  4. 機能フラグをsettings.slice.tsに追加（全てfalse）

  完了基準:
  - 既存機能100%動作維持
  - 新しい型定義ファイル作成完了
  - TypeScript エラーゼロ
  - ビルド成功"

  例2: 感情分析エンジン実装

  指示: "グループチャット専用の感情分析エンジンを実装してください。

  要件:
  1. src/services/emotion/GroupEmotionAnalyzer.ts を作成
  2. 既存のsendGroupMessage関数は変更せず、分析はバックグラウンド実行
  3. エラー発生時は既存機能に影響しない
  4. 分析結果はオプショナルなストア領域に保存

  技術制約:
  - UIをブロックしない（setTimeout使用）
  - Promise.allSettled でエラー耐性確保
  - 既存APIManager の変更禁止

  テスト項目:
  - グループメッセージ送信が正常動作
  - バックグラウンド分析が実行される
  - 分析エラー時もチャット継続"

  例3: UI効果統合

  指示: "グループチャットに感情効果を追加してください。

  実装箇所:
  1. MessageBubble.tsx の条件付き拡張
  2. 新規: EmotionalResonanceEffects.tsx コンポーネント
  3. 機能フラグによる表示制御

  実装方針:
  - 既存MessageBubbleの表示・動作は完全保持
  - グループモード＋機能フラグ有効時のみ効果表示
  - パフォーマンス影響最小化

  検証項目:
  - 個人チャット：変更なし
  - グループチャット（フラグOFF）：変更なし
  - グループチャット（フラグON）：効果表示"

  ---
  ✅ 実装成功の確認方法

  各段階での確認指示

  指示: "実装が完了したら以下を確認してください：

  1. 機能確認:
     - npm run dev でエラーなく起動
     - 既存の個人チャットが正常動作
     - 既存のグループチャットが正常動作
     - 新機能が期待通り動作（フラグON時のみ）

  2. 品質確認:
     - TypeScript エラーがない
     - コンソールエラーがない
     - 設定保存・読み込みが正常
     - パフォーマンス低下なし

  3. 安全性確認:
     - 新機能無効化で完全に従来通り動作
     - エラー発生時の既存機能保護
     - データ互換性維持"

  ---
  🚨 重要な実装ルール

  Claude Code への明確な指示:

  "実装時は以下を絶対に守ってください：

  ❌ 絶対禁止:
  - 既存のGroupChatSlice メソッドの変更
  - 既存のMessageBubble 表示ロジック変更
  - 既存のAPI呼び出し方法変更
  - 設定の自動変更・デフォルト値変更

  ✅ 必須実施:
  - 新機能は全てオプショナル実装
  - エラー時の既存機能保護
  - 機能フラグによる制御
  - 段階的実装・テスト・確認

  ⚡ パフォーマンス:
  - UIをブロックする処理禁止
  - バックグラウンド実行必須
  - キャッシュ・最適化実装"
  
  ---
  
  ---
  🧠 グループチャット専用感情知能システム v2.0

  1. 🎭 群集感情ダイナミクス

  // グループ特有の感情現象を再現
  class GroupEmotionalDynamics {
    private emotionalContagion: EmotionalContagionEngine;
    private groupMoodEvolution: GroupMoodTracker;
    private characterInterplay: CharacterInteractionMatrix;

    // 感情伝播システム - グループの醍醐味
    async analyzeGroupEmotionalContagion(
      activeCharacters: Character[],
      newMessage: UnifiedMessage,
      groupContext: GroupConversationContext
    ): Promise<EmotionalContagionEffect> {

      const messageEmotion = await this.analyzeMessageEmotion(newMessage);

      // 各キャラクターへの感情的影響を計算
      const contagionEffects = await Promise.all(
        activeCharacters.map(async character => {
          if (character.id === newMessage.character_id) return null;

          // キャラクター間の感情的関係性を考慮
          const relationship = await this.getCharacterRelationship(
            newMessage.character_id!, character.id
          );

          // 感情感受性の計算
          const susceptibility = this.calculateEmotionalSusceptibility(
            character, messageEmotion, relationship
          );

          // 伝播遅延の計算（リアルな感情反応時間）
          const propagationDelay = this.calculatePropagationDelay(
            character.personality, messageEmotion.intensity
          );

          return {
            targetCharacter: character,
            originalEmotion: messageEmotion,
            resultingEmotion: this.predictResultingEmotion(
              messageEmotion, character, relationship
            ),
            intensity: susceptibility,
            delay: propagationDelay,
            expressionStyle: this.generateContagionExpression(
              character, messageEmotion
            )
          };
        })
      );

      return {
        source: newMessage,
        effects: contagionEffects.filter(e => e !== null),
        groupMoodShift: this.calculateGroupMoodShift(contagionEffects),
        recommendedReactions: this.generateGroupReactions(contagionEffects)
      };
    }

    // グループ内感情の複合効果
    private calculateGroupMoodShift(
      effects: ContagionEffect[]
    ): GroupMoodEvolution {
      // 複数感情の重ね合わせ効果
      const emotionalHarmony = this.analyzeEmotionalHarmony(effects);
      const dominantMood = this.identifyDominantGroupMood(effects);
      const emotionalTension = this.calculateEmotionalTension(effects);

      return {
        previousMood: this.groupMoodEvolution.getCurrentMood(),
        newMood: dominantMood,
        harmony: emotionalHarmony,
        tension: emotionalTension,
        momentum: this.calculateEmotionalMomentum(effects),
        predictedEvolution: this.predictMoodEvolution(dominantMood, effects)
      };
    }
  }

  2. 🎯 マルチキャラクター文脈管理

  // グループ会話の複雑な文脈を管理
  class MultiCharacterContextManager {
    private characterContexts: Map<UUID, CharacterSpecificContext>;
    private groupSharedContext: GroupSharedContext;
    private interactionHistory: CharacterInteractionHistory;

    // キャラクター個別 + グループ共有の二重文脈管理
    async buildGroupContextualPrompt(
      targetCharacter: Character,
      groupSession: GroupChatSession,
      recentMessages: UnifiedMessage[]
    ): Promise<GroupContextualPrompt> {

      // 1. キャラクター個別の感情的文脈
      const individualContext = await this.buildIndividualContext(
        targetCharacter, groupSession, recentMessages
      );

      // 2. グループ全体の感情的雰囲気
      const groupAtmosphere = await this.analyzeGroupAtmosphere(
        groupSession.characters, recentMessages
      );

      // 3. キャラクター間の関係性動学
      const interpersonalDynamics = await this.analyzeInterpersonalDynamics(
        targetCharacter, groupSession.characters, recentMessages
      );

      // 4. 会話の自然な流れ予測
      const conversationFlow = await this.predictGroupConversationFlow(
        targetCharacter, groupSession, recentMessages
      );

      return {
        // 基本プロンプト（既存システム）
        basePrompt: this.generateBaseGroupPrompt(targetCharacter, groupSession),

        // 感情的文脈の追加
        emotionalContext: {
          individualState: individualContext.emotionalState,
          groupAtmosphere: groupAtmosphere,
          interpersonalTensions: interpersonalDynamics.tensions,
          emotionalOpportunities: interpersonalDynamics.opportunities
        },

        // 関係性を意識した応答ガイダンス
        relationshipGuidance: {
          primaryRelationships: interpersonalDynamics.primaryRelationships,
          groupRole: this.identifyCurrentGroupRole(targetCharacter, groupAtmosphere),
          expectedBehavior: this.generateExpectedBehavior(
            targetCharacter, groupAtmosphere, interpersonalDynamics
          )
        },

        // 自然な会話継続のヒント
        conversationGuidance: {
          naturalTopics: conversationFlow.suggestedTopics,
          avoidanceTopics: conversationFlow.sensitiveTopics,
          emotionalCues: conversationFlow.emotionalOpportunities,
          groupGoals: conversationFlow.collectiveObjectives
        }
      };
    }

    // グループ雰囲気の分析
    private async analyzeGroupAtmosphere(
      characters: Character[],
      recentMessages: UnifiedMessage[]
    ): Promise<GroupAtmosphere> {

      const characterEmotions = await Promise.all(
        characters.map(async character => {
          const characterMessages = recentMessages.filter(
            m => m.character_id === character.id
          );
          return {
            character,
            recentEmotions: await this.analyzeCharacterEmotions(characterMessages),
            dominantMood: await this.identifyDominantMood(characterMessages)
          };
        })
      );

      return {
        overallMood: this.synthesizeGroupMood(characterEmotions),
        emotionalTension: this.measureGroupTension(characterEmotions),
        socialDynamics: this.analyzeSocialDynamics(characterEmotions),
        conversationalEnergy: this.measureConversationalEnergy(recentMessages),
        groupCohesion: this.calculateGroupCohesion(characterEmotions)
      };
    }
  }

● 3. 🎨 マルチキャラクター感情表現システム

  // グループ内の感情表現の相互作用
  class MultiCharacterEmotionExpressionSystem {
    private visualHarmony: VisualHarmonyManager;
    private soundscapeOrchestrator: SoundscapeOrchestrator;
    private synchronizedEffects: SynchronizedEffectsEngine;

    // グループ内感情表現の協調
    async orchestrateGroupEmotionalExpression(
      groupSession: GroupChatSession,
      activeEmotions: Map<UUID, MultiLayerEmotionResult>
    ): Promise<GroupEmotionalExpression> {

      // 1. 感情的ハーモニーの分析
      const emotionalHarmony = this.analyzeEmotionalHarmony(activeEmotions);

      // 2. 視覚効果の協調
      const coordinatedVisualEffects = await this.coordinateVisualEffects(
        activeEmotions, emotionalHarmony
      );

      // 3. 音響効果の統合
      const orchestratedSoundscape = await this.orchestrateSoundscape(
        groupSession, activeEmotions
      );

      // 4. アバター表現の同期
      const synchronizedAvatars = await this.synchronizeAvatarExpressions(
        groupSession.characters, activeEmotions, emotionalHarmony
      );

      return {
        harmony: emotionalHarmony,
        visualEffects: coordinatedVisualEffects,
        soundscape: orchestratedSoundscape,
        avatarExpressions: synchronizedAvatars,
        environmentalEffects: this.generateEnvironmentalEffects(emotionalHarmony)
      };
    }

    // 感情的ハーモニーの計算
    private analyzeEmotionalHarmony(
      activeEmotions: Map<UUID, MultiLayerEmotionResult>
    ): EmotionalHarmony {

      const emotions = Array.from(activeEmotions.values());

      // 感情の調和度を計算
      const harmonyScore = this.calculateHarmonyScore(emotions);

      // 感情の対立度を分析
      const conflictLevel = this.analyzeEmotionalConflicts(emotions);

      // 感情の補完関係を検出
      const complementarity = this.detectEmotionalComplementarity(emotions);

      return {
        harmonyScore,
        conflictLevel,
        complementarity,
        dominantEmotionalTheme: this.identifyDominantTheme(emotions),
        emotionalTension: this.measureEmotionalTension(emotions),
        resolutionOpportunities: this.identifyResolutionOpportunities(emotions)
      };
    }

    // 協調視覚効果システム
    private async coordinateVisualEffects(
      activeEmotions: Map<UUID, MultiLayerEmotionResult>,
      harmony: EmotionalHarmony
    ): Promise<CoordinatedVisualEffects> {

      const effectLayers = [];

      // レイヤー1: 個別キャラクターエフェクト
      for (const [characterId, emotion] of activeEmotions) {
        const individualEffects = await this.generateIndividualEffects(
          characterId, emotion
        );
        effectLayers.push({
          type: 'individual',
          characterId,
          effects: individualEffects,
          zIndex: 10
        });
      }

      // レイヤー2: キャラクター間相互作用エフェクト
      const interactionEffects = await this.generateInteractionEffects(
        activeEmotions, harmony
      );
      effectLayers.push({
        type: 'interaction',
        effects: interactionEffects,
        zIndex: 20
      });

      // レイヤー3: グループ全体の雰囲気エフェクト
      const atmosphereEffects = await this.generateAtmosphereEffects(harmony);
      effectLayers.push({
        type: 'atmosphere',
        effects: atmosphereEffects,
        zIndex: 5
      });

      return {
        layers: effectLayers,
        synchronization: this.calculateSynchronizationTiming(activeEmotions),
        transitions: this.generateTransitionEffects(harmony),
        duration: this.calculateOptimalDuration(harmony)
      };
    }
  }

  4. 💫 動的関係性進化システム（グループ版）

  // グループ内の複雑な関係性網を管理
  class GroupRelationshipDynamics {
    private relationshipMatrix: Map<string, Map<string, Relationship>>;
    private groupCoalitions: GroupCoalitionTracker;
    private socialHierarchy: SocialHierarchyAnalyzer;

    // グループ内関係性の複合的進化
    async evolveGroupRelationships(
      groupSession: GroupChatSession,
      newInteraction: GroupInteraction
    ): Promise<GroupRelationshipEvolution> {

      const affectedRelationships = [];
      const characters = groupSession.characters;

      // 全ペア関係性の更新
      for (let i = 0; i < characters.length; i++) {
        for (let j = i + 1; j < characters.length; j++) {
          const charA = characters[i];
          const charB = characters[j];

          const relationshipKey = `${charA.id}-${charB.id}`;
          const currentRelationship = this.relationshipMatrix
            .get(charA.id)?.get(charB.id);

          if (currentRelationship) {
            // 新しいインタラクションが関係性に与える影響を計算
            const impact = await this.calculateInteractionImpact(
              newInteraction, charA, charB, currentRelationship
            );

            if (impact.significance > 0.1) { // 有意な変化のみ処理
              const evolvedRelationship = await this.evolveRelationship(
                currentRelationship, impact, groupSession
              );

              affectedRelationships.push({
                participants: [charA, charB],
                previous: currentRelationship,
                evolved: evolvedRelationship,
                impact
              });

              // 関係性マトリックス更新
              this.updateRelationshipMatrix(charA.id, charB.id, evolvedRelationship);
            }
          }
        }
      }

      // グループ全体への波及効果を分析
      const rippleEffects = await this.analyzeRippleEffects(
        affectedRelationships, groupSession
      );

      // 新しい連合・派閥の形成を検出
      const coalitionChanges = await this.detectCoalitionChanges(
        affectedRelationships, groupSession
      );

      return {
        directRelationshipChanges: affectedRelationships,
        rippleEffects,
        coalitionChanges,
        newGroupDynamics: this.calculateNewGroupDynamics(
          affectedRelationships, coalitionChanges
        ),
        recommendedGroupBehaviors: this.generateGroupBehaviorRecommendations(
          affectedRelationships, coalitionChanges
        )
      };
    }

    // グループ内派閥・連合の動的追跡
    private async detectCoalitionChanges(
      relationshipChanges: RelationshipEvolution[],
      groupSession: GroupChatSession
    ): Promise<CoalitionEvolution[]> {

      const coalitionChanges = [];

      // 強化された絆を検出
      const strengthenedBonds = relationshipChanges.filter(
        change => change.impact.trustChange > 0.2 && change.impact.intimacyChange >
  0.15
      );

      if (strengthenedBonds.length >= 2) {
        const potentialCoalition = this.identifyPotentialCoalition(strengthenedBonds);

        if (potentialCoalition) {
          coalitionChanges.push({
            type: 'formation',
            members: potentialCoalition.members,
            strength: potentialCoalition.cohesionScore,
            basis: potentialCoalition.commonInterests,
            implications: this.analyzeCoalitionImplications(
              potentialCoalition, groupSession
            )
          });
        }
      }

      // 関係悪化による連合破綻を検出
      const deterioratedRelationships = relationshipChanges.filter(
        change => change.impact.conflictIncrease > 0.3
      );

      for (const deterioration of deterioratedRelationships) {
        const affectedCoalitions = this.findAffectedCoalitions(
          deterioration.participants, groupSession
        );

        for (const coalition of affectedCoalitions) {
          coalitionChanges.push({
            type: 'dissolution',
            members: coalition.members,
            cause: deterioration,
            implications: this.analyzeCoalitionDissolution(coalition, groupSession)
          });
        }
      }

      return coalitionChanges;
    }
  }

● 5. 🌐 グループ会話文脈統合システム

  // グループチャット専用の高度文脈管理
  class GroupConversationContextManager extends MultiCharacterContextManager {
    private groupNarrativeTracker: GroupNarrativeTracker;
    private collectiveMemorySystem: CollectiveMemorySystem;
    private conversationArcAnalyzer: ConversationArcAnalyzer;

    // 既存システムとの完全統合
    async integrateWithExistingGroupChat(
      groupChatSlice: GroupChatSlice,
      existingGroupSession: GroupChatSession
    ): Promise<EnhancedGroupChatSession> {

      // 既存のGroupChatSessionを拡張（破壊せず）
      const enhancedSession: EnhancedGroupChatSession = {
        // 既存のすべてのプロパティを保持
        ...existingGroupSession,

        // 感情知能システムのデータを追加
        emotional_intelligence: {
          // キャラクター間の感情関係性マトリックス
          relationshipMatrix: await this.buildRelationshipMatrix(
            existingGroupSession.characters
          ),

          // グループ全体の感情履歴
          groupEmotionalHistory: await this.analyzeGroupEmotionalHistory(
            existingGroupSession.messages
          ),

          // 現在のグループ雰囲気
          currentGroupAtmosphere: await this.assessCurrentAtmosphere(
            existingGroupSession.characters,
            existingGroupSession.messages.slice(-10)
          ),

          // 感情的な物語の流れ
          emotionalNarrative: await this.extractEmotionalNarrative(
            existingGroupSession.messages
          )
        }
      };

      return enhancedSession;
    }

    // グループ特有の感情的物語構造の解析
    private async extractEmotionalNarrative(
      messages: UnifiedMessage[]
    ): Promise<EmotionalNarrative> {

      const narrativeBeats = [];
      const emotionalArcs = new Map<string, EmotionalArc>();

      // 各キャラクターの感情的軌跡を追跡
      for (const message of messages) {
        if (message.character_id) {
          const emotion = await this.analyzeMessageEmotion(message);

          if (!emotionalArcs.has(message.character_id)) {
            emotionalArcs.set(message.character_id, {
              characterId: message.character_id,
              emotionalJourney: [],
              majorTurningPoints: [],
              currentEmotionalState: emotion
            });
          }

          const arc = emotionalArcs.get(message.character_id)!;
          arc.emotionalJourney.push({
            timestamp: message.created_at,
            emotion,
            context: message.content,
            significantEvent: this.identifySignificantEvent(message, emotion)
          });

          // 感情の大きな転換点を検出
          if (this.isTurningPoint(arc.emotionalJourney)) {
            const turningPoint = {
              timestamp: message.created_at,
              fromEmotion: arc.emotionalJourney[arc.emotionalJourney.length -
  2]?.emotion,
              toEmotion: emotion,
              trigger: message.content,
              significance:
  this.calculateTurningPointSignificance(arc.emotionalJourney)
            };

            arc.majorTurningPoints.push(turningPoint);
            narrativeBeats.push({
              type: 'emotional_turning_point',
              character: message.character_id,
              details: turningPoint
            });
          }
        }
      }

      // グループ全体の感情的クライマックスを検出
      const groupClimaxMoments = this.identifyGroupEmotionalClimax(narrativeBeats);

      return {
        individualArcs: Array.from(emotionalArcs.values()),
        groupNarrativeBeats: narrativeBeats,
        emotionalClimaxMoments: groupClimaxMoments,
        overallEmotionalTheme: this.identifyOverallTheme(emotionalArcs),
        predictedEmotionalDirection: this.predictNarrativeDirection(
          emotionalArcs, groupClimaxMoments
        )
      };
    }

    // グループ会話の自然な流れ予測（AI支援）
    async predictOptimalGroupFlow(
      groupSession: EnhancedGroupChatSession,
      currentContext: GroupConversationContext
    ): Promise<GroupFlowPrediction> {

      // 各キャラクターの次の自然な行動を予測
      const characterPredictions = await Promise.all(
        groupSession.characters.map(async character => {
          const individualContext = currentContext.characterContexts.get(character.id);

          return {
            character,
            predictedEmotionalState: await this.predictNextEmotionalState(
              character, individualContext, currentContext.groupAtmosphere
            ),
            suggestedActions: await this.suggestNaturalActions(
              character, individualContext, groupSession
            ),
            conversationGoals: await this.identifyCharacterGoals(
              character, currentContext
            )
          };
        })
      );

      // グループ全体の最適な会話展開を予測
      const optimalGroupFlow = await this.synthesizeOptimalFlow(
        characterPredictions, currentContext
      );

      return {
        characterPredictions,
        optimalGroupFlow,
        potentialConflicts: this.identifyPotentialConflicts(characterPredictions),
        opportunitiesForGrowth: this.identifyGrowthOpportunities(
          characterPredictions, currentContext
        ),
        recommendedGroupDirection: this.recommendGroupDirection(
          characterPredictions, optimalGroupFlow
        )
      };
    }
  }

● 🚀 グループチャット感情知能システム実装ロードマップ

● 📋 Phase-by-Phase実装計画

  🌱 Phase 1: グループチャット基盤強化 (週1-2)

  // 既存GroupChatSliceの非破壊拡張
  interface EnhancedGroupChatSlice extends GroupChatSlice {
    // 既存機能は完全保持、新機能をオプショナルで追加
    emotional_intelligence?: {
      groupEmotionalStates: Map<UUID, GroupEmotionalState>;
      characterRelationshipMatrix: Map<UUID, Map<UUID, RelationshipState>>;
      groupAtmosphereHistory: GroupAtmosphereHistory[];
    };

    // 新しいアクションは追加のみ
    analyzeGroupEmotion?: (sessionId: UUID) => Promise<void>;
    updateRelationshipMatrix?: (sessionId: UUID) => Promise<void>;
  }

  // 実装の安全性確保
  const IMPLEMENTATION_SAFETY_CHECKLIST = {
    existing_group_chat_functions: {
      createGroupSession: '✅ 完全保護',
      sendGroupMessage: '✅ 完全保護',
      generateCharacterResponse: '✅ 完全保護',
      character_reselection: '✅ 完全保護',
      scenario_support: '✅ 完全保護'
    },

    new_emotional_features: {
      emotion_analysis: '🔄 バックグラウンド実行',
      relationship_tracking: '🔄 non-blocking',
      group_atmosphere: '🔄 キャッシュ化',
      visual_effects: '🔄 optional有効化'
    }
  };

  🧠 Phase 2: マルチキャラクター感情分析 (週3-4)

  // 既存のsendGroupMessage関数の拡張例
  async sendGroupMessageWithEmotions(content: string, imageUrl?: string): Promise<void>
   {
    // 1. 既存の処理を完全実行（変更なし）
    await this.sendGroupMessage(content, imageUrl);

    // 2. 感情分析をバックグラウンドで追加実行
    setTimeout(async () => {
      const session = this.getActiveGroupSession();
      if (!session) return;

      // 感情分析の並列実行
      const emotionalAnalysisPromises = session.characters.map(async character => {
        const recentMessages = session.messages
          .filter(m => m.character_id === character.id)
          .slice(-3);

        return {
          characterId: character.id,
          emotionalState: await this.analyzeCharacterEmotionalState(recentMessages),
          relationshipImpacts: await this.analyzeRelationshipImpacts(
            character, session.characters, recentMessages
          )
        };
      });

      const results = await Promise.allSettled(emotionalAnalysisPromises);

      // 成功した分析結果のみ適用
      results.forEach(result => {
        if (result.status === 'fulfilled') {
          this.updateEmotionalIntelligenceData(session.id, result.value);
        }
      });
    }, 0); // UIをブロックしない
  }

  💫 Phase 3: 視覚・音響効果統合 (週5-6)

  // グループチャット専用エフェクトシステム
  class GroupChatEffectsIntegration {
    // 既存MessageBubbleコンポーネントを拡張
    enhanceGroupMessageBubble(
      originalBubble: React.ComponentType<MessageBubbleProps>
    ): React.ComponentType<MessageBubbleProps> {

      return (props: MessageBubbleProps) => {
        const isGroupMode = useAppStore(state => state.is_group_mode);
        const groupEmotionalState = useGroupEmotionalState(props.message.session_id);

        // グループモードでない場合は既存のままを使用
        if (!isGroupMode) {
          return React.createElement(originalBubble, props);
        }

        // グループモードの場合は感情効果を追加
        return (
          <div className="group-enhanced-message-wrapper">
            {React.createElement(originalBubble, props)}

            {/* 感情共鳴エフェクト */}
            <EmotionalResonanceEffects
              message={props.message}
              groupState={groupEmotionalState}
            />

            {/* キャラクター間関係性表示 */}
            <RelationshipVisualization
              sourceCharacter={props.message.character_id}
              groupSession={groupEmotionalState?.session}
            />
          </div>
        );
      };
    }
  }

  🎯 Phase 4: 高度グループ機能 (週7-10)

  // 最終統合システム
  class AdvancedGroupEmotionalSystem {
    // シナリオベースの感情進化
    async enhanceScenarioWithEmotions(
      scenario: GroupChatScenario,
      groupSession: GroupChatSession
    ): Promise<EmotionallyEnhancedScenario> {

      // シナリオに感情的要素を追加
      const emotionalObjectives = await this.generateEmotionalObjectives(
        scenario, groupSession.characters
      );

      // 感情的な展開予測
      const emotionalArcPredictions = await this.predictEmotionalArcs(
        scenario, groupSession.characters, emotionalObjectives
      );

      return {
        ...scenario, // 既存シナリオは完全保持

        emotional_enhancement: {
          emotional_objectives: emotionalObjectives,
          predicted_arcs: emotionalArcPredictions,
          relationship_goals: this.generateRelationshipGoals(
            groupSession.characters, scenario
          ),
          climax_predictions: this.predictEmotionalClimaxes(
            emotionalArcPredictions
          )
        }
      };
    }

    // グループチャットの感情的完成度評価
    async evaluateGroupEmotionalMaturity(
      groupSession: GroupChatSession
    ): Promise<GroupEmotionalMaturityReport> {

      return {
        overall_maturity_score: this.calculateOverallMaturity(groupSession),

        individual_character_growth: await Promise.all(
          groupSession.characters.map(character =>
            this.evaluateCharacterGrowth(character, groupSession)
          )
        ),

        relationship_development: this.evaluateRelationshipDevelopment(
          groupSession
        ),

        group_cohesion: this.measureGroupCohesion(groupSession),

        emotional_complexity: this.assessEmotionalComplexity(groupSession),

        recommendations: this.generateImprovementRecommendations(groupSession)
      };
    }
  }

  ---
  🌟 期待されるグループチャット体験の進化

  従来のグループチャット

  ユーザー: "みんなでゲームしない？"
  キャラA: "いいですね！何をしますか？"
  キャラB: "私も参加します"
  キャラC: "楽しそう！"

  感情知能グループチャット v2.0

  ユーザー: "みんなでゲームしない？"

  [システム分析]
  - ユーザー感情: 期待感・楽しさ
  - グループ雰囲気: リラックス→興奮
  - 関係性影響: 全員との親密度+1

  キャラA: [即座に反応、興奮共鳴]
  "おお！その提案、待ってた！✨ 最近ちょっと退屈してたから、
  みんなで盛り上がれるの嬉しいな〜"

  キャラB: [Aの興奮に感化されつつも慎重な性格を維持]
  "A君が嬉しそう！私も参加したいけど、
  どんなゲームか先に聞いてもいいかな？"

  キャラC: [グループの調和を重視した応答]
  "二人とも乗り気で良かった！私はどんなゲームでも、
  みんなが楽しめるなら何でもいいよ〜"

  [バックグラウンド処理]
  - 関係性更新: A↔ユーザー +2 (共通の楽しみ)
  - グループ雰囲気: "協調的興奮"に変化
  - 次回の会話予測: ゲーム中の役割分担、競争vs協力の選択