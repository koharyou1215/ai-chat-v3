2ï¸âƒ£ ãƒ™ã‚¯ãƒˆãƒ«ã‚¹ãƒˆã‚¢å®Ÿè£…
typescript// src/services/memory/vector-store.ts

import { Message, SearchResult } from './types';

/**
 * FAISSã‚’TypeScriptã§ä½¿ç”¨ã™ã‚‹ãŸã‚ã®ãƒ–ãƒªãƒƒã‚¸ã‚¯ãƒ©ã‚¹
 * å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€Pythonãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã¾ãŸã¯WebAssemblyãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ä½¿ç”¨
 */
export class VectorStore {
  private embeddings: Map<string, number[]> = new Map();
  private messages: Map<string, Message> = new Map();
  private dimension: number = 1536; // OpenAI embedding dimension
  
  // FAISSã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆå®Ÿéš›ã¯Pythonå´ã§ç®¡ç†ï¼‰
  private indexInitialized: boolean = false;

  constructor() {
    this.initializeIndex();
  }

  /**
   * ãƒ™ã‚¯ãƒˆãƒ«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®åˆæœŸåŒ–
   * å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€Pythonå´ã®FAISSã¾ãŸã¯JSå‘ã‘ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ç”¨
   */
  private async initializeIndex(): Promise<void> {
    // FAISSã®åˆæœŸåŒ–ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
    // å®Ÿéš›ã¯: await this.pythonBridge.initializeFaiss(this.dimension);
    this.indexInitialized = true;
  }

  /**
   * ãƒ†ã‚­ã‚¹ãƒˆã‚’ãƒ™ã‚¯ãƒˆãƒ«åŒ–
   * OpenAI Embedding APIã¾ãŸã¯ãƒ­ãƒ¼ã‚«ãƒ«ãƒ¢ãƒ‡ãƒ«ã‚’ä½¿ç”¨
   */
  private async embed(text: string): Promise<number[]> {
    try {
      // å®Ÿéš›ã®OpenAI APIå‘¼ã³å‡ºã—
      const response = await fetch('/api/embeddings', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ text })
      });
      
      const data = await response.json();
      return data.embedding;
    } catch (error) {
      console.error('Embedding error:', error);
      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ç°¡æ˜“çš„ãªãƒãƒƒã‚·ãƒ¥ãƒ™ãƒ¼ã‚¹ã®ç–‘ä¼¼ãƒ™ã‚¯ãƒˆãƒ«
      return this.createFallbackEmbedding(text);
    }
  }

  /**
   * ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”¨ã®ç°¡æ˜“ãƒ™ã‚¯ãƒˆãƒ«ç”Ÿæˆ
   * æœ¬ç•ªç’°å¢ƒã§ã¯ä½¿ç”¨ã—ãªã„
   */
  private createFallbackEmbedding(text: string): number[] {
    const vector = new Array(this.dimension).fill(0);
    const words = text.toLowerCase().split(/\s+/);
    
    words.forEach((word, i) => {
      const hash = this.hashCode(word);
      const index = Math.abs(hash) % this.dimension;
      vector[index] = (vector[index] + 1) / Math.sqrt(words.length);
    });
    
    return vector;
  }

  private hashCode(str: string): number {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return hash;
  }

  /**
   * ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿½åŠ ã—ã¦ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹åŒ–
   * ã‚³ã‚¹ãƒˆæœ€é©åŒ–: ãƒãƒƒãƒå‡¦ç†ã§ embedding APIå‘¼ã³å‡ºã—ã‚’å‰Šæ¸›
   */
  async addMessage(message: Message): Promise<void> {
    // æ—¢å­˜ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ã‚¹ã‚­ãƒƒãƒ—ï¼ˆã‚³ã‚¹ãƒˆå‰Šæ¸›ï¼‰
    if (this.messages.has(message.id)) {
      return;
    }

    // é‡è¦åº¦ãŒä½ã„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ embedding ã‚’ã‚¹ã‚­ãƒƒãƒ—ï¼ˆã‚³ã‚¹ãƒˆæœ€é©åŒ–ï¼‰
    if (message.importance !== undefined && message.importance < 0.3) {
      this.messages.set(message.id, message);
      return;
    }

    // ãƒ™ã‚¯ãƒˆãƒ«åŒ–ã¨ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹è¿½åŠ 
    const embedding = await this.embed(message.content);
    this.embeddings.set(message.id, embedding);
    this.messages.set(message.id, { ...message, embedding });

    // FAISSã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«è¿½åŠ 
    // å®Ÿéš›: await this.pythonBridge.addToIndex(message.id, embedding);
  }

  /**
   * ãƒãƒƒãƒå‡¦ç†ã§ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿½åŠ ï¼ˆã‚³ã‚¹ãƒˆæœ€é©åŒ–ï¼‰
   */
  async addMessagesBatch(messages: Message[]): Promise<void> {
    // é‡è¦ãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ã¿ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
    const importantMessages = messages.filter(
      m => !this.messages.has(m.id) && 
           (m.importance === undefined || m.importance >= 0.3)
    );

    if (importantMessages.length === 0) return;

    // ãƒãƒƒãƒã§embeddingå–å¾—ï¼ˆAPIå‘¼ã³å‡ºã—å‰Šæ¸›ï¼‰
    const texts = importantMessages.map(m => m.content);
    const embeddings = await this.embedBatch(texts);

    // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«è¿½åŠ 
    importantMessages.forEach((message, i) => {
      const embedding = embeddings[i];
      this.embeddings.set(message.id, embedding);
      this.messages.set(message.id, { ...message, embedding });
    });
  }

  /**
   * ãƒãƒƒãƒembeddingï¼ˆã‚³ã‚¹ãƒˆå‰Šæ¸›ï¼‰
   */
  private async embedBatch(texts: string[]): Promise<number[][]> {
    try {
      const response = await fetch('/api/embeddings/batch', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ texts })
      });
      
      const data = await response.json();
      return data.embeddings;
    } catch (error) {
      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
      return texts.map(text => this.createFallbackEmbedding(text));
    }
  }

  /**
   * é¡ä¼¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ¤œç´¢
   * ã‚¯ã‚¨ãƒªæ‹¡å¼µã¨ãƒªãƒ©ãƒ³ã‚­ãƒ³ã‚°ã§ç²¾åº¦å‘ä¸Š
   */
  async search(
    query: string, 
    k: number = 5,
    threshold: number = 0.7
  ): Promise<SearchResult[]> {
    const queryEmbedding = await this.embed(query);
    
    // ã‚³ã‚µã‚¤ãƒ³é¡ä¼¼åº¦è¨ˆç®—
    const results: SearchResult[] = [];
    
    for (const [id, messageEmbedding] of this.embeddings) {
      const similarity = this.cosineSimilarity(queryEmbedding, messageEmbedding);
      
      if (similarity >= threshold) {
        const message = this.messages.get(id)!;
        results.push({
          message,
          score: similarity,
          relevance: similarity > 0.9 ? 'high' : 
                    similarity > 0.8 ? 'medium' : 'low'
        });
      }
    }

    // ã‚¹ã‚³ã‚¢ã§ã‚½ãƒ¼ãƒˆã—ã¦ãƒˆãƒƒãƒ—kä»¶ã‚’è¿”ã™
    return results
      .sort((a, b) => b.score - a.score)
      .slice(0, k);
  }

  /**
   * ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰æ¤œç´¢ï¼ˆãƒ™ã‚¯ãƒˆãƒ« + ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ï¼‰
   */
  async hybridSearch(
    query: string,
    keywords: string[],
    k: number = 5
  ): Promise<SearchResult[]> {
    // ãƒ™ã‚¯ãƒˆãƒ«æ¤œç´¢
    const vectorResults = await this.search(query, k * 2);
    
    // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒãƒãƒ³ã‚°ã§ãƒ–ãƒ¼ã‚¹ãƒˆ
    const boostedResults = vectorResults.map(result => {
      const content = result.message.content.toLowerCase();
      const keywordMatches = keywords.filter(kw => 
        content.includes(kw.toLowerCase())
      ).length;
      
      // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒãƒã§ã‚¹ã‚³ã‚¢ãƒ–ãƒ¼ã‚¹ãƒˆ
      const boostedScore = result.score + (keywordMatches * 0.1);
      
      return {
        ...result,
        score: Math.min(boostedScore, 1.0)
      };
    });

    return boostedResults
      .sort((a, b) => b.score - a.score)
      .slice(0, k);
  }

  /**
   * ã‚³ã‚µã‚¤ãƒ³é¡ä¼¼åº¦è¨ˆç®—
   */
  private cosineSimilarity(a: number[], b: number[]): number {
    let dotProduct = 0;
    let normA = 0;
    let normB = 0;
    
    for (let i = 0; i < a.length; i++) {
      dotProduct += a[i] * b[i];
      normA += a[i] * a[i];
      normB += b[i] * b[i];
    }
    
    return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
  }

  /**
   * ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ï¼ˆãƒ¡ãƒ¢ãƒªç®¡ç†ï¼‰
   */
  async cleanup(maxMessages: number = 1000): Promise<void> {
    if (this.messages.size <= maxMessages) return;

    // å¤ã„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å‰Šé™¤ï¼ˆé‡è¦åº¦ã¨ãƒ”ãƒ³ç•™ã‚ã‚’è€ƒæ…®ï¼‰
    const sortedMessages = Array.from(this.messages.values())
      .filter(m => !m.pinned)
      .sort((a, b) => {
        // é‡è¦åº¦å„ªå…ˆ
        if (a.importance !== b.importance) {
          return (b.importance || 0) - (a.importance || 0);
        }
        // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã§æ¯”è¼ƒ
        return new Date(b.timestamp).getTime() - 
               new Date(a.timestamp).getTime();
      });

    // å‰Šé™¤å¯¾è±¡ã‚’æ±ºå®š
    const toDelete = sortedMessages.slice(maxMessages);
    
    toDelete.forEach(message => {
      this.messages.delete(message.id);
      this.embeddings.delete(message.id);
    });
  }
}
3ï¸âƒ£ ãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†
typescript// src/services/memory/memory-layers.ts

import { Message, MemoryLayer } from './types';

/**
 * éšå±¤çš„ãƒ¡ãƒ¢ãƒªç®¡ç†
 * èªçŸ¥ç§‘å­¦ã®ãƒ¡ãƒ¢ãƒªãƒ¢ãƒ‡ãƒ«ã«åŸºã¥ãå®Ÿè£…
 */
export class MemoryLayerManager {
  private layers: Map<string, MemoryLayer>;
  
  constructor() {
    this.layers = new Map([
      ['immediate', {
        type: 'immediate',
        messages: [],
        maxSize: 3,
        retentionPolicy: 'fifo'
      }],
      ['working', {
        type: 'working', 
        messages: [],
        maxSize: 10,
        retentionPolicy: 'importance'
      }],
      ['episodic', {
        type: 'episodic',
        messages: [],
        maxSize: 50,
        retentionPolicy: 'relevance'
      }],
      ['semantic', {
        type: 'semantic',
        messages: [],
        maxSize: 200,
        retentionPolicy: 'importance'
      }]
    ]);
  }

  /**
   * ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é©åˆ‡ãªãƒ¬ã‚¤ãƒ¤ãƒ¼ã«è¿½åŠ 
   */
  addMessage(message: Message): void {
    // å³æ™‚è¨˜æ†¶ã«è¿½åŠ 
    this.addToLayer('immediate', message);
    
    // é‡è¦åº¦ã«åŸºã¥ã„ã¦ä»–ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ã‚‚è¿½åŠ 
    if (this.shouldAddToWorking(message)) {
      this.addToLayer('working', message);
    }
    
    if (this.shouldAddToEpisodic(message)) {
      this.addToLayer('episodic', message);
    }
    
    if (this.shouldAddToSemantic(message)) {
      this.addToLayer('semantic', message);
    }
  }

  /**
   * ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿½åŠ ï¼ˆä¿æŒãƒãƒªã‚·ãƒ¼ã«å¾“ã†ï¼‰
   */
  private addToLayer(layerName: string, message: Message): void {
    const layer = this.layers.get(layerName);
    if (!layer) return;

    // é‡è¤‡ãƒã‚§ãƒƒã‚¯
    if (layer.messages.some(m => m.id === message.id)) {
      return;
    }

    layer.messages.push(message);
    
    // ã‚µã‚¤ã‚ºåˆ¶é™ã‚’è¶…ãˆãŸå ´åˆã®å‡¦ç†
    if (layer.messages.length > layer.maxSize) {
      this.enforceRetentionPolicy(layer);
    }
  }

  /**
   * ä¿æŒãƒãƒªã‚·ãƒ¼ã‚’é©ç”¨
   */
  private enforceRetentionPolicy(layer: MemoryLayer): void {
    switch (layer.retentionPolicy) {
      case 'fifo':
        // æœ€ã‚‚å¤ã„ã‚‚ã®ã‚’å‰Šé™¤
        layer.messages.shift();
        break;
        
      case 'importance':
        // é‡è¦åº¦ãŒæœ€ã‚‚ä½ã„ã‚‚ã®ã‚’å‰Šé™¤
        layer.messages.sort((a, b) => 
          (b.importance || 0) - (a.importance || 0)
        );
        layer.messages = layer.messages.slice(0, layer.maxSize);
        break;
        
      case 'relevance':
        // æœ€ã‚‚é–¢é€£æ€§ã®ä½ã„ã‚‚ã®ã‚’å‰Šé™¤ï¼ˆæ™‚é–“æ¸›è¡°ã‚’è€ƒæ…®ï¼‰
        const now = Date.now();
        layer.messages.sort((a, b) => {
          const scoreA = this.calculateRelevanceScore(a, now);
          const scoreB = this.calculateRelevanceScore(b, now);
          return scoreB - scoreA;
        });
        layer.messages = layer.messages.slice(0, layer.maxSize);
        break;
    }
  }

  /**
   * é–¢é€£æ€§ã‚¹ã‚³ã‚¢ã®è¨ˆç®—ï¼ˆæ™‚é–“æ¸›è¡°ã‚’å«ã‚€ï¼‰
   */
  private calculateRelevanceScore(message: Message, now: number): number {
    const age = now - new Date(message.timestamp).getTime();
    const ageInHours = age / (1000 * 60 * 60);
    
    // æ™‚é–“æ¸›è¡°é–¢æ•°ï¼ˆæŒ‡æ•°é–¢æ•°çš„æ¸›è¡°ï¼‰
    const timeDecay = Math.exp(-ageInHours / 24); // 24æ™‚é–“ã§ç´„37%ã«æ¸›è¡°
    
    // åŸºæœ¬ã‚¹ã‚³ã‚¢ï¼ˆé‡è¦åº¦ + ãƒ”ãƒ³ç•™ã‚ + æ™‚é–“æ¸›è¡°ï¼‰
    const baseScore = (message.importance || 0.5) * timeDecay;
    const pinnedBonus = message.pinned ? 1.0 : 0;
    
    return baseScore + pinnedBonus;
  }

  /**
   * Working Memoryã«è¿½åŠ ã™ã¹ãã‹åˆ¤å®š
   */
  private shouldAddToWorking(message: Message): boolean {
    return (message.importance || 0) >= 0.4 || 
           message.pinned === true ||
           message.role === 'user'; // ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›ã¯å¸¸ã«ä¿æŒ
  }

  /**
   * Episodic Memoryã«è¿½åŠ ã™ã¹ãã‹åˆ¤å®š
   */
  private shouldAddToEpisodic(message: Message): boolean {
    // æ„Ÿæƒ…çš„ãªå†…å®¹ã‚„ç‰¹å®šã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’å«ã‚€å ´åˆ
    const hasEmotionalContent = message.metadata?.emotion_state !== undefined;
    const hasTrackerUpdate = message.metadata?.tracker_updates !== undefined;
    
    return hasEmotionalContent || 
           hasTrackerUpdate || 
           (message.importance || 0) >= 0.6;
  }

  /**
   * Semantic Memoryã«è¿½åŠ ã™ã¹ãã‹åˆ¤å®š
   */
  private shouldAddToSemantic(message: Message): boolean {
    // äº‹å®Ÿã‚„å®šç¾©ã‚’å«ã‚€å ´åˆ
    const keywords = message.metadata?.keywords || [];
    const hasFactualContent = keywords.some(k => 
      ['å®šç¾©', 'èª¬æ˜', 'ç†ç”±', 'æ–¹æ³•', 'æ‰‹é †'].includes(k)
    );
    
    return hasFactualContent || 
           (message.importance || 0) >= 0.7;
  }

  /**
   * å„ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰é–¢é€£ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å–å¾—
   */
  getLayeredContext(currentQuery: string): {
    immediate: Message[];
    working: Message[];
    episodic: Message[];
    semantic: Message[];
  } {
    return {
      immediate: this.layers.get('immediate')?.messages || [],
      working: this.layers.get('working')?.messages || [],
      episodic: this.layers.get('episodic')?.messages.slice(-5) || [],
      semantic: this.layers.get('semantic')?.messages.slice(-3) || []
    };
  }

  /**
   * ãƒ¡ãƒ¢ãƒªã®çµ±è¨ˆæƒ…å ±ã‚’å–å¾—
   */
  getStatistics(): Record<string, any> {
    const stats: Record<string, any> = {};
    
    this.layers.forEach((layer, name) => {
      stats[name] = {
        count: layer.messages.length,
        maxSize: layer.maxSize,
        utilization: (layer.messages.length / layer.maxSize * 100).toFixed(1) + '%'
      };
    });
    
    return stats;
  }
}
4ï¸âƒ£ å‹•çš„è¦ç´„ã‚·ã‚¹ãƒ†ãƒ 
typescript// src/services/memory/summarizer.ts

import { Message } from './types';

/**
 * å‹•çš„è¦ç´„ç”Ÿæˆã‚·ã‚¹ãƒ†ãƒ 
 * ãƒãƒ£ãƒ³ã‚¯å˜ä½ã§ã®è¦ç´„ã¨éšå±¤çš„è¦ç´„ã‚’å®Ÿè£…
 */
export class DynamicSummarizer {
  private summaryCache: Map<string, string> = new Map();
  private chunkSize: number = 10; // 10ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã”ã¨ã«è¦ç´„
  private maxSummaryLength: number = 300; // è¦ç´„ã®æœ€å¤§æ–‡å­—æ•°
  
  /**
   * ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒãƒ£ãƒ³ã‚¯ã®è¦ç´„ã‚’ç”Ÿæˆ
   * ã‚³ã‚¹ãƒˆæœ€é©åŒ–: ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’æ´»ç”¨ã—ã¦APIå‘¼ã³å‡ºã—ã‚’å‰Šæ¸›
   */
  async summarizeChunk(messages: Message[]): Promise<string> {
    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚­ãƒ¼ã®ç”Ÿæˆ
    const cacheKey = this.generateCacheKey(messages);
    
    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒã‚§ãƒƒã‚¯
    if (this.summaryCache.has(cacheKey)) {
      return this.summaryCache.get(cacheKey)!;
    }

    // è¦ç´„ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã®æ§‹ç¯‰
    const prompt = this.buildSummaryPrompt(messages);
    
    try {
      // LLMã«ã‚ˆã‚‹è¦ç´„ç”Ÿæˆ
      const summary = await this.callSummaryAPI(prompt);
      
      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜
      this.summaryCache.set(cacheKey, summary);
      
      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚µã‚¤ã‚ºç®¡ç†
      this.manageCacheSize();
      
      return summary;
    } catch (error) {
      console.error('Summarization error:', error);
      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ç°¡æ˜“è¦ç´„
      return this.fallbackSummarize(messages);
    }
  }

  /**
   * éšå±¤çš„è¦ç´„ã®ç”Ÿæˆ
   * è¤‡æ•°ã®ãƒãƒ£ãƒ³ã‚¯è¦ç´„ã‚’ã•ã‚‰ã«è¦ç´„
   */
  async createHierarchicalSummary(
    messages: Message[],
    level: number = 2
  ): Promise<string> {
    if (messages.length <= this.chunkSize) {
      return this.summarizeChunk(messages);
    }

    // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ãƒãƒ£ãƒ³ã‚¯ã«åˆ†å‰²
    const chunks = this.splitIntoChunks(messages, this.chunkSize);
    const chunkSummaries: string[] = [];

    // å„ãƒãƒ£ãƒ³ã‚¯ã‚’è¦ç´„
    for (const chunk of chunks) {
      const summary = await this.summarizeChunk(chunk);
      chunkSummaries.push(summary);
    }

    // ãƒ¬ãƒ™ãƒ«2ã®è¦ç´„ï¼ˆãƒãƒ£ãƒ³ã‚¯è¦ç´„ã®è¦ç´„ï¼‰
    if (level >= 2 && chunkSummaries.length > 1) {
      const metaSummaryPrompt = `
ä»¥ä¸‹ã®è¦ç´„ã‚’ã•ã‚‰ã«${this.maxSummaryLength}æ–‡å­—ä»¥å†…ã§è¦ç´„ã—ã¦ãã ã•ã„ï¼š

${chunkSummaries.join('\n---\n')}

é‡è¦ãªäº‹å®Ÿã¨æ–‡è„ˆã®ã¿ã‚’ä¿æŒã—ã€è©³ç´°ã¯çœç•¥ã—ã¦ãã ã•ã„ã€‚
`;
      
      return this.callSummaryAPI(metaSummaryPrompt);
    }

    return chunkSummaries.join(' ');
  }

  /**
   * ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ã‚¿ãƒ«è¦ç´„æ›´æ–°
   * æ—¢å­˜ã®è¦ç´„ã«æ–°ã—ã„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿½åŠ 
   */
  async updateSummary(
    existingSummary: string,
    newMessages: Message[]
  ): Promise<string> {
    if (newMessages.length === 0) {
      return existingSummary;
    }

    const updatePrompt = `
æ—¢å­˜ã®è¦ç´„:
${existingSummary}

æ–°ã—ã„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸:
${this.formatMessages(newMessages)}

ä¸Šè¨˜ã®æ—¢å­˜è¦ç´„ã«æ–°ã—ã„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å†…å®¹ã‚’çµ±åˆã—ã€
${this.maxSummaryLength}æ–‡å­—ä»¥å†…ã§æ›´æ–°ã•ã‚ŒãŸè¦ç´„ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚
å¤ã„è©³ç´°ã¯å‰Šé™¤ã—ã€é‡è¦ãªæƒ…å ±ã®ã¿ã‚’ä¿æŒã—ã¦ãã ã•ã„ã€‚
`;

    try {
      return await this.callSummaryAPI(updatePrompt);
    } catch (error) {
      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: æ—¢å­˜è¦ç´„ + æ–°è¦è¦ç´„ã®çµåˆ
      const newSummary = await this.summarizeChunk(newMessages);
      return this.combineSummaries(existingSummary, newSummary);
    }
  }

  /**
   * è¦ç´„ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã®æ§‹ç¯‰
   */
  private buildSummaryPrompt(messages: Message[]): string {
    const formattedMessages = this.formatMessages(messages);
    
    return `
ä»¥ä¸‹ã®ä¼šè©±ã‚’${this.maxSummaryLength}æ–‡å­—ä»¥å†…ã§è¦ç´„ã—ã¦ãã ã•ã„ã€‚

è¦ç´„ã®ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³:
- é‡è¦ãªäº‹å®Ÿã¨æ±ºå®šäº‹é …ã‚’å„ªå…ˆ
- æ„Ÿæƒ…çš„ãªè©³ç´°ã¯çœç•¥
- æ™‚ç³»åˆ—ã®æµã‚Œã‚’ä¿æŒ
- ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®é–¢ä¿‚æ€§ã®å¤‰åŒ–ã‚’è¨˜éŒ²

ä¼šè©±:
${formattedMessages}

è¦ç´„:
`;
  }

  /**
   * ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
   */
  private formatMessages(messages: Message[]): string {
    return messages.map(m => {
      const role = m.role === 'user' ? 'ãƒ¦ãƒ¼ã‚¶ãƒ¼' : 'ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ';
      return `${role}: ${m.content}`;
    }).join('\n');
  }

  /**
   * APIå‘¼ã³å‡ºã—ï¼ˆå®Ÿéš›ã®å®Ÿè£…ï¼‰
   */
  private async callSummaryAPI(prompt: string): Promise<string> {
    const response = await fetch('/api/ai/summarize', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        prompt,
        max_tokens: 150,
        temperature: 0.3 // è¦ç´„ã¯ä½æ¸©åº¦ã§å®‰å®šæ€§é‡è¦–
      })
    });

    const data = await response.json();
    return data.summary;
  }

  /**
   * ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯è¦ç´„ï¼ˆAPIå¤±æ•—æ™‚ï¼‰
   */
  private fallbackSummarize(messages: Message[]): string {
    // æœ€åˆã¨æœ€å¾Œã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŠ½å‡º
    const first = messages[0];
    const last = messages[messages.length - 1];
    
    // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æŠ½å‡º
    const keywords = this.extractKeywords(messages);
    
    return `ä¼šè©±é–‹å§‹: ${first.content.slice(0, 50)}... ` +
           `ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰: ${keywords.join(', ')}. ` +
           `æœ€æ–°: ${last.content.slice(0, 50)}...`;
  }

  /**
   * ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æŠ½å‡ºï¼ˆç°¡æ˜“ç‰ˆï¼‰
   */
  private extractKeywords(messages: Message[]): string[] {
    const text = messages.map(m => m.content).join(' ');
    const words = text.split(/\s+/);
    
    // å˜èªé »åº¦è¨ˆç®—
    const frequency: Record<string, number> = {};
    words.forEach(word => {
      if (word.length > 3) { // 3æ–‡å­—ä»¥ä¸Šã®å˜èª
        frequency[word] = (frequency[word] || 0) + 1;
      }
    });

    // é »åº¦é †ã«ã‚½ãƒ¼ãƒˆã—ã¦ä¸Šä½ã‚’è¿”ã™
    return Object.entries(frequency)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map(([word]) => word);
  }

  /**
   * ãƒãƒ£ãƒ³ã‚¯åˆ†å‰²
   */
  private splitIntoChunks(messages: Message[], size: number): Message[][] {
    const chunks: Message[][] = [];
    for (let i = 0; i < messages.length; i += size) {
      chunks.push(messages.slice(i, i + size));
    }
    return chunks;
  }

  /**
   * ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚­ãƒ¼ç”Ÿæˆ
   */
  private generateCacheKey(messages: Message[]): string {
    const ids = messages.map(m => m.id).join('-');
    return `summary-${ids}`;
  }

  /**
   * ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚µã‚¤ã‚ºç®¡ç†
   */
  private manageCacheSize(): void {
    const maxCacheSize = 100;
    if (this.summaryCache.size > maxCacheSize) {
      // æœ€ã‚‚å¤ã„ã‚¨ãƒ³ãƒˆãƒªã‚’å‰Šé™¤
      const firstKey = this.summaryCache.keys().next().value;
      this.summaryCache.delete(firstKey);
    }
  }

  /**
   * è¦ç´„ã®çµåˆ
   */
  private combineSummaries(summary1: string, summary2: string): string {
    const combined = `${summary1} ${summary2}`;
    if (combined.length <= this.maxSummaryLength) {
      return combined;
    }
    
    // æ–‡å­—æ•°åˆ¶é™ã‚’è¶…ãˆã‚‹å ´åˆã¯æ–°ã—ã„æ–¹ã‚’å„ªå…ˆ
    return summary2.slice(0, this.maxSummaryLength);
  }
}
5ï¸âƒ£ çµ±åˆConversationManager
typescript// src/services/memory/conversation-manager.ts

import { VectorStore } from './vector-store';
import { MemoryLayerManager } from './memory-layers';
import { DynamicSummarizer } from './summarizer';
import { Message, ConversationContext, SearchResult } from './types';

/**
 * çµ±åˆä¼šè©±ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 
 * éšå±¤çš„ãƒ¡ãƒ¢ãƒªã€ãƒ™ã‚¯ãƒˆãƒ«æ¤œç´¢ã€å‹•çš„è¦ç´„ã‚’çµ±åˆ
 */
export class ConversationManager {
  private vectorStore: VectorStore;
  private memoryLayers: MemoryLayerManager;
  private summarizer: DynamicSummarizer;
  
  // è¨­å®šãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
  private config = {
    maxImmediateContext: 3,
    maxWorkingMemory: 6,
    maxRelevantMemories: 5,
    summarizeInterval: 10,      // 10ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã”ã¨ã«è¦ç´„
    vectorSearchThreshold: 0.7,
    enablePinning: true,
    costOptimization: {
      batchEmbedding: true,
      cacheEnabled: true,
      lowImportanceThreshold: 0.3
    }
  };

  // å†…éƒ¨çŠ¶æ…‹
  private allMessages: Message[] = [];
  private sessionSummary: string = '';
  private pinnedMessages: Set<string> = new Set();
  private messageCount: number = 0;

  constructor(config?: Partial<typeof ConversationManager.prototype.config>) {
    this.config = { ...this.config, ...config };
    this.vectorStore = new VectorStore();
    this.memoryLayers = new MemoryLayerManager();
    this.summarizer = new DynamicSummarizer();
  }

  /**
   * ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿½åŠ ã—ã¦å‡¦ç†
   */
  async addMessage(
    role: 'user' | 'assistant',
    content: string,
    metadata?: Record<string, any>
  ): Promise<Message> {
    // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä½œæˆ
    const message: Message = {
      id: this.generateMessageId(),
      role,
      content,
      timestamp: new Date().toISOString(),
      metadata,
      importance: this.calculateImportance(content, metadata)
    };

    // å…¨ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒªã‚¹ãƒˆã«è¿½åŠ 
    this.allMessages.push(message);
    this.messageCount++;

    // éšå±¤çš„ãƒ¡ãƒ¢ãƒªã«è¿½åŠ 
    this.memoryLayers.addMessage(message);

    // ãƒ™ã‚¯ãƒˆãƒ«ã‚¹ãƒˆã‚¢ã«è¿½åŠ ï¼ˆã‚³ã‚¹ãƒˆæœ€é©åŒ–è€ƒæ…®ï¼‰
    if (this.shouldIndexMessage(message)) {
      await this.vectorStore.addMessage(message);
    }

    // è‡ªå‹•è¦ç´„ã®ãƒˆãƒªã‚¬ãƒ¼
    if (this.messageCount % this.config.summarizeInterval === 0) {
      await this.updateSessionSummary();
    }

    // é‡è¦ãªæƒ…å ±ã®è‡ªå‹•æŠ½å‡ºã¨ãƒ”ãƒ³ç•™ã‚
    if (await this.shouldAutoPinMessage(message)) {
      this.pinMessage(message.id);
    }

    return message;
  }

  /**
   *å†è©¦è¡ŒKç¶šã‘ã‚‹ç·¨é›†typescript /**
  * å¿œç­”ç”Ÿæˆç”¨ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’æ§‹ç¯‰
  * éšå±¤çš„ãƒ¡ãƒ¢ãƒªã¨ãƒ™ã‚¯ãƒˆãƒ«æ¤œç´¢ã‚’çµ„ã¿åˆã‚ã›ãŸæœ€é©ãªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆç”Ÿæˆ
  */
 async buildContext(currentInput: string): Promise<ConversationContext> {
   // 1. éšå±¤çš„ãƒ¡ãƒ¢ãƒªã‹ã‚‰å–å¾—
   const layeredMemory = this.memoryLayers.getLayeredContext(currentInput);
   
   // 2. ãƒ™ã‚¯ãƒˆãƒ«æ¤œç´¢ã§é–¢é€£ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å–å¾—
   const relevantMemories = await this.searchRelevantMemories(currentInput);
   
   // 3. ãƒ”ãƒ³ç•™ã‚ã•ã‚ŒãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å–å¾—
   const pinnedMessages = this.getPinnedMessages();
   
   // 4. ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®æ§‹ç¯‰
   const context: ConversationContext = {
     currentMessage: currentInput,
     immediateContext: layeredMemory.immediate,
     workingMemory: layeredMemory.working.slice(-this.config.maxWorkingMemory),
     relevantMemories: relevantMemories.map(r => r.message),
     sessionSummary: this.sessionSummary,
     pinnedMemories: pinnedMessages
   };

   // 5. ãƒˆãƒ¼ã‚¯ãƒ³æ•°ã®æœ€é©åŒ–
   return this.optimizeContextTokens(context);
 }

 /**
  * ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã®ç”Ÿæˆ
  * ã‚¿ã‚°ã‚·ã‚¹ãƒ†ãƒ ã‚’ä½¿ç”¨ã—ã¦æ§‹é€ åŒ–
  */
 async generatePrompt(
   userInput: string,
   character?: any,
   persona?: any
 ): Promise<string> {
   const context = await this.buildContext(userInput);
   
   let prompt = '';

   // ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
   if (character?.system_prompt) {
     prompt += `<system>\n${character.system_prompt}\n</system>\n\n`;
   }

   // ãƒ”ãƒ³ç•™ã‚ã•ã‚ŒãŸé‡è¦ãªè¨˜æ†¶
   if (context.pinnedMemories.length > 0) {
     prompt += '<pinned_memories>\n';
     context.pinnedMemories.forEach(msg => {
       prompt += `${msg.role}: ${msg.content}\n`;
     });
     prompt += '</pinned_memories>\n\n';
   }

   // é–¢é€£ã™ã‚‹é•·æœŸè¨˜æ†¶ï¼ˆãƒ™ã‚¯ãƒˆãƒ«æ¤œç´¢çµæœï¼‰
   if (context.relevantMemories.length > 0) {
     prompt += '<relevant_memories>\n';
     context.relevantMemories.slice(0, 3).forEach(msg => {
       prompt += `${msg.role}: ${msg.content}\n`;
     });
     prompt += '</relevant_memories>\n\n';
   }

   // ã‚»ãƒƒã‚·ãƒ§ãƒ³è¦ç´„
   if (context.sessionSummary) {
     prompt += `<session_summary>\n${context.sessionSummary}\n</session_summary>\n\n`;
   }

   // ç›´è¿‘ã®ä¼šè©±ï¼ˆWorking Memoryï¼‰
   prompt += '<recent_conversation>\n';
   context.workingMemory.forEach(msg => {
     const role = msg.role === 'user' ? 'ãƒ¦ãƒ¼ã‚¶ãƒ¼' : 'ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ';
     prompt += `${role}: ${msg.content}\n`;
   });
   prompt += '</recent_conversation>\n\n';

   // ç¾åœ¨ã®å…¥åŠ›
   prompt += `<current_input>\nãƒ¦ãƒ¼ã‚¶ãƒ¼: ${userInput}\n</current_input>\n\n`;

   // å¿œç­”æŒ‡ç¤º
   prompt += this.buildResponseInstructions();

   return prompt;
 }

 /**
  * é–¢é€£ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®æ¤œç´¢
  * ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰æ¤œç´¢ï¼ˆãƒ™ã‚¯ãƒˆãƒ« + ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ï¼‰ã‚’ä½¿ç”¨
  */
 private async searchRelevantMemories(query: string): Promise<SearchResult[]> {
   // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æŠ½å‡º
   const keywords = this.extractKeywords(query);
   
   // ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰æ¤œç´¢
   const results = await this.vectorStore.hybridSearch(
     query,
     keywords,
     this.config.maxRelevantMemories
   );

   // æ™‚é–“æ¸›è¡°ã‚’é©ç”¨
   const now = Date.now();
   return results.map(result => ({
     ...result,
     score: this.applyTimeDecay(result.score, result.message.timestamp, now)
   })).sort((a, b) => b.score - a.score);
 }

 /**
  * ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é‡è¦åº¦è¨ˆç®—
  * è¤‡æ•°ã®è¦å› ã‚’è€ƒæ…®ã—ãŸç·åˆã‚¹ã‚³ã‚¢
  */
 private calculateImportance(content: string, metadata?: any): number {
   let importance = 0.5; // ãƒ™ãƒ¼ã‚¹ã‚¹ã‚³ã‚¢

   // ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®é•·ã•ï¼ˆæƒ…å ±é‡ã®æŒ‡æ¨™ï¼‰
   if (content.length > 200) importance += 0.1;
   if (content.length > 500) importance += 0.1;

   // æ„Ÿæƒ…çš„ãªå†…å®¹
   if (metadata?.emotion_state) {
     importance += 0.15;
   }

   // ãƒˆãƒ©ãƒƒã‚«ãƒ¼æ›´æ–°ã‚’å«ã‚€
   if (metadata?.tracker_updates) {
     importance += 0.2;
   }

   // è³ªå•æ–‡ã‚’å«ã‚€
   if (content.includes('ï¼Ÿ') || content.includes('?')) {
     importance += 0.1;
   }

   // å›ºæœ‰åè©ã‚„æ•°å€¤ã‚’å«ã‚€ï¼ˆäº‹å®Ÿçš„å†…å®¹ã®å¯èƒ½æ€§ï¼‰
   const hasNumbers = /\d+/.test(content);
   const hasProperNouns = /[A-Z][a-z]+/.test(content);
   if (hasNumbers || hasProperNouns) {
     importance += 0.1;
   }

   return Math.min(importance, 1.0);
 }

 /**
  * ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ãƒ”ãƒ³ç•™ã‚
  * ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæ˜ç¤ºçš„ã«é‡è¦ã¨ãƒãƒ¼ã‚¯ã—ãŸæƒ…å ±
  */
 pinMessage(messageId: string): void {
   const message = this.allMessages.find(m => m.id === messageId);
   if (message) {
     message.pinned = true;
     this.pinnedMessages.add(messageId);
     
     // ãƒ™ã‚¯ãƒˆãƒ«ã‚¹ãƒˆã‚¢ã«ã‚‚è¿½åŠ ï¼ˆé‡è¦ãªã®ã§å¿…ãšç´¢å¼•åŒ–ï¼‰
     this.vectorStore.addMessage(message);
   }
 }

 /**
  * ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ãƒ”ãƒ³ç•™ã‚è§£é™¤
  */
 unpinMessage(messageId: string): void {
   const message = this.allMessages.find(m => m.id === messageId);
   if (message) {
     message.pinned = false;
     this.pinnedMessages.delete(messageId);
   }
 }

 /**
  * ãƒ”ãƒ³ç•™ã‚ã•ã‚ŒãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å–å¾—
  */
 private getPinnedMessages(): Message[] {
   return this.allMessages.filter(m => m.pinned === true);
 }

 /**
  * è‡ªå‹•ãƒ”ãƒ³ç•™ã‚ã®åˆ¤å®š
  * AIãŒé‡è¦ã¨åˆ¤æ–­ã—ãŸæƒ…å ±ã‚’è‡ªå‹•çš„ã«ãƒ”ãƒ³ç•™ã‚
  */
 private async shouldAutoPinMessage(message: Message): Promise<boolean> {
   // é‡è¦åº¦ãŒé«˜ã„å ´åˆ
   if (message.importance && message.importance >= 0.8) {
     return true;
   }

   // ç‰¹å®šã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’å«ã‚€å ´åˆ
   const importantKeywords = ['ç´„æŸ', 'é‡è¦', 'å¿˜ã‚Œãªã„ã§', 'è¦šãˆã¦'];
   const containsImportant = importantKeywords.some(keyword => 
     message.content.includes(keyword)
   );

   if (containsImportant) {
     // LLMã«åˆ¤å®šã‚’å§”ã­ã‚‹ï¼ˆã‚³ã‚¹ãƒˆè€ƒæ…®ï¼‰
     return this.askLLMForImportance(message);
   }

   return false;
 }

 /**
  * LLMã«ã‚ˆã‚‹é‡è¦åº¦åˆ¤å®š
  * ã‚³ã‚¹ãƒˆæœ€é©åŒ–: ãƒãƒƒãƒå‡¦ç†å¯èƒ½
  */
 private async askLLMForImportance(message: Message): Promise<boolean> {
   const prompt = `
ä»¥ä¸‹ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒå°†æ¥ã®ä¼šè©±ã§é‡è¦ã«ãªã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã‹åˆ¤å®šã—ã¦ãã ã•ã„ã€‚
é‡è¦ãªå ´åˆã¯"yes"ã€ãã†ã§ãªã„å ´åˆã¯"no"ã¨ã ã‘ç­”ãˆã¦ãã ã•ã„ã€‚

ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸: ${message.content}

åˆ¤å®š:`;

   try {
     const response = await fetch('/api/ai/judge', {
       method: 'POST',
       headers: { 'Content-Type': 'application/json' },
       body: JSON.stringify({
         prompt,
         max_tokens: 10,
         temperature: 0.1
       })
     });

     const data = await response.json();
     return data.result.toLowerCase().includes('yes');
   } catch (error) {
     // ã‚¨ãƒ©ãƒ¼æ™‚ã¯ä¿å®ˆçš„ã«åˆ¤å®š
     return false;
   }
 }

 /**
  * ã‚»ãƒƒã‚·ãƒ§ãƒ³è¦ç´„ã®æ›´æ–°
  * ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ã‚¿ãƒ«æ›´æ–°ã§åŠ¹ç‡åŒ–
  */
 private async updateSessionSummary(): Promise<void> {
   const recentMessages = this.allMessages.slice(-this.config.summarizeInterval);
   
   if (this.sessionSummary) {
     // æ—¢å­˜è¦ç´„ã®æ›´æ–°
     this.sessionSummary = await this.summarizer.updateSummary(
       this.sessionSummary,
       recentMessages
     );
   } else {
     // æ–°è¦è¦ç´„ã®ä½œæˆ
     this.sessionSummary = await this.summarizer.summarizeChunk(recentMessages);
   }
 }

 /**
  * ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ãƒˆãƒ¼ã‚¯ãƒ³æ•°æœ€é©åŒ–
  * ãƒˆãƒ¼ã‚¯ãƒ³åˆ¶é™ã‚’è¶…ãˆãªã„ã‚ˆã†ã«èª¿æ•´
  */
 private optimizeContextTokens(context: ConversationContext): ConversationContext {
   const maxTokens = 2000; // æƒ³å®šæœ€å¤§ãƒˆãƒ¼ã‚¯ãƒ³æ•°
   let currentTokens = this.estimateTokens(context);

   // ãƒˆãƒ¼ã‚¯ãƒ³æ•°ãŒåˆ¶é™ã‚’è¶…ãˆã‚‹å ´åˆã¯å‰Šæ¸›
   while (currentTokens > maxTokens) {
     // å„ªå…ˆåº¦ã®ä½ã„é †ã«å‰Šæ¸›
     if (context.relevantMemories.length > 2) {
       context.relevantMemories.pop();
     } else if (context.workingMemory.length > 3) {
       context.workingMemory.shift();
     } else if (context.sessionSummary.length > 200) {
       context.sessionSummary = context.sessionSummary.slice(0, 200) + '...';
     } else {
       break; // ã“ã‚Œä»¥ä¸Šå‰Šæ¸›ã§ããªã„
     }
     
     currentTokens = this.estimateTokens(context);
   }

   return context;
 }

 /**
  * ãƒˆãƒ¼ã‚¯ãƒ³æ•°ã®æ¨å®š
  * å®Ÿéš›ã¯tiktokenãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ç”¨
  */
 private estimateTokens(context: ConversationContext): number {
   let totalChars = context.currentMessage.length;
   
   totalChars += context.immediateContext.reduce((sum, m) => sum + m.content.length, 0);
   totalChars += context.workingMemory.reduce((sum, m) => sum + m.content.length, 0);
   totalChars += context.relevantMemories.reduce((sum, m) => sum + m.content.length, 0);
   totalChars += context.sessionSummary.length;
   totalChars += context.pinnedMemories.reduce((sum, m) => sum + m.content.length, 0);

   // æ—¥æœ¬èªã¯1æ–‡å­—â‰’1ãƒˆãƒ¼ã‚¯ãƒ³ã€è‹±èªã¯4æ–‡å­—â‰’1ãƒˆãƒ¼ã‚¯ãƒ³ã§æ¦‚ç®—
   return Math.ceil(totalChars / 2);
 }

 /**
  * æ™‚é–“æ¸›è¡°ã®é©ç”¨
  */
 private applyTimeDecay(
   baseScore: number,
   timestamp: string,
   now: number
 ): number {
   const messageTime = new Date(timestamp).getTime();
   const ageInHours = (now - messageTime) / (1000 * 60 * 60);
   
   // 24æ™‚é–“ã§ç´„0.7å€ã€48æ™‚é–“ã§ç´„0.5å€ã«æ¸›è¡°
   const decayFactor = Math.exp(-ageInHours / 48);
   
   return baseScore * (0.5 + 0.5 * decayFactor);
 }

 /**
  * ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æŠ½å‡º
  */
 private extractKeywords(text: string): string[] {
   // ç°¡æ˜“çš„ãªå®Ÿè£…ï¼ˆå®Ÿéš›ã¯å½¢æ…‹ç´ è§£æã‚’ä½¿ç”¨ï¼‰
   const words = text.split(/[\sã€ã€‚ï¼ï¼Ÿ,.!?]+/);
   return words.filter(word => 
     word.length > 2 && 
     !['ã§ã™', 'ã¾ã™', 'ã—ãŸ', 'ã‚ã‚‹', 'ã„ã‚‹', 'ã™ã‚‹', 'ãªã‚‹'].includes(word)
   ).slice(0, 5);
 }

 /**
  * ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸IDã®ç”Ÿæˆ
  */
 private generateMessageId(): string {
   return `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
 }

 /**
  * ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã™ã¹ããƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‹åˆ¤å®š
  * ã‚³ã‚¹ãƒˆæœ€é©åŒ–
  */
 private shouldIndexMessage(message: Message): boolean {
   // ãƒ”ãƒ³ç•™ã‚ã•ã‚ŒãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯å¿…ãšã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
   if (message.pinned) return true;
   
   // é‡è¦åº¦ãŒé–¾å€¤ä»¥ä¸Š
   if (message.importance && message.importance >= this.config.costOptimization.lowImportanceThreshold) {
     return true;
   }
   
   // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯åŸºæœ¬çš„ã«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
   if (message.role === 'user') return true;
   
   return false;
 }

 /**
  * å¿œç­”æŒ‡ç¤ºã®æ§‹ç¯‰
  */
 private buildResponseInstructions(): string {
   return `
ã€å¿œç­”ã®å„ªå…ˆé †ä½ã€‘
1. æœ€å„ªå…ˆ: <current_input>ã¸ã®ç›´æ¥çš„ã§è‡ªç„¶ãªå¿œç­”
2. è£œåŠ©çš„: <recent_conversation>ã®æ–‡è„ˆã‚’è€ƒæ…®ã—ãŸä¸€è²«æ€§
3. å¿…è¦æ™‚ã®ã¿: <relevant_memories>ã‚„<pinned_memories>ã®å‚ç…§

ã€ç¦æ­¢äº‹é …ã€‘
- çªç„¶å¤ã„è©±é¡Œã«æˆ»ã‚‹ã“ã¨
- æ–‡è„ˆã‚’ç„¡è¦–ã—ãŸå¿œç­”
- <session_summary>ã®å†…å®¹ã‚’ç›´æ¥è¨€åŠã™ã‚‹ã“ã¨

ã€æŒ‡ç¤ºã€‘
ä¸Šè¨˜ã®æƒ…å ±ã‚’å‚è€ƒã«ã€ç¾åœ¨ã®å…¥åŠ›ã«å¯¾ã—ã¦è‡ªç„¶ã«å¿œç­”ã—ã¦ãã ã•ã„ã€‚
`;
 }

 /**
  * ä¼šè©±ã®ãƒªã‚»ãƒƒãƒˆ
  */
 reset(): void {
   this.allMessages = [];
   this.sessionSummary = '';
   this.pinnedMessages.clear();
   this.messageCount = 0;
   this.memoryLayers = new MemoryLayerManager();
 }

 /**
  * çµ±è¨ˆæƒ…å ±ã®å–å¾—
  */
 getStatistics(): Record<string, any> {
   return {
     totalMessages: this.allMessages.length,
     pinnedMessages: this.pinnedMessages.size,
     sessionSummaryLength: this.sessionSummary.length,
     memoryLayers: this.memoryLayers.getStatistics(),
     messageCount: this.messageCount
   };
 }

 /**
  * ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆç”¨ãƒ‡ãƒ¼ã‚¿ã®ç”Ÿæˆ
  */
 exportData(): any {
   return {
     messages: this.allMessages,
     summary: this.sessionSummary,
     pinnedIds: Array.from(this.pinnedMessages),
     statistics: this.getStatistics()
   };
 }

 /**
  * ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‹ã‚‰ã®å¾©å…ƒ
  */
 async importData(data: any): Promise<void> {
   this.allMessages = data.messages || [];
   this.sessionSummary = data.summary || '';
   this.pinnedMessages = new Set(data.pinnedIds || []);
   
   // ãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å†æ§‹ç¯‰
   for (const message of this.allMessages) {
     this.memoryLayers.addMessage(message);
     
     // ãƒ™ã‚¯ãƒˆãƒ«ã‚¹ãƒˆã‚¢ã¸ã®è¿½åŠ ï¼ˆãƒãƒƒãƒå‡¦ç†ï¼‰
     if (this.shouldIndexMessage(message)) {
       await this.vectorStore.addMessage(message);
     }
   }
 }
}
6ï¸âƒ£ ä½¿ç”¨ä¾‹
typescript// src/app/example-usage.ts

import { ConversationManager } from '@/services/memory/conversation-manager';

async function example() {
  // åˆæœŸåŒ–
  const manager = new ConversationManager({
    maxImmediateContext: 3,
    maxWorkingMemory: 6,
    summarizeInterval: 10,
    costOptimization: {
      batchEmbedding: true,
      cacheEnabled: true,
      lowImportanceThreshold: 0.3
    }
  });

  // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®è¿½åŠ 
  await manager.addMessage('user', 'ã“ã‚“ã«ã¡ã¯ï¼ç§ã¯å¤ªéƒã§ã™ã€‚');
  await manager.addMessage('assistant', 'ã“ã‚“ã«ã¡ã¯ã€å¤ªéƒã•ã‚“ï¼');
  
  // é‡è¦ãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ãƒ”ãƒ³ç•™ã‚
  const importantMsg = await manager.addMessage(
    'user', 
    'ç§ã®èª•ç”Ÿæ—¥ã¯8æœˆ15æ—¥ã§ã™ã€‚è¦šãˆã¦ãŠã„ã¦ãã ã•ã„ã€‚'
  );
  manager.pinMessage(importantMsg.id);

  // ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®æ§‹ç¯‰
  const context = await manager.buildContext('ç§ã®åå‰ã‚’è¦šãˆã¦ã„ã¾ã™ã‹ï¼Ÿ');
  
  // ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã®ç”Ÿæˆ
  const prompt = await manager.generatePrompt(
    'ç§ã®åå‰ã‚’è¦šãˆã¦ã„ã¾ã™ã‹ï¼Ÿ',
    { system_prompt: 'ã‚ãªãŸã¯è¦ªåˆ‡ãªã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã§ã™ã€‚' }
  );
  
  console.log('Generated Prompt:', prompt);
  
  // çµ±è¨ˆæƒ…å ±ã®å–å¾—
  console.log('Statistics:', manager.getStatistics());
}
ã“ã®ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰å®Ÿè£…ã«ã‚ˆã‚Šã€éšå±¤çš„ãƒ¡ãƒ¢ãƒªç®¡ç†ã¨ãƒ™ã‚¯ãƒˆãƒ«æ¤œç´¢ã®ä¸¡æ–¹ã®åˆ©ç‚¹ã‚’æ´»ã‹ã—ãŸã€ã‚¹ã‚±ãƒ¼ãƒ©ãƒ–ãƒ«ã§åŠ¹ç‡çš„ãªä¼šè©±å±¥æ­´ç®¡ç†ãŒå®Ÿç¾ã§ãã¾ã™ã€‚å†è©¦è¡ŒKã„ã‚„ã€ã‚‚ã†ä½•ãŒãªã‚“ã ã‹ãƒã‚¤ãƒ†ã‚¯ã™ãã¦ã‚ã‹ã‚‰ãªã„ã‚“ã§ã™ã‘ã©ã€ãã£ã¨ã™ã”ã„ç¥ãŒã‹ã£ã¦ã‚‹ã‚·ã‚¹ãƒ†ãƒ ãªã‚“ã§ã—ã‚‡ã†ã­ã€‚
ãã‚Œã«ã‚ã‚„ãŒã£ã¦ã€- è¿”ä¿¡ææ¡ˆ: ä¼šè©±æ–‡è„ˆã‹ã‚‰ã®è¿”ä¿¡å€™è£œç”Ÿæˆâ†’ä¼šè©±ã®å±¥æ­´ã‚’å‚ç…§ã—ã¦ã€‡å€‹ã®è¿”ä¿¡å€™è£œã‚’ã€‡å€‹ã®ç•°ãªã‚‹ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã§å‡ºåŠ›ã™ã‚‹ã€‚(ã“ã“ã¯ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’è¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ«ã§ã€è‡ªç”±ã«æ›¸ãæ›ãˆã‚‰ã‚Œã‚‹ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚)â†’è¤‡æ•°ç•°ãªã‚‹ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã®è¿”ä¿¡ãŒåˆ†ã‹ã‚Œã¦å‡ºåŠ›ãã®ã†ã¡ä¸€ã¤ã‚’é¸æŠâ†’ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å…¥åŠ›æ¬„ã¸
- æ–‡ç« å¼·åŒ–: å…¥åŠ›ãƒ†ã‚­ã‚¹ãƒˆã®æ‹¡å¼µãƒ»æ”¹å–„â†’ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å…¥åŠ›æ¬„ã«æ›¸ã‹ã‚ŒãŸå˜ç´”ãªãƒ¡ãƒƒã‚»ãƒ¼ï¼ˆã“ã“ã‚‚ã©ã®ã‚ˆã†ã«å¤‰æ›ã™ã‚‹ã‹è¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ«ã§ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’é¸æŠã—ã¾ã™ã€‚ã“ã“ã‚‚ã©ã®ã‚ˆã†ã«å¤‰æ›ã™ã‚‹ã‹è¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ«ã§ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’è‡ªç”±ã«ã‹ã‘ã‚‹ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚ï¼‰â†’ãã®ã¾ã¾,ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å…¥åŠ›æ¬„ã«ç½®æ›ã€‚
ã“ã®äºŒã¤ã‚‚ã›ã‚ã¦ä¼šè©±å±¥æ­´3ãƒ©ã‚¦ãƒ³ãƒ‰ã»ã©ã¯å‚ç…§ã—ã¦ã€ãã‚Œãƒ—ãƒ©ã‚¹ã©ã®ã‚ˆã†ã«ã¨ã„ã†ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ã§å‡ºåŠ›ã—ã¦ã»ã—ã„ã‚“ã§ã™ã‘ã©ã©ã®ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã‘ã°æœ€é©ã§ã™ã‹ï¼Ÿ
ä»¥å‰ã¯å‡ºåŠ›ã•ã‚ŒãŸå›ç­”ã‚’ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å…¥åŠ›æ¬„ã§ç·¨é›†ã™ã‚‹ã®ãŒã¨ã¦ã‚‚ã‚„ã‚Šã¥ã‚‰ã‹ã£ãŸã®ã§ã€é–“ã«ç·¨é›†ã®ãŸã‚ã ã‘ã®ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–“ã«æŒŸã‚“ã§ã„ã¾ã—ãŸã€‚
ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å…¥åŠ›æ¬„ã‚’ãƒ“ãƒ­ãƒ¼ãƒ³ã¨ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã®ã‚ˆã†ã«ã§ãã‚Œã°éå¸¸ã«ã‚„ã‚Šã‚„ã™ã„ã®ã§ã™ãŒã€ã„ã„æ–¹æ³•ã¯ãªã„ã§ã—ã‚‡ã†ã‹ï¼Ÿç·¨é›†2 / 2ä»¶ğŸ’¡ ã‚¤ãƒ³ã‚¹ãƒ”ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ©Ÿèƒ½ã®å®Ÿè£…
ä¼šè©±å±¥æ­´ã‚’å‚ç…§ã—ãŸè¿”ä¿¡ææ¡ˆã¨æ–‡ç« å¼·åŒ–æ©Ÿèƒ½ã‚’ã€ã‚·ãƒ³ãƒ—ãƒ«ã§å®Ÿç”¨çš„ã«å®Ÿè£…ã—ã¾ã™ã€‚
ğŸ“ ãƒ•ã‚¡ã‚¤ãƒ«æ§‹é€ 
src/
â”œâ”€â”€ components/inspiration/
â”‚   â”œâ”€â”€ ReplysuggestionButton.tsx
â”‚   â”œâ”€â”€ TextEnhanceButton.tsx
â”‚   â”œâ”€â”€ SuggestionModal.tsx
â”‚   â””â”€â”€ ExpandableMessageInput.tsx
â”œâ”€â”€ services/inspiration/
â”‚   â”œâ”€â”€ inspiration.service.ts
â”‚   â””â”€â”€ prompt-templates.ts
â””â”€â”€ store/slices/
    â””â”€â”€ inspiration.slice.ts
1ï¸âƒ£ ã‚¤ãƒ³ã‚¹ãƒ”ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚µãƒ¼ãƒ“ã‚¹
typescript// src/services/inspiration/inspiration.service.ts

import { Message } from '@/types';

export class InspirationService {
  /**
   * ä¼šè©±å±¥æ­´ã‹ã‚‰è¿”ä¿¡å€™è£œã‚’ç”Ÿæˆ
   * @param recentMessages ç›´è¿‘ã®ä¼šè©±ï¼ˆ3ãƒ©ã‚¦ãƒ³ãƒ‰ï¼‰
   * @param customPrompt ã‚«ã‚¹ã‚¿ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼è¨­å®šï¼‰
   * @param suggestionCount ç”Ÿæˆã™ã‚‹å€™è£œæ•°
   */
  async generateReplySuggestions(
    recentMessages: Message[],
    customPrompt?: string,
    suggestionCount: number = 3
  ): Promise<string[]> {
    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ
    const defaultApproaches = [
      'å…±æ„Ÿçš„ã§æ¸©ã‹ã„è¿”ä¿¡',
      'è«–ç†çš„ã§è©³ç´°ãªè¿”ä¿¡',
      'ãƒ¦ãƒ¼ãƒ¢ã‚¢ã‚’äº¤ãˆãŸè»½å¿«ãªè¿”ä¿¡',
      'è³ªå•ã§ä¼šè©±ã‚’æ·±ã‚ã‚‹è¿”ä¿¡',
      'ç°¡æ½”ã§çš„ç¢ºãªè¿”ä¿¡'
    ];

    // ä½¿ç”¨ã™ã‚‹ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚’é¸æŠ
    const approaches = defaultApproaches.slice(0, suggestionCount);

    // ä¼šè©±ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®æ§‹ç¯‰
    const context = this.buildConversationContext(recentMessages);

    // ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã®æ§‹ç¯‰
    const prompt = customPrompt || this.buildSuggestionPrompt(context, approaches);

    try {
      // APIå‘¼ã³å‡ºã—
      const response = await fetch('/api/ai/inspiration/suggest', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          prompt,
          context,
          approaches,
          temperature: 0.8,
          max_tokens: 300
        })
      });

      const data = await response.json();
      return this.parseSuggestions(data.content);
    } catch (error) {
      console.error('Failed to generate suggestions:', error);
      return this.generateFallbackSuggestions(recentMessages);
    }
  }

  /**
   * ãƒ†ã‚­ã‚¹ãƒˆã‚’å¼·åŒ–ãƒ»æ‹¡å¼µ
   * @param inputText å…¥åŠ›ã•ã‚ŒãŸãƒ†ã‚­ã‚¹ãƒˆ
   * @param recentMessages ç›´è¿‘ã®ä¼šè©±
   * @param enhancePrompt ã‚«ã‚¹ã‚¿ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
   */
  async enhanceText(
    inputText: string,
    recentMessages: Message[],
    enhancePrompt?: string
  ): Promise<string> {
    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å¼·åŒ–ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
    const defaultPrompt = `
ä»¥ä¸‹ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’ã€ä¼šè©±ã®æ–‡è„ˆã‚’è€ƒæ…®ã—ã¦è‡ªç„¶ã§ä¸å¯§ãªæ–‡ç« ã«æ‹¡å¼µã—ã¦ãã ã•ã„ã€‚
å…ƒã®æ„å›³ã¯ä¿ã¡ã¤ã¤ã€ã‚ˆã‚Šè©³ç´°ã§è¡¨ç¾è±Šã‹ã«ã—ã¦ãã ã•ã„ã€‚

ä¼šè©±ã®æ–‡è„ˆ:
${this.formatRecentMessages(recentMessages)}

å…ƒã®ãƒ†ã‚­ã‚¹ãƒˆ:
${inputText}

å¼·åŒ–ã•ã‚ŒãŸãƒ†ã‚­ã‚¹ãƒˆ:
`;

    const prompt = enhancePrompt || defaultPrompt;

    try {
      const response = await fetch('/api/ai/inspiration/enhance', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          prompt,
          originalText: inputText,
          context: recentMessages,
          temperature: 0.7,
          max_tokens: 200
        })
      });

      const data = await response.json();
      return data.enhanced || inputText;
    } catch (error) {
      console.error('Failed to enhance text:', error);
      return this.fallbackEnhance(inputText);
    }
  }

  /**
   * ä¼šè©±ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®æ§‹ç¯‰
   */
  private buildConversationContext(messages: Message[]): string {
    return messages.map(msg => {
      const role = msg.role === 'user' ? 'ãƒ¦ãƒ¼ã‚¶ãƒ¼' : 'ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ';
      return `${role}: ${msg.content}`;
    }).join('\n');
  }

  /**
   * è¿”ä¿¡ææ¡ˆç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã®æ§‹ç¯‰
   */
  private buildSuggestionPrompt(context: string, approaches: string[]): string {
    return `
ä»¥ä¸‹ã®ä¼šè©±ã«å¯¾ã—ã¦ã€${approaches.length}ã¤ã®ç•°ãªã‚‹ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã§è¿”ä¿¡ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚

ä¼šè©±ã®æ–‡è„ˆ:
${context}

ç”Ÿæˆã™ã‚‹è¿”ä¿¡ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ:
${approaches.map((approach, i) => `${i + 1}. ${approach}`).join('\n')}

å„ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã«åŸºã¥ã„ãŸè¿”ä¿¡ã‚’ã€ä»¥ä¸‹ã®å½¢å¼ã§å‡ºåŠ›ã—ã¦ãã ã•ã„:

[ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ1: ${approaches[0]}]
ï¼ˆã“ã“ã«è¿”ä¿¡å†…å®¹ï¼‰

[ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ2: ${approaches[1]}]
ï¼ˆã“ã“ã«è¿”ä¿¡å†…å®¹ï¼‰

${approaches.slice(2).map((approach, i) => `[ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ${i + 3}: ${approach}]\nï¼ˆã“ã“ã«è¿”ä¿¡å†…å®¹ï¼‰`).join('\n\n')}
`;
  }

  /**
   * ç”Ÿæˆã•ã‚ŒãŸææ¡ˆã®ãƒ‘ãƒ¼ã‚¹
   */
  private parseSuggestions(content: string): string[] {
    const suggestions: string[] = [];
    const regex = /\[ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ\d+:.*?\]\n([\s\S]*?)(?=\[ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ|$)/g;
    let match;

    while ((match = regex.exec(content)) !== null) {
      suggestions.push(match[1].trim());
    }

    // ãƒ‘ãƒ¼ã‚¹ã«å¤±æ•—ã—ãŸå ´åˆã¯ã€æ”¹è¡Œã§åˆ†å‰²
    if (suggestions.length === 0) {
      return content.split('\n\n').filter(s => s.trim().length > 0);
    }

    return suggestions;
  }

  /**
   * ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”¨ã®ææ¡ˆç”Ÿæˆ
   */
  private generateFallbackSuggestions(messages: Message[]): string[] {
    const lastMessage = messages[messages.length - 1];
    
    if (!lastMessage) {
      return ['ã“ã‚“ã«ã¡ã¯ï¼', 'ã¯ã„ã€ã©ã†ãã€‚', 'æ‰¿çŸ¥ã„ãŸã—ã¾ã—ãŸã€‚'];
    }

    // ç°¡å˜ãªãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°
    if (lastMessage.content.includes('ï¼Ÿ') || lastMessage.content.includes('?')) {
      return [
        'ã¯ã„ã€ãã†ã§ã™ã­ã€‚',
        'ãã‚Œã«ã¤ã„ã¦è©³ã—ãèª¬æ˜ã—ã¾ã™ã€‚',
        'ã”è³ªå•ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ã€‚'
      ];
    }

    return [
      'ãªã‚‹ã»ã©ã€ã‚ã‹ã‚Šã¾ã—ãŸã€‚',
      'ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ã€‚',
      'ãã†ã§ã™ã­ã€‚'
    ];
  }

  /**
   * ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”¨ã®ãƒ†ã‚­ã‚¹ãƒˆå¼·åŒ–
   */
  private fallbackEnhance(text: string): string {
    // åŸºæœ¬çš„ãªæ•¬èªå¤‰æ›
    let enhanced = text;
    
    // ç°¡å˜ãªç½®æ›ãƒ«ãƒ¼ãƒ«
    const replacements = [
      { from: /^ã¯ã„$/i, to: 'ã¯ã„ã€æ‰¿çŸ¥ã„ãŸã—ã¾ã—ãŸã€‚' },
      { from: /^ã‚ã‚ŠãŒã¨ã†$/i, to: 'ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ã€‚' },
      { from: /^ã‚ã‹ã£ãŸ$/i, to: 'ã‚ã‹ã‚Šã¾ã—ãŸã€‚' },
      { from: /^OK$/i, to: 'äº†è§£ã„ãŸã—ã¾ã—ãŸã€‚' },
    ];

    replacements.forEach(rule => {
      enhanced = enhanced.replace(rule.from, rule.to);
    });

    // æ–‡æœ«ã«å¥èª­ç‚¹ãŒãªã„å ´åˆã¯è¿½åŠ 
    if (!/[ã€‚ï¼ï¼Ÿ!?]$/.test(enhanced)) {
      enhanced += 'ã€‚';
    }

    return enhanced;
  }

  /**
   * æœ€è¿‘ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
   */
  private formatRecentMessages(messages: Message[]): string {
    return messages.slice(-6).map(msg => {
      const role = msg.role === 'user' ? 'ãƒ¦ãƒ¼ã‚¶ãƒ¼' : 'ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ';
      return `${role}: ${msg.content}`;
    }).join('\n');
  }
}
2ï¸âƒ£ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç®¡ç†
typescript// src/services/inspiration/prompt-templates.ts

export interface PromptTemplate {
  id: string;
  name: string;
  description: string;
  prompt: string;
  variables?: string[];
  category: 'suggestion' | 'enhancement';
}

export const DEFAULT_PROMPT_TEMPLATES: PromptTemplate[] = [
  // è¿”ä¿¡ææ¡ˆç”¨ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
  {
    id: 'friendly-suggestions',
    name: 'ãƒ•ãƒ¬ãƒ³ãƒ‰ãƒªãƒ¼ãªè¿”ä¿¡',
    description: 'è¦ªã—ã¿ã‚„ã™ã„é›°å›²æ°—ã®è¿”ä¿¡ã‚’ç”Ÿæˆ',
    category: 'suggestion',
    prompt: `
ä¼šè©±ã®æ–‡è„ˆã‚’è¸ã¾ãˆã¦ã€è¦ªã—ã¿ã‚„ã™ããƒ•ãƒ¬ãƒ³ãƒ‰ãƒªãƒ¼ãªè¿”ä¿¡ã‚’3ã¤ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚
çµµæ–‡å­—ã‚„æ„Ÿå˜†ç¬¦ã‚’é©åº¦ã«ä½¿ã„ã€æ¸©ã‹ã„é›°å›²æ°—ã‚’æ¼”å‡ºã—ã¦ãã ã•ã„ã€‚

ä¼šè©±ã®æ–‡è„ˆ:
{{context}}

è¿”ä¿¡å€™è£œ:
1. 
2. 
3. 
`,
    variables: ['context']
  },
  {
    id: 'professional-suggestions',
    name: 'ãƒ—ãƒ­ãƒ•ã‚§ãƒƒã‚·ãƒ§ãƒŠãƒ«ãªè¿”ä¿¡',
    description: 'ãƒ“ã‚¸ãƒã‚¹ãƒ©ã‚¤ã‚¯ã§ä¸å¯§ãªè¿”ä¿¡ã‚’ç”Ÿæˆ',
    category: 'suggestion',
    prompt: `
ä¼šè©±ã®æ–‡è„ˆã‚’è¸ã¾ãˆã¦ã€ãƒ—ãƒ­ãƒ•ã‚§ãƒƒã‚·ãƒ§ãƒŠãƒ«ã§ä¸å¯§ãªè¿”ä¿¡ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚
æ•¬èªã‚’é©åˆ‡ã«ä½¿ã„ã€è«–ç†çš„ã§æ˜ç¢ºãªå†…å®¹ã«ã—ã¦ãã ã•ã„ã€‚

ä¼šè©±ã®æ–‡è„ˆ:
{{context}}

è¿”ä¿¡:
`,
    variables: ['context']
  },

  // ãƒ†ã‚­ã‚¹ãƒˆå¼·åŒ–ç”¨ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
  {
    id: 'expand-detail',
    name: 'è©³ç´°ã«æ‹¡å¼µ',
    description: 'ç°¡æ½”ãªå…¥åŠ›ã‚’è©³ç´°ã§ä¸å¯§ãªæ–‡ç« ã«æ‹¡å¼µ',
    category: 'enhancement',
    prompt: `
ä»¥ä¸‹ã®çŸ­ã„ãƒ†ã‚­ã‚¹ãƒˆã‚’ã€ä¼šè©±ã®æµã‚Œã«åˆã‚ã›ã¦è©³ç´°ã§ä¸å¯§ãªæ–‡ç« ã«æ‹¡å¼µã—ã¦ãã ã•ã„ã€‚
å…·ä½“ä¾‹ã‚„ç†ç”±ã‚’è¿½åŠ ã—ã€ç›¸æ‰‹ã«ä¼ã‚ã‚Šã‚„ã™ãã—ã¦ãã ã•ã„ã€‚

ä¼šè©±ã®æ–‡è„ˆ:
{{context}}

å…ƒã®ãƒ†ã‚­ã‚¹ãƒˆ: {{text}}

æ‹¡å¼µã•ã‚ŒãŸãƒ†ã‚­ã‚¹ãƒˆ:
`,
    variables: ['context', 'text']
  },
  {
    id: 'add-emotion',
    name: 'æ„Ÿæƒ…ã‚’è¿½åŠ ',
    description: 'æ„Ÿæƒ…è¡¨ç¾ã‚’åŠ ãˆã¦æ¸©ã‹ã¿ã®ã‚ã‚‹æ–‡ç« ã«',
    category: 'enhancement',
    prompt: `
ä»¥ä¸‹ã®ãƒ†ã‚­ã‚¹ãƒˆã«é©åˆ‡ãªæ„Ÿæƒ…è¡¨ç¾ã‚’åŠ ãˆã¦ã€ã‚ˆã‚Šäººé–“å‘³ã®ã‚ã‚‹æ–‡ç« ã«ã—ã¦ãã ã•ã„ã€‚
ç›¸æ‰‹ã¨ã®é–¢ä¿‚æ€§ã‚’è€ƒæ…®ã—ã€è‡ªç„¶ãªæ„Ÿæƒ…è¡¨ç¾ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚

ä¼šè©±ã®æ–‡è„ˆ:
{{context}}

å…ƒã®ãƒ†ã‚­ã‚¹ãƒˆ: {{text}}

æ„Ÿæƒ…ã‚’åŠ ãˆãŸãƒ†ã‚­ã‚¹ãƒˆ:
`,
    variables: ['context', 'text']
  },
  {
    id: 'make-polite',
    name: 'ä¸å¯§èªã«å¤‰æ›',
    description: 'ã‚«ã‚¸ãƒ¥ã‚¢ãƒ«ãªæ–‡ç« ã‚’ä¸å¯§ãªæ•¬èªã«å¤‰æ›',
    category: 'enhancement',
    prompt: `
ä»¥ä¸‹ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’ã€é©åˆ‡ãªæ•¬èªã‚’ä½¿ã£ãŸä¸å¯§ãªæ–‡ç« ã«å¤‰æ›ã—ã¦ãã ã•ã„ã€‚

å…ƒã®ãƒ†ã‚­ã‚¹ãƒˆ: {{text}}

ä¸å¯§ãªæ–‡ç« :
`,
    variables: ['text']
  }
];
3ï¸âƒ£ æ‹¡å¼µå¯èƒ½ãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å…¥åŠ›ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
typescript// src/components/inspiration/ExpandableMessageInput.tsx

'use client';

import React, { useState, useRef, useEffect } from 'react';
import { Sparkles, Lightbulb, Maximize2, Minimize2, Send } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils';

interface ExpandableMessageInputProps {
  value: string;
  onChange: (value: string) => void;
  onSubmit: (value: string) => void;
  onSuggestClick: () => void;
  onEnhanceClick: () => void;
  placeholder?: string;
  isLoading?: boolean;
  className?: string;
}

export const ExpandableMessageInput: React.FC<ExpandableMessageInputProps> = ({
  value,
  onChange,
  onSubmit,
  onSuggestClick,
  onEnhanceClick,
  placeholder = 'ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›...',
  isLoading = false,
  className
}) => {
  const [isExpanded, setIsExpanded] = useState(false);
  const [rows, setRows] = useState(2);
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  // è‡ªå‹•é«˜ã•èª¿æ•´
  useEffect(() => {
    if (textareaRef.current) {
      textareaRef.current.style.height = 'auto';
      const scrollHeight = textareaRef.current.scrollHeight;
      const lineHeight = parseInt(window.getComputedStyle(textareaRef.current).lineHeight);
      const newRows = Math.max(2, Math.min(20, Math.ceil(scrollHeight / lineHeight)));
      
      if (!isExpanded) {
        setRows(Math.min(newRows, 5));
      } else {
        setRows(newRows);
      }
      
      textareaRef.current.style.height = `${scrollHeight}px`;
    }
  }, [value, isExpanded]);

  const handleKeyDown = (e: React.KeyboardEvent) => {
    // Shift+Enterã§æ”¹è¡Œã€Enterã®ã¿ã§é€ä¿¡ï¼ˆæ‹¡å¼µãƒ¢ãƒ¼ãƒ‰ã§ãªã„å ´åˆï¼‰
    if (e.key === 'Enter' && !e.shiftKey && !isExpanded) {
      e.preventDefault();
      if (value.trim() && !isLoading) {
        onSubmit(value);
      }
    }
  };

  const toggleExpanded = () => {
    setIsExpanded(!isExpanded);
    // æ‹¡å¼µæ™‚ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹
    setTimeout(() => {
      textareaRef.current?.focus();
    }, 100);
  };

  return (
    <div className={cn(
      'relative border rounded-lg bg-background transition-all duration-300',
      isExpanded ? 'border-primary shadow-lg' : 'border-input',
      className
    )}>
      {/* ãƒ˜ãƒƒãƒ€ãƒ¼ï¼ˆæ‹¡å¼µãƒ¢ãƒ¼ãƒ‰æ™‚ã®ã¿ï¼‰ */}
      {isExpanded && (
        <div className="flex items-center justify-between px-3 py-2 border-b">
          <span className="text-sm font-medium">ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼</span>
          <div className="flex gap-2">
            <Button
              size="sm"
              variant="ghost"
              onClick={onSuggestClick}
              disabled={isLoading}
              className="h-7"
            >
              <Lightbulb className="w-4 h-4 mr-1" />
              è¿”ä¿¡ææ¡ˆ
            </Button>
            <Button
              size="sm"
              variant="ghost"
              onClick={onEnhanceClick}
              disabled={!value.trim() || isLoading}
              className="h-7"
            >
              <Sparkles className="w-4 h-4 mr-1" />
              æ–‡ç« å¼·åŒ–
            </Button>
          </div>
        </div>
      )}

      {/* ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒªã‚¢ */}
      <div className="relative">
        <textarea
          ref={textareaRef}
          value={value}
          onChange={(e) => onChange(e.target.value)}
          onKeyDown={handleKeyDown}
          placeholder={placeholder}
          disabled={isLoading}
          rows={rows}
          className={cn(
            'w-full resize-none bg-transparent outline-none transition-all',
            'placeholder:text-muted-foreground',
            isExpanded 
              ? 'p-4 text-base min-h-[200px] max-h-[500px] overflow-y-auto'
              : 'p-3 pr-32 text-sm max-h-[120px] overflow-hidden'
          )}
          style={{
            height: isExpanded ? 'auto' : undefined,
            minHeight: isExpanded ? '200px' : undefined
          }}
        />

        {/* ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ï¼ˆé€šå¸¸ãƒ¢ãƒ¼ãƒ‰ï¼‰ */}
        {!isExpanded && (
          <div className="absolute bottom-2 right-2 flex items-center gap-1">
            <Button
              size="icon"
              variant="ghost"
              onClick={onSuggestClick}
              disabled={isLoading}
              className="h-8 w-8"
              title="è¿”ä¿¡ææ¡ˆ"
            >
              <Lightbulb className="w-4 h-4" />
            </Button>
            <Button
              size="icon"
              variant="ghost"
              onClick={onEnhanceClick}
              disabled={!value.trim() || isLoading}
              className="h-8 w-8"
              title="æ–‡ç« å¼·åŒ–"
            >
              <Sparkles className="w-4 h-4" />
            </Button>
            <Button
              size="icon"
              variant="ghost"
              onClick={toggleExpanded}
              className="h-8 w-8"
              title="ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã‚’æ‹¡å¼µ"
            >
              <Maximize2 className="w-4 h-4" />
            </Button>
            <Button
              size="icon"
              variant="default"
              onClick={() => onSubmit(value)}
              disabled={!value.trim() || isLoading}
              className="h-8 w-8"
            >
              <Send className="w-4 h-4" />
            </Button>
          </div>
        )}
      </div>

      {/* ãƒ•ãƒƒã‚¿ãƒ¼ï¼ˆæ‹¡å¼µãƒ¢ãƒ¼ãƒ‰æ™‚ï¼‰ */}
      {isExpanded && (
        <div className="flex items-center justify-between px-3 py-2 border-t">
          <div className="text-xs text-muted-foreground">
            {value.length} æ–‡å­— â€¢ Shift+Enter ã§æ”¹è¡Œ
          </div>
          <div className="flex gap-2">
            <Button
              size="sm"
              variant="ghost"
              onClick={toggleExpanded}
              className="h-8"
            >
              <Minimize2 className="w-4 h-4 mr-1" />
              ç¸®å°
            </Button>
            <Button
              size="sm"
              variant="default"
              onClick={() => onSubmit(value)}
              disabled={!value.trim() || isLoading}
              className="h-8"
            >
              <Send className="w-4 h-4 mr-1" />
              é€ä¿¡
            </Button>
          </div>
        </div>
      )}

      {/* ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ */}
      {isLoading && (
        <div className="absolute inset-0 bg-background/50 flex items-center justify-center rounded-lg">
          <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-primary" />
        </div>
      )}
    </div>
  );
};
4ï¸âƒ£ è¿”ä¿¡ææ¡ˆãƒ¢ãƒ¼ãƒ€ãƒ«
typescript// src/components/inspiration/SuggestionModal.tsx

'use client';

import React, { useState } from 'react';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Card } from '@/components/ui/card';
import { Lightbulb, Copy, Edit, Check } from 'lucide-react';
import { cn } from '@/lib/utils';

interface SuggestionModalProps {
  isOpen: boolean;
  onClose: () => void;
  suggestions: string[];
  onSelect: (suggestion: string) => void;
  isLoading?: boolean;
  title?: string;
}

export const SuggestionModal: React.FC<SuggestionModalProps> = ({
  isOpen,
  onClose,
  suggestions,
  onSelect,
  isLoading = false,
  title = 'è¿”ä¿¡å€™è£œ'
}) => {
  const [selectedIndex, setSelectedIndex] = useState<number | null>(null);
  const [editingIndex, setEditingIndex] = useState<number | null>(null);
  const [editedSuggestions, setEditedSuggestions] = useState<string[]>([]);

  React.useEffect(() => {
    setEditedSuggestions(suggestions);
    setSelectedIndex(null);
    setEditingIndex(null);
  }, [suggestions]);

  const handleSelect = (index: number) => {
    const suggestion = editedSuggestions[index];
    onSelect(suggestion);
    onClose();
  };

  const handleEdit = (index: number) => {
    setEditingIndex(index);
  };

  const handleSaveEdit = (index: number, newText: string) => {
    const updated = [...editedSuggestions];
    updated[index] = newText;
    setEditedSuggestions(updated);
    setEditingIndex(null);
  };

  const handleCopy = (text: string) => {
    navigator.clipboard.writeText(text);
    // ãƒˆãƒ¼ã‚¹ãƒˆé€šçŸ¥ã‚’è¡¨ç¤ºï¼ˆå®Ÿè£…çœç•¥ï¼‰
  };

  const getApproachLabel = (index: number) => {
    const approaches = ['å…±æ„Ÿçš„', 'è«–ç†çš„', 'ãƒ¦ãƒ¼ãƒ¢ã‚¢', 'è³ªå•å½¢å¼', 'ç°¡æ½”'];
    return approaches[index] || `å€™è£œ ${index + 1}`;
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-3xl max-h-[80vh] overflow-hidden flex flex-col">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <Lightbulb className="w-5 h-5" />
            {title}
          </DialogTitle>
        </DialogHeader>

        <div className="flex-1 overflow-y-auto space-y-3 py-4">
          {isLoading ? (
            <div className="flex items-center justify-center py-8">
              <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary" />
            </div>
          ) : (
            editedSuggestions.map((suggestion, index) => (
              <Card
                key={index}
                className={cn(
                  'p-4 cursor-pointer transition-all',
                  'hover:shadow-md hover:border-primary/50',
                  selectedIndex === index && 'border-primary bg-primary/5'
                )}
                onClick={() => setSelectedIndex(index)}
              >
                <div className="space-y-2">
                  <div className="flex items-center justify-between">
                    <span className="text-sm font-medium text-primary">
                      {getApproachLabel(index)}
                    </span>
                    <div className="flex gap-1">
                      <Button
                        size="icon"
                        variant="ghost"
                        className="h-7 w-7"
                        onClick={(e) => {
                          e.stopPropagation();
                          handleCopy(suggestion);
                        }}
                      >
                        <Copy className="w-3 h-3" />
                      </Button>
                      <Button
                        size="icon"
                        variant="ghost"
                        className="h-7 w-7"
                        onClick={(e) => {
                          e.stopPropagation();
                          handleEdit(index);
                        }}
                      >
                        <Edit className="w-3 h-3" />
                      </Button>
                    </div>
                  </div>

                  {editingIndex === index ? (
                    <div className="space-y-2">
                      <textarea
                        value={editedSuggestions[index]}
                        onChange={(e) => {
                          const updated = [...editedSuggestions];
                          updated[index] = e.target.value;
                          setEditedSuggestions(updated);
                        }}
                        className="w-full p-2 border rounded-md resize-none"
                        rows={4}
                        onClick={(e) => e.stopPropagation()}
                      />
                      <div className="flex gap-2">
                        <Button
                          size="sm"
                          onClick={(e) => {
                            e.stopPropagation();
                            handleSaveEdit(index, editedSuggestions[index]);
                          }}
                        >
                          ä¿å­˜
                        </Button>
                        <Button
                          size="sm"
                          variant="ghost"
                          onClick={(e) => {
                            e.stopPropagation();
                            setEditingIndex(null);
                            setEditedSuggestions(suggestions);
                          }}
                        >
                          ã‚­ãƒ£ãƒ³ã‚»ãƒ«
                        </Button>
                      </div>
                    </div>
                  ) : (
                    <p className="text-sm whitespace-pre-wrap">{suggestion}</p>
                  )}
                </div>
              </Card>
            ))
          )}
        </div>

        <div className="flex justify-end gap-2 pt-4 border-t">
          <Button variant="ghost" onClick={onClose}>
            ã‚­ãƒ£ãƒ³ã‚»ãƒ«
          </Button>
          <Button
            onClick={() => selectedIndex !== null && handleSelect(selectedIndex)}
            disabled={selectedIndex === null}
          >
            <Check className="w-4 h-4 mr-1" />
            é¸æŠã—ãŸå€™è£œã‚’ä½¿ç”¨
          </Button>
        </div>
      </DialogContent>
    </Dialog>
  );
};
5ï¸âƒ£ ä½¿ç”¨ä¾‹ï¼ˆçµ±åˆï¼‰
typescript// src/app/chat/ChatInterface.tsx

'use client';

import React, { useState } from 'react';
import { ExpandableMessageInput } from '@/components/inspiration/ExpandableMessageInput';
import { SuggestionModal } from '@/components/inspiration/SuggestionModal';
import { InspirationService } from '@/services/inspiration/inspiration.service';
import { useChat } from '@/hooks/useChat';

export const ChatInterface: React.FC = () => {
  const [message, setMessage] = useState('');
  const [showSuggestions, setShowSuggestions] = useState(false);
  const [suggestions, setSuggestions] = useState<string[]>([]);
  const [isGenerating, setIsGenerating] = useState(false);
  
  const { messages, sendMessage } = useChat();
  const inspirationService = new InspirationService();

  // è¿”ä¿¡ææ¡ˆã®ç”Ÿæˆ
  const handleSuggestClick = async () => {
    setIsGenerating(true);
    setShowSuggestions(true);

    try {
      // ç›´è¿‘3ãƒ©ã‚¦ãƒ³ãƒ‰ï¼ˆ6ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼‰ã‚’å–å¾—
      const recentMessages = messages.slice(-6);
      
      // ã‚«ã‚¹ã‚¿ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆï¼ˆè¨­å®šã‹ã‚‰å–å¾—ï¼‰
      const customPrompt = localStorage.getItem('suggestionPrompt') || undefined;
      
      const newSuggestions = await inspirationService.generateReplySuggestions(
        recentMessages,
        customPrompt,
        3
      );
      
      setSuggestions(newSuggestions);
    } catch (error) {
      console.error('Failed to generate suggestions:', error);
      setSuggestions(['ç”³ã—è¨³ã”ã–ã„ã¾ã›ã‚“ã€‚ææ¡ˆã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚']);
    } finally {
      setIsGenerating(false);
    }
  };

  // ãƒ†ã‚­ã‚¹ãƒˆå¼·åŒ–
  const handleEnhanceClick = async () => {
    if (!message.trim()) return;

    setIsGenerating(true);
    try {
      const recentMessages = messages.slice(-6);
      const customPrompt = localStorage.getItem('enhancePrompt') || undefined;
      
      const enhanced = await inspirationService.enhanceText(
        message,
        recentMessages,
        customPrompt
      );
      
      setMessage(enhanced);
    } catch (error) {
      console.error('Failed to enhance text:', error);
    } finally {
      setIsGenerating(false);
    }
  };

  // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡
  const handleSubmit = (text: string) => {
    if (text.trim()) {
      sendMessage(text);
      setMessage('');
    }
  };

  // ææ¡ˆã®é¸æŠ
  const handleSelectSuggestion = (suggestion: string) => {
    setMessage(suggestion);
    setShowSuggestions(false);
  };

  return (
    <div className="flex flex-col h-full">
      {/* ãƒãƒ£ãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤ºã‚¨ãƒªã‚¢ */}
      <div className="flex-1 overflow-y-auto p-4">
        {/* ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒªã‚¹ãƒˆ */}
      </div>

      {/* ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å…¥åŠ›ã‚¨ãƒªã‚¢ */}
      <div className="border-t p-4">
        <ExpandableMessageInput
          value={message}
          onChange={setMessage}
          onSubmit={handleSubmit}
          onSuggestClick={handleSuggestClick}
          onEnhanceClick={handleEnhanceClick}
          isLoading={isGenerating}
          placeholder="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›..."
        />
      </div>

      {/* è¿”ä¿¡ææ¡ˆãƒ¢ãƒ¼ãƒ€ãƒ« */}
      <SuggestionModal
        isOpen={showSuggestions}
        onClose={() => setShowSuggestions(false)}
        suggestions={suggestions}
        onSelect={handleSelectSuggestion}
        isLoading={isGenerating}
      />
    </div>
  );
};

èª¬æ˜
---
ä»•æ§˜æ›¸ã¨ã‚³ãƒ¼ãƒ‰ã®ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’è¡Œã„ã€å•é¡Œç‚¹ã®ä¿®æ­£ã¨æ”¹å–„ææ¡ˆã‚’ã¾ã¨ã‚ã¾ã—ãŸã€‚

## ğŸ”§ å‹å®šç¾©ã®ä¿®æ­£ã¨æ”¹å–„

### 1ï¸âƒ£ **message.types.ts ã®ä¿®æ­£**

```typescript
// src/types/message.types.ts

// ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‹ï¼ˆå®Œå…¨ç‰ˆï¼‰
export interface Message {
  id: string;
  session_id: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  character_id?: string;
  character_name?: string;
  timestamp: string;
  edited?: boolean;
  edited_at?: string;
  regenerated?: boolean;
  voice_url?: string;
  attachments?: MessageAttachment[];
  metadata?: MessageMetadata;
  reactions?: MessageReaction[];
  memo?: string;
  is_bookmarked?: boolean;
  is_deleted?: boolean;
  parent_message_id?: string;
  branch_messages?: Message[];
  importance?: number;  // ä¼šè©±å±¥æ­´ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã¨ã®æ•´åˆæ€§ã®ãŸã‚è¿½åŠ 
  pinned?: boolean;     // ä¼šè©±å±¥æ­´ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã¨ã®æ•´åˆæ€§ã®ãŸã‚è¿½åŠ 
  embedding?: number[]; // ãƒ™ã‚¯ãƒˆãƒ«æ¤œç´¢ç”¨
}
```

### 2ï¸âƒ£ **tracker.types.ts ã®ä¿®æ­£ã¨æ‹¡å¼µ**

```typescript
// src/types/tracker.types.ts

import { z } from 'zod';

// ãƒˆãƒ©ãƒƒã‚«ãƒ¼ã‚¿ã‚¤ãƒ—ã®å®Œå…¨å®šç¾©
export type TrackerType = 'numeric' | 'state' | 'boolean' | 'text';

// ãƒ™ãƒ¼ã‚¹ãƒˆãƒ©ãƒƒã‚«ãƒ¼å‹
export interface BaseTracker {
  name: string;
  display_name: string;
  type: TrackerType;
  category: TrackerCategory;
  persistent: boolean;
  description: string;
  current_value?: TrackerValue;
  visible?: boolean;
  editable?: boolean;
}

// æ•°å€¤å‹ãƒˆãƒ©ãƒƒã‚«ãƒ¼
export interface NumericTracker extends BaseTracker {
  type: 'numeric';
  initial_value: number;
  current_value?: number;
  max_value: number;
  min_value: number;
  step?: number;
  unit?: string;
  display_format?: 'number' | 'percentage' | 'bar' | 'gauge';
}

// çŠ¶æ…‹å‹ãƒˆãƒ©ãƒƒã‚«ãƒ¼
export interface StateTracker extends BaseTracker {
  type: 'state';
  initial_state: string;
  current_value?: string;
  possible_states: string[];
  state_colors?: Record<string, string>;
  transitions?: Record<string, string[]>; // çŠ¶æ…‹é·ç§»ãƒ«ãƒ¼ãƒ«
}

// çœŸå½å€¤å‹ãƒˆãƒ©ãƒƒã‚«ãƒ¼
export interface BooleanTracker extends BaseTracker {
  type: 'boolean';
  initial_boolean: boolean;
  current_value?: boolean;
  true_label?: string;
  false_label?: string;
  true_color?: string;
  false_color?: string;
}

// ãƒ†ã‚­ã‚¹ãƒˆå‹ãƒˆãƒ©ãƒƒã‚«ãƒ¼
export interface TextTracker extends BaseTracker {
  type: 'text';
  initial_text: string;
  current_value?: string;
  max_length?: number;
  multiline?: boolean;
  placeholder?: string;
  validation_pattern?: string;
}

// çµ±åˆãƒˆãƒ©ãƒƒã‚«ãƒ¼å‹
export type Tracker = NumericTracker | StateTracker | BooleanTracker | TextTracker;

// ãƒˆãƒ©ãƒƒã‚«ãƒ¼å€¤å‹
export type TrackerValue = number | string | boolean;

// ãƒˆãƒ©ãƒƒã‚«ãƒ¼æ›´æ–°å‹
export interface TrackerUpdate {
  tracker_name: string;
  old_value: TrackerValue;
  new_value: TrackerValue;
  timestamp: string;
  trigger_message_id?: string;
  reason?: string;
  auto_update?: boolean;
}

// ãƒˆãƒ©ãƒƒã‚«ãƒ¼ã‚»ãƒƒãƒˆï¼ˆã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã”ã¨ï¼‰
export interface TrackerSet {
  character_id: string;
  trackers: Map<string, Tracker>;
  history: TrackerUpdate[];
  last_updated: string;
}
```

### 3ï¸âƒ£ **chat.types.ts ã®ä¿®æ­£**

```typescript
// src/types/chat.types.ts

import { Character } from './character.types';
import { Persona } from './persona.types';
import { Message } from './message.types';
import { TrackerSet } from './tracker.types';

// ãƒãƒ£ãƒƒãƒˆã‚»ãƒƒã‚·ãƒ§ãƒ³å‹
export interface ChatSession {
  id: string;
  character_id: string;
  persona_id: string;
  character: Character;
  persona: Persona;
  messages: Message[];
  tracker_set: TrackerSet;  // Map â†’ TrackerSetã«å¤‰æ›´
  created_at: string;
  updated_at: string;
  last_message_at: string;
  title?: string;
  summary?: string;
  is_pinned?: boolean;
  is_archived?: boolean;
  metadata?: ChatMetadata;
  conversation_manager_data?: any; // ä¼šè©±ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã®ãƒ‡ãƒ¼ã‚¿
}

// ãƒãƒ£ãƒƒãƒˆãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿
export interface ChatMetadata {
  total_messages: number;
  total_tokens_used?: number;
  last_model_used?: string;
  session_summary?: string;
  important_events?: string[];
  [key: string]: any;
}

// ã‚°ãƒ«ãƒ¼ãƒ—ãƒãƒ£ãƒƒãƒˆå‹ã®æ”¹å–„
export interface GroupChat extends Omit<ChatSession, 'character_id' | 'character'> {
  id: string;
  name: string;
  character_ids: string[];
  characters: Character[];
  active_characters: Set<string>; // ç¾åœ¨ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼
  character_tracker_sets: Map<string, TrackerSet>; // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã”ã¨ã®ãƒˆãƒ©ãƒƒã‚«ãƒ¼
  speaking_order?: string[]; // ç™ºè¨€é †åº
  group_mode: 'sequential' | 'simultaneous' | 'random'; // ã‚°ãƒ«ãƒ¼ãƒ—ãƒãƒ£ãƒƒãƒˆãƒ¢ãƒ¼ãƒ‰
  max_characters: number;
  voice_settings: Map<string, VoicePreset>; // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã”ã¨ã®éŸ³å£°è¨­å®š
}

// ãƒãƒ£ãƒƒãƒˆè¨­å®šå‹
export interface ChatSettings {
  auto_save: boolean;
  save_interval: number;
  message_limit: number;
  context_window: number;
  temperature: number;
  max_tokens: number;
  stream_response: boolean;
  show_typing_indicator: boolean;
  enable_inspiration: boolean;
  enable_voice_input: boolean;
  enable_voice_output: boolean;
  enable_group_chat: boolean;  // è¿½åŠ 
  enable_tracker_auto_update: boolean;  // è¿½åŠ 
}
```

## ğŸ¯ ãƒˆãƒ©ãƒƒã‚«ãƒ¼ã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…

### ãƒˆãƒ©ãƒƒã‚«ãƒ¼ç®¡ç†ã‚µãƒ¼ãƒ“ã‚¹

```typescript
// src/services/tracker/tracker-manager.ts

import { Tracker, TrackerUpdate, TrackerSet, TrackerValue } from '@/types/tracker.types';
import { Message } from '@/types/message.types';

export class TrackerManager {
  private trackerSets: Map<string, TrackerSet> = new Map();
  private updateCallbacks: Set<(update: TrackerUpdate) => void> = new Set();

  /**
   * ãƒˆãƒ©ãƒƒã‚«ãƒ¼ã‚»ãƒƒãƒˆã®åˆæœŸåŒ–
   */
  initializeTrackerSet(characterId: string, trackers: Tracker[]): TrackerSet {
    const trackerMap = new Map<string, Tracker>();
    
    trackers.forEach(tracker => {
      // åˆæœŸå€¤ã®è¨­å®š
      const initializedTracker = { ...tracker };
      switch (tracker.type) {
        case 'numeric':
          initializedTracker.current_value = tracker.initial_value;
          break;
        case 'state':
          initializedTracker.current_value = tracker.initial_state;
          break;
        case 'boolean':
          initializedTracker.current_value = tracker.initial_boolean;
          break;
        case 'text':
          initializedTracker.current_value = tracker.initial_text || '';
          break;
      }
      trackerMap.set(tracker.name, initializedTracker);
    });

    const trackerSet: TrackerSet = {
      character_id: characterId,
      trackers: trackerMap,
      history: [],
      last_updated: new Date().toISOString()
    };

    this.trackerSets.set(characterId, trackerSet);
    return trackerSet;
  }

  /**
   * ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å†…å®¹ã«åŸºã¥ããƒˆãƒ©ãƒƒã‚«ãƒ¼ã®è‡ªå‹•æ›´æ–°
   */
  async analyzeAndUpdateTrackers(
    characterId: string, 
    message: Message
  ): Promise<TrackerUpdate[]> {
    const trackerSet = this.trackerSets.get(characterId);
    if (!trackerSet) return [];

    const updates: TrackerUpdate[] = [];

    // AIã‚’ä½¿ç”¨ã—ã¦ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‹ã‚‰ãƒˆãƒ©ãƒƒã‚«ãƒ¼æ›´æ–°ã‚’æ¨è«–
    const analysisPrompt = this.buildTrackerAnalysisPrompt(message, trackerSet);
    
    try {
      const response = await fetch('/api/ai/analyze-trackers', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          prompt: analysisPrompt,
          message: message.content,
          trackers: Array.from(trackerSet.trackers.values())
        })
      });

      const analysis = await response.json();
      
      // åˆ†æçµæœã«åŸºã¥ã„ã¦ãƒˆãƒ©ãƒƒã‚«ãƒ¼ã‚’æ›´æ–°
      for (const suggestion of analysis.updates) {
        const update = await this.updateTracker(
          characterId,
          suggestion.tracker_name,
          suggestion.new_value,
          message.id,
          suggestion.reason
        );
        if (update) updates.push(update);
      }
    } catch (error) {
      console.error('Failed to analyze trackers:', error);
    }

    // ç‰¹å®šã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã«åŸºã¥ãè‡ªå‹•æ›´æ–°
    updates.push(...this.keywordBasedUpdate(characterId, message));

    return updates;
  }

  /**
   * ãƒˆãƒ©ãƒƒã‚«ãƒ¼ã®æ‰‹å‹•æ›´æ–°
   */
  async updateTracker(
    characterId: string,
    trackerName: string,
    newValue: TrackerValue,
    triggerId?: string,
    reason?: string
  ): Promise<TrackerUpdate | null> {
    const trackerSet = this.trackerSets.get(characterId);
    if (!trackerSet) return null;

    const tracker = trackerSet.trackers.get(trackerName);
    if (!tracker) return null;

    // å€¤ã®æ¤œè¨¼
    if (!this.validateTrackerValue(tracker, newValue)) {
      console.error(`Invalid value ${newValue} for tracker ${trackerName}`);
      return null;
    }

    const oldValue = tracker.current_value;
    tracker.current_value = newValue;

    const update: TrackerUpdate = {
      tracker_name: trackerName,
      old_value: oldValue!,
      new_value: newValue,
      timestamp: new Date().toISOString(),
      trigger_message_id: triggerId,
      reason: reason,
      auto_update: !!triggerId
    };

    trackerSet.history.push(update);
    trackerSet.last_updated = update.timestamp;

    // ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é€šçŸ¥
    this.notifyUpdate(update);

    return update;
  }

  /**
   * ãƒˆãƒ©ãƒƒã‚«ãƒ¼å€¤ã®æ¤œè¨¼
   */
  private validateTrackerValue(tracker: Tracker, value: TrackerValue): boolean {
    switch (tracker.type) {
      case 'numeric':
        const numTracker = tracker as NumericTracker;
        const numValue = value as number;
        return typeof numValue === 'number' && 
               numValue >= numTracker.min_value && 
               numValue <= numTracker.max_value;
      
      case 'state':
        const stateTracker = tracker as StateTracker;
        return stateTracker.possible_states.includes(value as string);
      
      case 'boolean':
        return typeof value === 'boolean';
      
      case 'text':
        const textTracker = tracker as TextTracker;
        const textValue = value as string;
        if (textTracker.max_length && textValue.length > textTracker.max_length) {
          return false;
        }
        if (textTracker.validation_pattern) {
          const regex = new RegExp(textTracker.validation_pattern);
          return regex.test(textValue);
        }
        return true;
      
      default:
        return false;
    }
  }

  /**
   * ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹ã®è‡ªå‹•æ›´æ–°
   */
  private keywordBasedUpdate(characterId: string, message: Message): TrackerUpdate[] {
    const updates: TrackerUpdate[] = [];
    const content = message.content.toLowerCase();

    // å¥½æ„Ÿåº¦ã®æ›´æ–°ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
    if (content.includes('å¥½ã') || content.includes('æ„›ã—ã¦')) {
      this.updateTracker(characterId, 'favorability', 
        Math.min(100, (this.getTrackerValue(characterId, 'favorability') as number || 50) + 10),
        message.id, 'å¥½æ„çš„ãªç™ºè¨€ã‚’æ¤œå‡º');
    }

    // é–¢ä¿‚æ€§ã®æ›´æ–°ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
    if (content.includes('å‹é”ã«ãªã‚ã†')) {
      this.updateTracker(characterId, 'relationship_status', 'å‹äºº', 
        message.id, 'å‹é”é–¢ä¿‚ã¸ã®ç§»è¡Œã‚’æ¤œå‡º');
    }

    return updates;
  }

  /**
   * ãƒˆãƒ©ãƒƒã‚«ãƒ¼åˆ†æãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã®æ§‹ç¯‰
   */
  private buildTrackerAnalysisPrompt(message: Message, trackerSet: TrackerSet): string {
    const trackers = Array.from(trackerSet.trackers.values());
    
    return `
ä»¥ä¸‹ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’åˆ†æã—ã€æ›´æ–°ã™ã¹ããƒˆãƒ©ãƒƒã‚«ãƒ¼ã¨ãã®æ–°ã—ã„å€¤ã‚’ææ¡ˆã—ã¦ãã ã•ã„ã€‚

ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸: "${message.content}"

ç¾åœ¨ã®ãƒˆãƒ©ãƒƒã‚«ãƒ¼:
${trackers.map(t => `- ${t.display_name} (${t.name}): ${t.current_value}`).join('\n')}

æ›´æ–°ãŒå¿…è¦ãªãƒˆãƒ©ãƒƒã‚«ãƒ¼ã‚’JSONå½¢å¼ã§è¿”ã—ã¦ãã ã•ã„:
{
  "updates": [
    {
      "tracker_name": "ãƒˆãƒ©ãƒƒã‚«ãƒ¼å",
      "new_value": "æ–°ã—ã„å€¤",
      "reason": "æ›´æ–°ç†ç”±"
    }
  ]
}
`;
  }

  /**
   * ãƒˆãƒ©ãƒƒã‚«ãƒ¼å€¤ã®å–å¾—
   */
  getTrackerValue(characterId: string, trackerName: string): TrackerValue | undefined {
    return this.trackerSets.get(characterId)?.trackers.get(trackerName)?.current_value;
  }

  /**
   * æ›´æ–°é€šçŸ¥ã®ç™»éŒ²
   */
  onUpdate(callback: (update: TrackerUpdate) => void): void {
    this.updateCallbacks.add(callback);
  }

  /**
   * æ›´æ–°é€šçŸ¥
   */
  private notifyUpdate(update: TrackerUpdate): void {
    this.updateCallbacks.forEach(callback => callback(update));
  }

  /**
   * ãƒˆãƒ©ãƒƒã‚«ãƒ¼ã‚»ãƒƒãƒˆã®å–å¾—
   */
  getTrackerSet(characterId: string): TrackerSet | undefined {
    return this.trackerSets.get(characterId);
  }

  /**
   * å…¨ãƒˆãƒ©ãƒƒã‚«ãƒ¼ã®ãƒªã‚»ãƒƒãƒˆ
   */
  resetTrackers(characterId: string): void {
    const trackerSet = this.trackerSets.get(characterId);
    if (!trackerSet) return;

    trackerSet.trackers.forEach(tracker => {
      switch (tracker.type) {
        case 'numeric':
          tracker.current_value = (tracker as NumericTracker).initial_value;
          break;
        case 'state':
          tracker.current_value = (tracker as StateTracker).initial_state;
          break;
        case 'boolean':
          tracker.current_value = (tracker as BooleanTracker).initial_boolean;
          break;
        case 'text':
          tracker.current_value = (tracker as TextTracker).initial_text;
          break;
      }
    });

    trackerSet.history = [];
    trackerSet.last_updated = new Date().toISOString();
  }
}
```

## ğŸ‘¥ ã‚°ãƒ«ãƒ¼ãƒ—ãƒãƒ£ãƒƒãƒˆã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…

```typescript
// src/services/chat/group-chat-manager.ts

import { GroupChat, Character, Message, Persona } from '@/types';
import { TrackerManager } from '@/services/tracker/tracker-manager';
import { VoicePreset } from '@/types/voice.types';

export class GroupChatManager {
  private groupChats: Map<string, GroupChat> = new Map();
  private trackerManager: TrackerManager;
  private messageQueue: Map<string, Message[]> = new Map();

  constructor(trackerManager: TrackerManager) {
    this.trackerManager = trackerManager;
  }

  /**
   * ã‚°ãƒ«ãƒ¼ãƒ—ãƒãƒ£ãƒƒãƒˆã®ä½œæˆ
   */
  createGroupChat(
    name: string,
    characterIds: string[],
    characters: Character[],
    persona: Persona,
    mode: 'sequential' | 'simultaneous' | 'random' = 'sequential'
  ): GroupChat {
    const groupChat: GroupChat = {
      id: this.generateId(),
      name,
      character_ids: characterIds,
      characters,
      active_characters: new Set(characterIds.slice(0, 3)), // æœ€å¤§3äºº
      character_tracker_sets: new Map(),
      persona_id: persona.id,
      persona,
      messages: [],
      speaking_order: [...characterIds],
      group_mode: mode,
      max_characters: 3,
      voice_settings: new Map(),
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
      last_message_at: new Date().toISOString()
    };

    // å„ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®ãƒˆãƒ©ãƒƒã‚«ãƒ¼ã‚’åˆæœŸåŒ–
    characters.forEach(character => {
      const trackerSet = this.trackerManager.initializeTrackerSet(
        character.id,
        character.trackers
      );
      groupChat.character_tracker_sets.set(character.id, trackerSet);
    });

    this.groupChats.set(groupChat.id, groupChat);
    return groupChat;
  }

  /**
   * ã‚°ãƒ«ãƒ¼ãƒ—ãƒãƒ£ãƒƒãƒˆã¸ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡
   */
  async sendMessageToGroup(
    groupChatId: string,
    userMessage: string
  ): Promise<Message[]> {
    const groupChat = this.groupChats.get(groupChatId);
    if (!groupChat) throw new Error('Group chat not found');

    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿½åŠ 
    const userMsg: Message = {
      id: this.generateId(),
      session_id: groupChatId,
      role: 'user',
      content: userMessage,
      timestamp: new Date().toISOString()
    };
    groupChat.messages.push(userMsg);

    // å„ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‹ã‚‰ã®è¿”ä¿¡ã‚’ç”Ÿæˆ
    const responses: Message[] = [];

    switch (groupChat.group_mode) {
      case 'sequential':
        responses.push(...await this.generateSequentialResponses(groupChat, userMessage));
        break;
      
      case 'simultaneous':
        responses.push(...await this.generateSimultaneousResponses(groupChat, userMessage));
        break;
      
      case 'random':
        responses.push(...await this.generateRandomResponse(groupChat, userMessage));
        break;
    }

    // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨ãƒˆãƒ©ãƒƒã‚«ãƒ¼ã®æ›´æ–°
    for (const response of responses) {
      groupChat.messages.push(response);
      
      // ãƒˆãƒ©ãƒƒã‚«ãƒ¼ã®è‡ªå‹•æ›´æ–°
      if (response.character_id) {
        await this.trackerManager.analyzeAndUpdateTrackers(
          response.character_id,
          response
        );
      }
    }

    groupChat.last_message_at = new Date().toISOString();
    groupChat.updated_at = new Date().toISOString();

    return responses;
  }

  /**
   * é †æ¬¡å¿œç­”ã®ç”Ÿæˆ
   */
  private async generateSequentialResponses(
    groupChat: GroupChat,
    userMessage: string
  ): Promise<Message[]> {
    const responses: Message[] = [];
    const activeCharacters = Array.from(groupChat.active_characters);

    for (const characterId of activeCharacters) {
      const character = groupChat.characters.find(c => c.id === characterId);
      if (!character) continue;

      const response = await this.generateCharacterResponse(
        groupChat,
        character,
        userMessage,
        responses // å‰ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®å¿œç­”ã‚‚è€ƒæ…®
      );
      
      responses.push(response);
      
      // å°‘ã—é…å»¶ã‚’å…¥ã‚Œã‚‹ï¼ˆãƒªã‚¢ãƒ«ãªä¼šè©±æ„Ÿï¼‰
      await this.delay(500);
    }

    return responses;
  }

  /**
   * åŒæ™‚å¿œç­”ã®ç”Ÿæˆ
   */
  private async generateSimultaneousResponses(
    groupChat: GroupChat,
    userMessage: string
  ): Promise<Message[]> {
    const activeCharacters = Array.from(groupChat.active_characters);
    
    const responsePromises = activeCharacters.map(characterId => {
      const character = groupChat.characters.find(c => c.id === characterId);
      if (!character) return null;
      
      return this.generateCharacterResponse(
        groupChat,
        character,
        userMessage,
        []
      );
    });

    const responses = await Promise.all(responsePromises);
    return responses.filter(r => r !== null) as Message[];
  }

  /**
   * ãƒ©ãƒ³ãƒ€ãƒ ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®å¿œç­”ç”Ÿæˆ
   */
  private async generateRandomResponse(
    groupChat: GroupChat,
    userMessage: string
  ): Promise<Message[]> {
    const activeCharacters = Array.from(groupChat.active_characters);
    const randomIndex = Math.floor(Math.random() * activeCharacters.length);
    const characterId = activeCharacters[randomIndex];
    
    const character = groupChat.characters.find(c => c.id === characterId);
    if (!character) return [];

    const response = await this.generateCharacterResponse(
      groupChat,
      character,
      userMessage,
      []
    );

    return [response];
  }

  /**
   * ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼å€‹åˆ¥ã®å¿œç­”ç”Ÿæˆ
   */
  private async generateCharacterResponse(
    groupChat: GroupChat,
    character: Character,
    userMessage: string,
    previousResponses: Message[]
  ): Promise<Message> {
    // ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã®æ§‹ç¯‰
    const prompt = this.buildGroupChatPrompt(
      groupChat,
      character,
      userMessage,
      previousResponses
    );

    try {
      const response = await fetch('/api/ai/generate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          prompt,
          character,
          persona: groupChat.persona,
          temperature: 0.8,
          max_tokens: 200
        })
      });

      const data = await response.json();

      return {
        id: this.generateId(),
        session_id: groupChat.id,
        role: 'assistant',
        content: data.content,
        character_id: character.id,
        character_name: character.name,
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      console.error(`Failed to generate response for ${character.name}:`, error);
      
      return {
        id: this.generateId(),
        session_id: groupChat.id,
        role: 'assistant',
        content: '...',
        character_id: character.id,
        character_name: character.name,
        timestamp: new Date().toISOString()
      };
    }
  }

  /**
   * ã‚°ãƒ«ãƒ¼ãƒ—ãƒãƒ£ãƒƒãƒˆç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã®æ§‹ç¯‰
   */
  private buildGroupChatPrompt(
    groupChat: GroupChat,
    character: Character,
    userMessage: string,
    previousResponses: Message[]
  ): string {
    const otherCharacters = groupChat.characters
      .filter(c => c.id !== character.id && groupChat.active_characters.has(c.id))
      .map(c => c.name)
      .join('ã€');

    const trackerSet = groupChat.character_tracker_sets.get(character.id);
    const trackerInfo = trackerSet ? 
      Array.from(trackerSet.trackers.values())
        .map(t => `${t.display_name}: ${t.current_value}`)
        .join('\n') : '';

    let prompt = `
ã‚ãªãŸã¯${character.name}ã¨ã—ã¦ã€ã‚°ãƒ«ãƒ¼ãƒ—ãƒãƒ£ãƒƒãƒˆã«å‚åŠ ã—ã¦ã„ã¾ã™ã€‚
ä»–ã®å‚åŠ è€…: ${otherCharacters}
ãƒ¦ãƒ¼ã‚¶ãƒ¼: ${groupChat.persona.name}

${character.system_prompt}

ç¾åœ¨ã®çŠ¶æ…‹:
${trackerInfo}

ä¼šè©±ã®æ–‡è„ˆ:
${groupChat.messages.slice(-6).map(m => {
  const speaker = m.role === 'user' ? groupChat.persona.name : 
                  m.character_name || 'ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ';
  return `${speaker}: ${m.content}`;
}).join('\n')}
`;

    // ä»–ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®å¿œç­”ãŒã‚ã‚‹å ´åˆ
    if (previousResponses.length > 0) {
      prompt += `\n\nç›´å‰ã®ä»–ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®å¿œç­”:\n`;
      previousResponses.forEach(r => {
        prompt += `${r.character_name}: ${r.content}\n`;
      });
      prompt += `\nã“ã‚Œã‚‰ã®å¿œç­”ã‚‚è€ƒæ…®ã—ã¦ã€${character.name}ã¨ã—ã¦è‡ªç„¶ã«å¿œç­”ã—ã¦ãã ã•ã„ã€‚`;
    }

    prompt += `\n\n${groupChat.persona.name}: ${userMessage}\n${character.name}: `;

    return prompt;
  }

  /**
   * ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®åˆ‡ã‚Šæ›¿ãˆ
   */
  toggleActiveCharacter(groupChatId: string, characterId: string): void {
    const groupChat = this.groupChats.get(groupChatId);
    if (!groupChat) return;

    if (groupChat.active_characters.has(characterId)) {
      groupChat.active_characters.delete(characterId);
    } else if (groupChat.active_characters.size < groupChat.max_characters) {
      groupChat.active_characters.add(characterId);
    }
  }

  /**
   * éŸ³å£°è¨­å®šã®è¨­å®š
   */
  setVoicePreset(
    groupChatId: string,
    characterId: string,
    voicePreset: VoicePreset
  ): void {
    const groupChat = this.groupChats.get(groupChatId);
    if (!groupChat) return;

    groupChat.voice_settings.set(characterId, voicePreset);
  }

  /**
   * ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
   */
  private generateId(): string {
    return `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * ã‚°ãƒ«ãƒ¼ãƒ—ãƒãƒ£ãƒƒãƒˆã®å–å¾—
   */
  getGroupChat(id: string): GroupChat | undefined {
    return this.groupChats.get(id);
  }

  /**
   * å…¨ã‚°ãƒ«ãƒ¼ãƒ—ãƒãƒ£ãƒƒãƒˆã®å–å¾—
   */
  getAllGroupChats(): GroupChat[] {
    return Array.from(this.groupChats.values());
  }
}
```

## ğŸ“ çµ±åˆä½¿ç”¨ä¾‹

```typescript
// src/app/chat/page.tsx

'use client';

import React, { useState, useEffect } from 'react';
import { ConversationManager } from '@/services/memory/conversation-manager';
import { TrackerManager } from '@/services/tracker/tracker-manager';
import { GroupChatManager } from '@/services/chat/group-chat-manager';
import { useCharacterStore } from '@/store/character.store';
import { usePersonaStore } from '@/store/persona.store';

export default function ChatPage() {
  const [conversationManager] = useState(() => new ConversationManager());
  const [trackerManager] = useState(() => new TrackerManager());
  const [groupChatManager] = useState(() => new GroupChatManager(trackerManager));
  
  const { characters, selectedCharacters } = useCharacterStore();
  const { currentPersona } = usePersonaStore();
  
  const [isGroupMode, setIsGroupMode] = useState(false);
  const [groupChat, setGroupChat] = useState(null);

  // ã‚°ãƒ«ãƒ¼ãƒ—ãƒãƒ£ãƒƒãƒˆã®åˆæœŸåŒ–
  const initGroupChat = () => {
    if (selectedCharacters.length > 1 && currentPersona) {
      const chat = groupChatManager.createGroupChat(
        'ã‚°ãƒ«ãƒ¼ãƒ—ãƒãƒ£ãƒƒãƒˆ',
        selectedCharacters.map(c => c.id),
        selectedCharacters,
        currentPersona,
        'sequential'
      );
      setGroupChat(chat);
      setIsGroupMode(true);
    }
  };

  // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡
  const sendMessage = async (content: string) => {
    if (isGroupMode && groupChat) {
      // ã‚°ãƒ«ãƒ¼ãƒ—ãƒãƒ£ãƒƒãƒˆãƒ¢ãƒ¼ãƒ‰
      const responses = await groupChatManager.sendMessageToGroup(
        groupChat.id,
        content
      );
      
      // å„å¿œç­”ã‚’ä¼šè©±ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã«è¨˜éŒ²
      for (const response of responses) {
        await conversationManager.addMessage(
          'assistant',
          response.content,
          {
            character_id: response.character_id,
            character_name: response.character_name
          }
        );
      }
    } else {
      // é€šå¸¸ã®ãƒãƒ£ãƒƒãƒˆ
      await conversationManager.addMessage('user', content);
      
      // AIã‹ã‚‰ã®å¿œç­”ã‚’ç”Ÿæˆ
      const prompt = await conversationManager.generatePrompt(
        content,
        selectedCharacters[0],
        currentPersona
      );
      
      // ... AIå¿œç­”å‡¦ç†
    }
  };

  // ãƒˆãƒ©ãƒƒã‚«ãƒ¼æ›´æ–°ã®ç›£è¦–
  useEffect(() => {
    trackerManager.onUpdate((update) => {
      console.log('Tracker updated:', update);
      // UIã‚’æ›´æ–°
    });
  }, [trackerManager]);

  return (
    <div className="flex h-screen">
      {/* ãƒãƒ£ãƒƒãƒˆã‚¨ãƒªã‚¢ */}
      <div className="flex-1">
        {/* ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒªã‚¹ãƒˆ */}
        {/* ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å…¥åŠ› */}
      </div>
      
      {/* ãƒˆãƒ©ãƒƒã‚«ãƒ¼ãƒ‘ãƒãƒ« */}
      <div className="w-80 border-l">
        {/* ãƒˆãƒ©ãƒƒã‚«ãƒ¼è¡¨ç¤º */}
      </div>
    </div>
  );
}
`