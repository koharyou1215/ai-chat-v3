ä»•æ§˜æ›¸ã¨ã‚³ãƒ¼ãƒ‰ã®ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’è¡Œã„ã€å•é¡Œç‚¹ã®ä¿®æ­£ã¨æ”¹å–„ææ¡ˆã‚’ã¾ã¨ã‚ã¾ã—ãŸã€‚

## ğŸ”§ å‹å®šç¾©ã®ä¿®æ­£ã¨æ”¹å–„

### 1ï¸âƒ£ **message.types.ts ã®ä¿®æ­£**

```typescript
// src/types/message.types.ts

// ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‹ï¼ˆå®Œå…¨ç‰ˆï¼‰
export interface Message {
  id: string;
  session_id: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  character_id?: string;
  character_name?: string;
  timestamp: string;
  edited?: boolean;
  edited_at?: string;
  regenerated?: boolean;
  voice_url?: string;
  attachments?: MessageAttachment[];
  metadata?: MessageMetadata;
  reactions?: MessageReaction[];
  memo?: string;
  is_bookmarked?: boolean;
  is_deleted?: boolean;
  parent_message_id?: string;
  branch_messages?: Message[];
  importance?: number;  // ä¼šè©±å±¥æ­´ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã¨ã®æ•´åˆæ€§ã®ãŸã‚è¿½åŠ 
  pinned?: boolean;     // ä¼šè©±å±¥æ­´ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã¨ã®æ•´åˆæ€§ã®ãŸã‚è¿½åŠ 
  embedding?: number[]; // ãƒ™ã‚¯ãƒˆãƒ«æ¤œç´¢ç”¨
}
```

### 2ï¸âƒ£ **tracker.types.ts ã®ä¿®æ­£ã¨æ‹¡å¼µ**

```typescript
// src/types/tracker.types.ts

import { z } from 'zod';

// ãƒˆãƒ©ãƒƒã‚«ãƒ¼ã‚¿ã‚¤ãƒ—ã®å®Œå…¨å®šç¾©
export type TrackerType = 'numeric' | 'state' | 'boolean' | 'text';

// ãƒ™ãƒ¼ã‚¹ãƒˆãƒ©ãƒƒã‚«ãƒ¼å‹
export interface BaseTracker {
  name: string;
  display_name: string;
  type: TrackerType;
  category: TrackerCategory;
  persistent: boolean;
  description: string;
  current_value?: TrackerValue;
  visible?: boolean;
  editable?: boolean;
}

// æ•°å€¤å‹ãƒˆãƒ©ãƒƒã‚«ãƒ¼
export interface NumericTracker extends BaseTracker {
  type: 'numeric';
  initial_value: number;
  current_value?: number;
  max_value: number;
  min_value: number;
  step?: number;
  unit?: string;
  display_format?: 'number' | 'percentage' | 'bar' | 'gauge';
}

// çŠ¶æ…‹å‹ãƒˆãƒ©ãƒƒã‚«ãƒ¼
export interface StateTracker extends BaseTracker {
  type: 'state';
  initial_state: string;
  current_value?: string;
  possible_states: string[];
  state_colors?: Record<string, string>;
  transitions?: Record<string, string[]>; // çŠ¶æ…‹é·ç§»ãƒ«ãƒ¼ãƒ«
}

// çœŸå½å€¤å‹ãƒˆãƒ©ãƒƒã‚«ãƒ¼
export interface BooleanTracker extends BaseTracker {
  type: 'boolean';
  initial_boolean: boolean;
  current_value?: boolean;
  true_label?: string;
  false_label?: string;
  true_color?: string;
  false_color?: string;
}

// ãƒ†ã‚­ã‚¹ãƒˆå‹ãƒˆãƒ©ãƒƒã‚«ãƒ¼
export interface TextTracker extends BaseTracker {
  type: 'text';
  initial_text: string;
  current_value?: string;
  max_length?: number;
  multiline?: boolean;
  placeholder?: string;
  validation_pattern?: string;
}

// çµ±åˆãƒˆãƒ©ãƒƒã‚«ãƒ¼å‹
export type Tracker = NumericTracker | StateTracker | BooleanTracker | TextTracker;

// ãƒˆãƒ©ãƒƒã‚«ãƒ¼å€¤å‹
export type TrackerValue = number | string | boolean;

// ãƒˆãƒ©ãƒƒã‚«ãƒ¼æ›´æ–°å‹
export interface TrackerUpdate {
  tracker_name: string;
  old_value: TrackerValue;
  new_value: TrackerValue;
  timestamp: string;
  trigger_message_id?: string;
  reason?: string;
  auto_update?: boolean;
}

// ãƒˆãƒ©ãƒƒã‚«ãƒ¼ã‚»ãƒƒãƒˆï¼ˆã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã”ã¨ï¼‰
export interface TrackerSet {
  character_id: string;
  trackers: Map<string, Tracker>;
  history: TrackerUpdate[];
  last_updated: string;
}
```

### 3ï¸âƒ£ **chat.types.ts ã®ä¿®æ­£**

```typescript
// src/types/chat.types.ts

import { Character } from './character.types';
import { Persona } from './persona.types';
import { Message } from './message.types';
import { TrackerSet } from './tracker.types';

// ãƒãƒ£ãƒƒãƒˆã‚»ãƒƒã‚·ãƒ§ãƒ³å‹
export interface ChatSession {
  id: string;
  character_id: string;
  persona_id: string;
  character: Character;
  persona: Persona;
  messages: Message[];
  tracker_set: TrackerSet;  // Map â†’ TrackerSetã«å¤‰æ›´
  created_at: string;
  updated_at: string;
  last_message_at: string;
  title?: string;
  summary?: string;
  is_pinned?: boolean;
  is_archived?: boolean;
  metadata?: ChatMetadata;
  conversation_manager_data?: any; // ä¼šè©±ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã®ãƒ‡ãƒ¼ã‚¿
}

// ãƒãƒ£ãƒƒãƒˆãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿
export interface ChatMetadata {
  total_messages: number;
  total_tokens_used?: number;
  last_model_used?: string;
  session_summary?: string;
  important_events?: string[];
  [key: string]: any;
}

// ã‚°ãƒ«ãƒ¼ãƒ—ãƒãƒ£ãƒƒãƒˆå‹ã®æ”¹å–„
export interface GroupChat extends Omit<ChatSession, 'character_id' | 'character'> {
  id: string;
  name: string;
  character_ids: string[];
  characters: Character[];
  active_characters: Set<string>; // ç¾åœ¨ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼
  character_tracker_sets: Map<string, TrackerSet>; // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã”ã¨ã®ãƒˆãƒ©ãƒƒã‚«ãƒ¼
  speaking_order?: string[]; // ç™ºè¨€é †åº
  group_mode: 'sequential' | 'simultaneous' | 'random'; // ã‚°ãƒ«ãƒ¼ãƒ—ãƒãƒ£ãƒƒãƒˆãƒ¢ãƒ¼ãƒ‰
  max_characters: number;
  voice_settings: Map<string, VoicePreset>; // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã”ã¨ã®éŸ³å£°è¨­å®š
}

// ãƒãƒ£ãƒƒãƒˆè¨­å®šå‹
export interface ChatSettings {
  auto_save: boolean;
  save_interval: number;
  message_limit: number;
  context_window: number;
  temperature: number;
  max_tokens: number;
  stream_response: boolean;
  show_typing_indicator: boolean;
  enable_inspiration: boolean;
  enable_voice_input: boolean;
  enable_voice_output: boolean;
  enable_group_chat: boolean;  // è¿½åŠ 
  enable_tracker_auto_update: boolean;  // è¿½åŠ 
}
```

## ğŸ¯ ãƒˆãƒ©ãƒƒã‚«ãƒ¼ã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…

### ãƒˆãƒ©ãƒƒã‚«ãƒ¼ç®¡ç†ã‚µãƒ¼ãƒ“ã‚¹

```typescript
// src/services/tracker/tracker-manager.ts

import { Tracker, TrackerUpdate, TrackerSet, TrackerValue } from '@/types/tracker.types';
import { Message } from '@/types/message.types';

export class TrackerManager {
  private trackerSets: Map<string, TrackerSet> = new Map();
  private updateCallbacks: Set<(update: TrackerUpdate) => void> = new Set();

  /**
   * ãƒˆãƒ©ãƒƒã‚«ãƒ¼ã‚»ãƒƒãƒˆã®åˆæœŸåŒ–
   */
  initializeTrackerSet(characterId: string, trackers: Tracker[]): TrackerSet {
    const trackerMap = new Map<string, Tracker>();
    
    trackers.forEach(tracker => {
      // åˆæœŸå€¤ã®è¨­å®š
      const initializedTracker = { ...tracker };
      switch (tracker.type) {
        case 'numeric':
          initializedTracker.current_value = tracker.initial_value;
          break;
        case 'state':
          initializedTracker.current_value = tracker.initial_state;
          break;
        case 'boolean':
          initializedTracker.current_value = tracker.initial_boolean;
          break;
        case 'text':
          initializedTracker.current_value = tracker.initial_text || '';
          break;
      }
      trackerMap.set(tracker.name, initializedTracker);
    });

    const trackerSet: TrackerSet = {
      character_id: characterId,
      trackers: trackerMap,
      history: [],
      last_updated: new Date().toISOString()
    };

    this.trackerSets.set(characterId, trackerSet);
    return trackerSet;
  }

  /**
   * ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å†…å®¹ã«åŸºã¥ããƒˆãƒ©ãƒƒã‚«ãƒ¼ã®è‡ªå‹•æ›´æ–°
   */
  async analyzeAndUpdateTrackers(
    characterId: string, 
    message: Message
  ): Promise<TrackerUpdate[]> {
    const trackerSet = this.trackerSets.get(characterId);
    if (!trackerSet) return [];

    const updates: TrackerUpdate[] = [];

    // AIã‚’ä½¿ç”¨ã—ã¦ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‹ã‚‰ãƒˆãƒ©ãƒƒã‚«ãƒ¼æ›´æ–°ã‚’æ¨è«–
    const analysisPrompt = this.buildTrackerAnalysisPrompt(message, trackerSet);
    
    try {
      const response = await fetch('/api/ai/analyze-trackers', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          prompt: analysisPrompt,
          message: message.content,
          trackers: Array.from(trackerSet.trackers.values())
        })
      });

      const analysis = await response.json();
      
      // åˆ†æçµæœã«åŸºã¥ã„ã¦ãƒˆãƒ©ãƒƒã‚«ãƒ¼ã‚’æ›´æ–°
      for (const suggestion of analysis.updates) {
        const update = await this.updateTracker(
          characterId,
          suggestion.tracker_name,
          suggestion.new_value,
          message.id,
          suggestion.reason
        );
        if (update) updates.push(update);
      }
    } catch (error) {
      console.error('Failed to analyze trackers:', error);
    }

    // ç‰¹å®šã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã«åŸºã¥ãè‡ªå‹•æ›´æ–°
    updates.push(...this.keywordBasedUpdate(characterId, message));

    return updates;
  }

  /**
   * ãƒˆãƒ©ãƒƒã‚«ãƒ¼ã®æ‰‹å‹•æ›´æ–°
   */
  async updateTracker(
    characterId: string,
    trackerName: string,
    newValue: TrackerValue,
    triggerId?: string,
    reason?: string
  ): Promise<TrackerUpdate | null> {
    const trackerSet = this.trackerSets.get(characterId);
    if (!trackerSet) return null;

    const tracker = trackerSet.trackers.get(trackerName);
    if (!tracker) return null;

    // å€¤ã®æ¤œè¨¼
    if (!this.validateTrackerValue(tracker, newValue)) {
      console.error(`Invalid value ${newValue} for tracker ${trackerName}`);
      return null;
    }

    const oldValue = tracker.current_value;
    tracker.current_value = newValue;

    const update: TrackerUpdate = {
      tracker_name: trackerName,
      old_value: oldValue!,
      new_value: newValue,
      timestamp: new Date().toISOString(),
      trigger_message_id: triggerId,
      reason: reason,
      auto_update: !!triggerId
    };

    trackerSet.history.push(update);
    trackerSet.last_updated = update.timestamp;

    // ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é€šçŸ¥
    this.notifyUpdate(update);

    return update;
  }

  /**
   * ãƒˆãƒ©ãƒƒã‚«ãƒ¼å€¤ã®æ¤œè¨¼
   */
  private validateTrackerValue(tracker: Tracker, value: TrackerValue): boolean {
    switch (tracker.type) {
      case 'numeric':
        const numTracker = tracker as NumericTracker;
        const numValue = value as number;
        return typeof numValue === 'number' && 
               numValue >= numTracker.min_value && 
               numValue <= numTracker.max_value;
      
      case 'state':
        const stateTracker = tracker as StateTracker;
        return stateTracker.possible_states.includes(value as string);
      
      case 'boolean':
        return typeof value === 'boolean';
      
      case 'text':
        const textTracker = tracker as TextTracker;
        const textValue = value as string;
        if (textTracker.max_length && textValue.length > textTracker.max_length) {
          return false;
        }
        if (textTracker.validation_pattern) {
          const regex = new RegExp(textTracker.validation_pattern);
          return regex.test(textValue);
        }
        return true;
      
      default:
        return false;
    }
  }

  /**
   * ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹ã®è‡ªå‹•æ›´æ–°
   */
  private keywordBasedUpdate(characterId: string, message: Message): TrackerUpdate[] {
    const updates: TrackerUpdate[] = [];
    const content = message.content.toLowerCase();

    // å¥½æ„Ÿåº¦ã®æ›´æ–°ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
    if (content.includes('å¥½ã') || content.includes('æ„›ã—ã¦')) {
      this.updateTracker(characterId, 'favorability', 
        Math.min(100, (this.getTrackerValue(characterId, 'favorability') as number || 50) + 10),
        message.id, 'å¥½æ„çš„ãªç™ºè¨€ã‚’æ¤œå‡º');
    }

    // é–¢ä¿‚æ€§ã®æ›´æ–°ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
    if (content.includes('å‹é”ã«ãªã‚ã†')) {
      this.updateTracker(characterId, 'relationship_status', 'å‹äºº', 
        message.id, 'å‹é”é–¢ä¿‚ã¸ã®ç§»è¡Œã‚’æ¤œå‡º');
    }

    return updates;
  }

  /**
   * ãƒˆãƒ©ãƒƒã‚«ãƒ¼åˆ†æãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã®æ§‹ç¯‰
   */
  private buildTrackerAnalysisPrompt(message: Message, trackerSet: TrackerSet): string {
    const trackers = Array.from(trackerSet.trackers.values());
    
    return `
ä»¥ä¸‹ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’åˆ†æã—ã€æ›´æ–°ã™ã¹ããƒˆãƒ©ãƒƒã‚«ãƒ¼ã¨ãã®æ–°ã—ã„å€¤ã‚’ææ¡ˆã—ã¦ãã ã•ã„ã€‚

ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸: "${message.content}"

ç¾åœ¨ã®ãƒˆãƒ©ãƒƒã‚«ãƒ¼:
${trackers.map(t => `- ${t.display_name} (${t.name}): ${t.current_value}`).join('\n')}

æ›´æ–°ãŒå¿…è¦ãªãƒˆãƒ©ãƒƒã‚«ãƒ¼ã‚’JSONå½¢å¼ã§è¿”ã—ã¦ãã ã•ã„:
{
  "updates": [
    {
      "tracker_name": "ãƒˆãƒ©ãƒƒã‚«ãƒ¼å",
      "new_value": "æ–°ã—ã„å€¤",
      "reason": "æ›´æ–°ç†ç”±"
    }
  ]
}
`;
  }

  /**
   * ãƒˆãƒ©ãƒƒã‚«ãƒ¼å€¤ã®å–å¾—
   */
  getTrackerValue(characterId: string, trackerName: string): TrackerValue | undefined {
    return this.trackerSets.get(characterId)?.trackers.get(trackerName)?.current_value;
  }

  /**
   * æ›´æ–°é€šçŸ¥ã®ç™»éŒ²
   */
  onUpdate(callback: (update: TrackerUpdate) => void): void {
    this.updateCallbacks.add(callback);
  }

  /**
   * æ›´æ–°é€šçŸ¥
   */
  private notifyUpdate(update: TrackerUpdate): void {
    this.updateCallbacks.forEach(callback => callback(update));
  }

  /**
   * ãƒˆãƒ©ãƒƒã‚«ãƒ¼ã‚»ãƒƒãƒˆã®å–å¾—
   */
  getTrackerSet(characterId: string): TrackerSet | undefined {
    return this.trackerSets.get(characterId);
  }

  /**
   * å…¨ãƒˆãƒ©ãƒƒã‚«ãƒ¼ã®ãƒªã‚»ãƒƒãƒˆ
   */
  resetTrackers(characterId: string): void {
    const trackerSet = this.trackerSets.get(characterId);
    if (!trackerSet) return;

    trackerSet.trackers.forEach(tracker => {
      switch (tracker.type) {
        case 'numeric':
          tracker.current_value = (tracker as NumericTracker).initial_value;
          break;
        case 'state':
          tracker.current_value = (tracker as StateTracker).initial_state;
          break;
        case 'boolean':
          tracker.current_value = (tracker as BooleanTracker).initial_boolean;
          break;
        case 'text':
          tracker.current_value = (tracker as TextTracker).initial_text;
          break;
      }
    });

    trackerSet.history = [];
    trackerSet.last_updated = new Date().toISOString();
  }
}
```

## ğŸ‘¥ ã‚°ãƒ«ãƒ¼ãƒ—ãƒãƒ£ãƒƒãƒˆã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…

```typescript
// src/services/chat/group-chat-manager.ts

import { GroupChat, Character, Message, Persona } from '@/types';
import { TrackerManager } from '@/services/tracker/tracker-manager';
import { VoicePreset } from '@/types/voice.types';

export class GroupChatManager {
  private groupChats: Map<string, GroupChat> = new Map();
  private trackerManager: TrackerManager;
  private messageQueue: Map<string, Message[]> = new Map();

  constructor(trackerManager: TrackerManager) {
    this.trackerManager = trackerManager;
  }

  /**
   * ã‚°ãƒ«ãƒ¼ãƒ—ãƒãƒ£ãƒƒãƒˆã®ä½œæˆ
   */
  createGroupChat(
    name: string,
    characterIds: string[],
    characters: Character[],
    persona: Persona,
    mode: 'sequential' | 'simultaneous' | 'random' = 'sequential'
  ): GroupChat {
    const groupChat: GroupChat = {
      id: this.generateId(),
      name,
      character_ids: characterIds,
      characters,
      active_characters: new Set(characterIds.slice(0, 3)), // æœ€å¤§3äºº
      character_tracker_sets: new Map(),
      persona_id: persona.id,
      persona,
      messages: [],
      speaking_order: [...characterIds],
      group_mode: mode,
      max_characters: 3,
      voice_settings: new Map(),
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
      last_message_at: new Date().toISOString()
    };

    // å„ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®ãƒˆãƒ©ãƒƒã‚«ãƒ¼ã‚’åˆæœŸåŒ–
    characters.forEach(character => {
      const trackerSet = this.trackerManager.initializeTrackerSet(
        character.id,
        character.trackers
      );
      groupChat.character_tracker_sets.set(character.id, trackerSet);
    });

    this.groupChats.set(groupChat.id, groupChat);
    return groupChat;
  }

  /**
   * ã‚°ãƒ«ãƒ¼ãƒ—ãƒãƒ£ãƒƒãƒˆã¸ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡
   */
  async sendMessageToGroup(
    groupChatId: string,
    userMessage: string
  ): Promise<Message[]> {
    const groupChat = this.groupChats.get(groupChatId);
    if (!groupChat) throw new Error('Group chat not found');

    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿½åŠ 
    const userMsg: Message = {
      id: this.generateId(),
      session_id: groupChatId,
      role: 'user',
      content: userMessage,
      timestamp: new Date().toISOString()
    };
    groupChat.messages.push(userMsg);

    // å„ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‹ã‚‰ã®è¿”ä¿¡ã‚’ç”Ÿæˆ
    const responses: Message[] = [];

    switch (groupChat.group_mode) {
      case 'sequential':
        responses.push(...await this.generateSequentialResponses(groupChat, userMessage));
        break;
      
      case 'simultaneous':
        responses.push(...await this.generateSimultaneousResponses(groupChat, userMessage));
        break;
      
      case 'random':
        responses.push(...await this.generateRandomResponse(groupChat, userMessage));
        break;
    }

    // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨ãƒˆãƒ©ãƒƒã‚«ãƒ¼ã®æ›´æ–°
    for (const response of responses) {
      groupChat.messages.push(response);
      
      // ãƒˆãƒ©ãƒƒã‚«ãƒ¼ã®è‡ªå‹•æ›´æ–°
      if (response.character_id) {
        await this.trackerManager.analyzeAndUpdateTrackers(
          response.character_id,
          response
        );
      }
    }

    groupChat.last_message_at = new Date().toISOString();
    groupChat.updated_at = new Date().toISOString();

    return responses;
  }

  /**
   * é †æ¬¡å¿œç­”ã®ç”Ÿæˆ
   */
  private async generateSequentialResponses(
    groupChat: GroupChat,
    userMessage: string
  ): Promise<Message[]> {
    const responses: Message[] = [];
    const activeCharacters = Array.from(groupChat.active_characters);

    for (const characterId of activeCharacters) {
      const character = groupChat.characters.find(c => c.id === characterId);
      if (!character) continue;

      const response = await this.generateCharacterResponse(
        groupChat,
        character,
        userMessage,
        responses // å‰ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®å¿œç­”ã‚‚è€ƒæ…®
      );
      
      responses.push(response);
      
      // å°‘ã—é…å»¶ã‚’å…¥ã‚Œã‚‹ï¼ˆãƒªã‚¢ãƒ«ãªä¼šè©±æ„Ÿï¼‰
      await this.delay(500);
    }

    return responses;
  }

  /**
   * åŒæ™‚å¿œç­”ã®ç”Ÿæˆ
   */
  private async generateSimultaneousResponses(
    groupChat: GroupChat,
    userMessage: string
  ): Promise<Message[]> {
    const activeCharacters = Array.from(groupChat.active_characters);
    
    const responsePromises = activeCharacters.map(characterId => {
      const character = groupChat.characters.find(c => c.id === characterId);
      if (!character) return null;
      
      return this.generateCharacterResponse(
        groupChat,
        character,
        userMessage,
        []
      );
    });

    const responses = await Promise.all(responsePromises);
    return responses.filter(r => r !== null) as Message[];
  }

  /**
   * ãƒ©ãƒ³ãƒ€ãƒ ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®å¿œç­”ç”Ÿæˆ
   */
  private async generateRandomResponse(
    groupChat: GroupChat,
    userMessage: string
  ): Promise<Message[]> {
    const activeCharacters = Array.from(groupChat.active_characters);
    const randomIndex = Math.floor(Math.random() * activeCharacters.length);
    const characterId = activeCharacters[randomIndex];
    
    const character = groupChat.characters.find(c => c.id === characterId);
    if (!character) return [];

    const response = await this.generateCharacterResponse(
      groupChat,
      character,
      userMessage,
      []
    );

    return [response];
  }

  /**
   * ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼å€‹åˆ¥ã®å¿œç­”ç”Ÿæˆ
   */
  private async generateCharacterResponse(
    groupChat: GroupChat,
    character: Character,
    userMessage: string,
    previousResponses: Message[]
  ): Promise<Message> {
    // ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã®æ§‹ç¯‰
    const prompt = this.buildGroupChatPrompt(
      groupChat,
      character,
      userMessage,
      previousResponses
    );

    try {
      const response = await fetch('/api/ai/generate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          prompt,
          character,
          persona: groupChat.persona,
          temperature: 0.8,
          max_tokens: 200
        })
      });

      const data = await response.json();

      return {
        id: this.generateId(),
        session_id: groupChat.id,
        role: 'assistant',
        content: data.content,
        character_id: character.id,
        character_name: character.name,
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      console.error(`Failed to generate response for ${character.name}:`, error);
      
      return {
        id: this.generateId(),
        session_id: groupChat.id,
        role: 'assistant',
        content: '...',
        character_id: character.id,
        character_name: character.name,
        timestamp: new Date().toISOString()
      };
    }
  }

  /**
   * ã‚°ãƒ«ãƒ¼ãƒ—ãƒãƒ£ãƒƒãƒˆç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã®æ§‹ç¯‰
   */
  private buildGroupChatPrompt(
    groupChat: GroupChat,
    character: Character,
    userMessage: string,
    previousResponses: Message[]
  ): string {
    const otherCharacters = groupChat.characters
      .filter(c => c.id !== character.id && groupChat.active_characters.has(c.id))
      .map(c => c.name)
      .join('ã€');

    const trackerSet = groupChat.character_tracker_sets.get(character.id);
    const trackerInfo = trackerSet ? 
      Array.from(trackerSet.trackers.values())
        .map(t => `${t.display_name}: ${t.current_value}`)
        .join('\n') : '';

    let prompt = `
ã‚ãªãŸã¯${character.name}ã¨ã—ã¦ã€ã‚°ãƒ«ãƒ¼ãƒ—ãƒãƒ£ãƒƒãƒˆã«å‚åŠ ã—ã¦ã„ã¾ã™ã€‚
ä»–ã®å‚åŠ è€…: ${otherCharacters}
ãƒ¦ãƒ¼ã‚¶ãƒ¼: ${groupChat.persona.name}

${character.system_prompt}

ç¾åœ¨ã®çŠ¶æ…‹:
${trackerInfo}

ä¼šè©±ã®æ–‡è„ˆ:
${groupChat.messages.slice(-6).map(m => {
  const speaker = m.role === 'user' ? groupChat.persona.name : 
                  m.character_name || 'ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ';
  return `${speaker}: ${m.content}`;
}).join('\n')}
`;

    // ä»–ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®å¿œç­”ãŒã‚ã‚‹å ´åˆ
    if (previousResponses.length > 0) {
      prompt += `\n\nç›´å‰ã®ä»–ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®å¿œç­”:\n`;
      previousResponses.forEach(r => {
        prompt += `${r.character_name}: ${r.content}\n`;
      });
      prompt += `\nã“ã‚Œã‚‰ã®å¿œç­”ã‚‚è€ƒæ…®ã—ã¦ã€${character.name}ã¨ã—ã¦è‡ªç„¶ã«å¿œç­”ã—ã¦ãã ã•ã„ã€‚`;
    }

    prompt += `\n\n${groupChat.persona.name}: ${userMessage}\n${character.name}: `;

    return prompt;
  }

  /**
   * ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®åˆ‡ã‚Šæ›¿ãˆ
   */
  toggleActiveCharacter(groupChatId: string, characterId: string): void {
    const groupChat = this.groupChats.get(groupChatId);
    if (!groupChat) return;

    if (groupChat.active_characters.has(characterId)) {
      groupChat.active_characters.delete(characterId);
    } else if (groupChat.active_characters.size < groupChat.max_characters) {
      groupChat.active_characters.add(characterId);
    }
  }

  /**
   * éŸ³å£°è¨­å®šã®è¨­å®š
   */
  setVoicePreset(
    groupChatId: string,
    characterId: string,
    voicePreset: VoicePreset
  ): void {
    const groupChat = this.groupChats.get(groupChatId);
    if (!groupChat) return;

    groupChat.voice_settings.set(characterId, voicePreset);
  }

  /**
   * ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
   */
  private generateId(): string {
    return `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * ã‚°ãƒ«ãƒ¼ãƒ—ãƒãƒ£ãƒƒãƒˆã®å–å¾—
   */
  getGroupChat(id: string): GroupChat | undefined {
    return this.groupChats.get(id);
  }

  /**
   * å…¨ã‚°ãƒ«ãƒ¼ãƒ—ãƒãƒ£ãƒƒãƒˆã®å–å¾—
   */
  getAllGroupChats(): GroupChat[] {
    return Array.from(this.groupChats.values());
  }
}
```

## ğŸ“ çµ±åˆä½¿ç”¨ä¾‹

```typescript
// src/app/chat/page.tsx

'use client';

import React, { useState, useEffect } from 'react';
import { ConversationManager } from '@/services/memory/conversation-manager';
import { TrackerManager } from '@/services/tracker/tracker-manager';
import { GroupChatManager } from '@/services/chat/group-chat-manager';
import { useCharacterStore } from '@/store/character.store';
import { usePersonaStore } from '@/store/persona.store';

export default function ChatPage() {
  const [conversationManager] = useState(() => new ConversationManager());
  const [trackerManager] = useState(() => new TrackerManager());
  const [groupChatManager] = useState(() => new GroupChatManager(trackerManager));
  
  const { characters, selectedCharacters } = useCharacterStore();
  const { currentPersona } = usePersonaStore();
  
  const [isGroupMode, setIsGroupMode] = useState(false);
  const [groupChat, setGroupChat] = useState(null);

  // ã‚°ãƒ«ãƒ¼ãƒ—ãƒãƒ£ãƒƒãƒˆã®åˆæœŸåŒ–
  const initGroupChat = () => {
    if (selectedCharacters.length > 1 && currentPersona) {
      const chat = groupChatManager.createGroupChat(
        'ã‚°ãƒ«ãƒ¼ãƒ—ãƒãƒ£ãƒƒãƒˆ',
        selectedCharacters.map(c => c.id),
        selectedCharacters,
        currentPersona,
        'sequential'
      );
      setGroupChat(chat);
      setIsGroupMode(true);
    }
  };

  // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡
  const sendMessage = async (content: string) => {
    if (isGroupMode && groupChat) {
      // ã‚°ãƒ«ãƒ¼ãƒ—ãƒãƒ£ãƒƒãƒˆãƒ¢ãƒ¼ãƒ‰
      const responses = await groupChatManager.sendMessageToGroup(
        groupChat.id,
        content
      );
      
      // å„å¿œç­”ã‚’ä¼šè©±ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã«è¨˜éŒ²
      for (const response of responses) {
        await conversationManager.addMessage(
          'assistant',
          response.content,
          {
            character_id: response.character_id,
            character_name: response.character_name
          }
        );
      }
    } else {
      // é€šå¸¸ã®ãƒãƒ£ãƒƒãƒˆ
      await conversationManager.addMessage('user', content);
      
      // AIã‹ã‚‰ã®å¿œç­”ã‚’ç”Ÿæˆ
      const prompt = await conversationManager.generatePrompt(
        content,
        selectedCharacters[0],
        currentPersona
      );
      
      // ... AIå¿œç­”å‡¦ç†
    }
  };

  // ãƒˆãƒ©ãƒƒã‚«ãƒ¼æ›´æ–°ã®ç›£è¦–
  useEffect(() => {
    trackerManager.onUpdate((update) => {
      console.log('Tracker updated:', update);
      // UIã‚’æ›´æ–°
    });
  }, [trackerManager]);

  return (
    <div className="flex h-screen">
      {/* ãƒãƒ£ãƒƒãƒˆã‚¨ãƒªã‚¢ */}
      <div className="flex-1">
        {/* ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒªã‚¹ãƒˆ */}
        {/* ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å…¥åŠ› */}
      </div>
      
      {/* ãƒˆãƒ©ãƒƒã‚«ãƒ¼ãƒ‘ãƒãƒ« */}
      <div className="w-80 border-l">
        {/* ãƒˆãƒ©ãƒƒã‚«ãƒ¼è¡¨ç¤º */}
      </div>
    </div>
  );
}
```

ã“ã‚Œã§ã€å‹å®šç¾©ã®æ•´åˆæ€§ãŒå–ã‚Œã€ãƒˆãƒ©ãƒƒã‚«ãƒ¼ã‚·ã‚¹ãƒ†ãƒ ã¨ã‚°ãƒ«ãƒ¼ãƒ—ãƒãƒ£ãƒƒãƒˆæ©Ÿèƒ½ãŒçµ±åˆã•ã‚ŒãŸå®Œå…¨ãªã‚·ã‚¹ãƒ†ãƒ ã«ãªã‚Šã¾ã™ã€‚

## ğŸ¨ ã‚«ãƒ©ãƒ•ãƒ«ãªå¹ãå‡ºã—ã¨ãƒ•ã‚©ãƒ³ãƒˆæ¼”å‡ºã®å®Ÿè£…

### 1ï¸âƒ£ **ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ç‰¹æ®Šãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ¤œå‡ºã¨è£…é£¾**

```typescript
// src/components/chat/RichMessage.tsx

import React, { useEffect, useState, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { Heart, Sparkle, Star } from 'lucide-react';
import { cn } from '@/lib/utils';

interface RichMessageProps {
  content: string;
  role: 'user' | 'assistant';
  characterColor?: string;
  enableEffects?: boolean;
  typingSpeed?: number;
}

export const RichMessage: React.FC<RichMessageProps> = ({
  content,
  role,
  characterColor = '#8b5cf6',
  enableEffects = true,
  typingSpeed = 30
}) => {
  const [displayedContent, setDisplayedContent] = useState('');
  const [isTyping, setIsTyping] = useState(true);
  const [particles, setParticles] = useState<any[]>([]);
  const messageRef = useRef<HTMLDivElement>(null);

  // ã‚¿ã‚¤ãƒ—ãƒ©ã‚¤ã‚¿ãƒ¼åŠ¹æœ
  useEffect(() => {
    if (!enableEffects) {
      setDisplayedContent(content);
      setIsTyping(false);
      return;
    }

    let index = 0;
    const timer = setInterval(() => {
      if (index <= content.length) {
        setDisplayedContent(content.slice(0, index));
        
        // ç‰¹å®šã®æ–‡å­—ã§ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’ç™ºç”Ÿ
        if (content[index] === 'â™¥' || content[index] === 'ğŸ’•') {
          createHeartEffect();
        }
        
        index++;
      } else {
        setIsTyping(false);
        clearInterval(timer);
      }
    }, typingSpeed);

    return () => clearInterval(timer);
  }, [content, enableEffects, typingSpeed]);

  // ãƒãƒ¼ãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ç”Ÿæˆ
  const createHeartEffect = () => {
    const newParticle = {
      id: Date.now() + Math.random(),
      x: Math.random() * 100 - 50,
      y: Math.random() * 20
    };
    
    setParticles(prev => [...prev, newParticle]);
    
    // 2ç§’å¾Œã«å‰Šé™¤
    setTimeout(() => {
      setParticles(prev => prev.filter(p => p.id !== newParticle.id));
    }, 2000);
  };

  // ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®ãƒ‘ãƒ¼ã‚¹ï¼ˆç‰¹æ®Šãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã®æ¤œå‡ºï¼‰
  const parseContent = (text: string) => {
    const elements: JSX.Element[] = [];
    
    // ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°
    const patterns = [
      // ã€Œã€å†…ã®å¼·èª¿
      { regex: /ã€Œ([^ã€]+)ã€/g, style: 'quote' },
      // ã€ã€å†…ã®ç‰¹åˆ¥å¼·èª¿
      { regex: /ã€([^ã€]+)ã€/g, style: 'special-quote' },
      // â€»æ³¨é‡ˆ
      { regex: /â€»([^â€»\n]+)/g, style: 'annotation' },
      // ...çœç•¥è¨˜æ³•
      { regex: /\.{3,}/g, style: 'ellipsis' },
      // æ„Ÿæƒ…è¡¨ç¾ï¼ˆï¼ã‚„ï¼Ÿã®é€£ç¶šï¼‰
      { regex: /[ï¼!ï¼Ÿ?]{2,}/g, style: 'emotion' },
      // ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚° [color:text]
      { regex: /\[(\w+):([^\]]+)\]/g, style: 'custom' }
    ];

    let lastIndex = 0;
    let result = text;
    const matches: any[] = [];

    // ã™ã¹ã¦ã®ãƒãƒƒãƒã‚’åé›†
    patterns.forEach(({ regex, style }) => {
      let match;
      while ((match = regex.exec(text)) !== null) {
        matches.push({
          start: match.index,
          end: match.index + match[0].length,
          text: match[1] || match[0],
          style,
          fullMatch: match[0]
        });
      }
    });

    // ãƒãƒƒãƒã‚’ä½ç½®ã§ã‚½ãƒ¼ãƒˆ
    matches.sort((a, b) => a.start - b.start);

    // JSXè¦ç´ ã‚’æ§‹ç¯‰
    matches.forEach((match, index) => {
      // ãƒãƒƒãƒå‰ã®ãƒ†ã‚­ã‚¹ãƒˆ
      if (lastIndex < match.start) {
        elements.push(
          <span key={`text-${index}`}>
            {text.slice(lastIndex, match.start)}
          </span>
        );
      }

      // ãƒãƒƒãƒã—ãŸéƒ¨åˆ†ã‚’ã‚¹ã‚¿ã‚¤ãƒ«ä»˜ãã§è¿½åŠ 
      elements.push(
        <StyledText
          key={`styled-${index}`}
          text={match.text}
          style={match.style}
          color={characterColor}
        />
      );

      lastIndex = match.end;
    });

    // æ®‹ã‚Šã®ãƒ†ã‚­ã‚¹ãƒˆ
    if (lastIndex < text.length) {
      elements.push(
        <span key="text-final">{text.slice(lastIndex)}</span>
      );
    }

    return elements.length > 0 ? elements : <span>{text}</span>;
  };

  return (
    <div className="relative">
      {/* ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒãƒ–ãƒ« */}
      <motion.div
        ref={messageRef}
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        className={cn(
          'relative px-4 py-3 rounded-2xl max-w-lg',
          'backdrop-blur-sm transition-all duration-300',
          role === 'assistant' ? 
            'bg-gradient-to-br from-purple-500/20 to-pink-500/20 border border-purple-400/30' :
            'bg-gradient-to-br from-blue-500/20 to-cyan-500/20 border border-blue-400/30'
        )}
        style={{
          boxShadow: `0 0 20px ${characterColor}20`,
        }}
      >
        {/* ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ */}
        {isTyping && (
          <motion.span
            animate={{ opacity: [0.5, 1, 0.5] }}
            transition={{ duration: 1, repeat: Infinity }}
            className="absolute -right-2 -bottom-2"
          >
            âœ¨
          </motion.span>
        )}

        {/* ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å†…å®¹ */}
        <div className="relative z-10 text-white">
          {parseContent(displayedContent)}
        </div>

        {/* ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ */}
        <AnimatePresence>
          {particles.map(particle => (
            <motion.div
              key={particle.id}
              initial={{ 
                x: 0, 
                y: 0, 
                scale: 0,
                opacity: 1 
              }}
              animate={{ 
                x: particle.x,
                y: particle.y - 50,
                scale: [0, 1.5, 0.5],
                opacity: 0
              }}
              exit={{ opacity: 0 }}
              transition={{ duration: 2, ease: 'easeOut' }}
              className="absolute top-1/2 left-1/2 pointer-events-none"
              style={{ zIndex: 100 }}
            >
              <Heart className="w-4 h-4 text-pink-400 fill-pink-400" />
            </motion.div>
          ))}
        </AnimatePresence>
      </motion.div>
    </div>
  );
};

// ã‚¹ã‚¿ã‚¤ãƒ«ä»˜ããƒ†ã‚­ã‚¹ãƒˆã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
const StyledText: React.FC<{
  text: string;
  style: string;
  color: string;
}> = ({ text, style, color }) => {
  const getStyleClass = () => {
    switch (style) {
      case 'quote':
        return 'text-yellow-300 font-bold px-1';
      case 'special-quote':
        return 'text-cyan-300 font-bold text-lg px-1 animate-pulse';
      case 'annotation':
        return 'text-gray-400 text-sm italic';
      case 'ellipsis':
        return 'text-gray-500 tracking-widest';
      case 'emotion':
        return 'text-red-400 font-bold text-xl animate-bounce';
      case 'custom':
        return 'font-bold';
      default:
        return '';
    }
  };

  if (style === 'custom') {
    // ã‚«ã‚¹ã‚¿ãƒ ã‚«ãƒ©ãƒ¼ã®å‡¦ç†
    const colorMap: Record<string, string> = {
      red: '#ef4444',
      blue: '#3b82f6',
      green: '#10b981',
      yellow: '#eab308',
      purple: '#8b5cf6',
      pink: '#ec4899'
    };
    
    const parts = text.split(':');
    if (parts.length === 2) {
      const [colorName, content] = parts;
      return (
        <span 
          style={{ color: colorMap[colorName] || colorName }}
          className="font-bold"
        >
          {content}
        </span>
      );
    }
  }

  return <span className={getStyleClass()}>{text}</span>;
};
```

### 2ï¸âƒ£ **é«˜åº¦ãªã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚·ã‚¹ãƒ†ãƒ **

```typescript
// src/components/chat/MessageEffects.tsx

import React, { useEffect, useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import confetti from 'canvas-confetti';

interface MessageEffectsProps {
  trigger: string;
  position: { x: number; y: number };
}

export const MessageEffects: React.FC<MessageEffectsProps> = ({
  trigger,
  position
}) => {
  const [effects, setEffects] = useState<any[]>([]);

  useEffect(() => {
    // ãƒˆãƒªã‚¬ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã«åŸºã¥ã„ã¦ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’ç™ºå‹•
    const effectMap: Record<string, () => void> = {
      'æ„›ã—ã¦ã‚‹': () => createHeartShower(),
      'ãŠã‚ã§ã¨ã†': () => createConfetti(),
      'ã‚ã‚ŠãŒã¨ã†': () => createSparkles(),
      'ç´ æ™´ã‚‰ã—ã„': () => createStarBurst(),
      'æœ€é«˜': () => createRainbow()
    };

    Object.keys(effectMap).forEach(keyword => {
      if (trigger.includes(keyword)) {
        effectMap[keyword]();
      }
    });
  }, [trigger]);

  // ãƒãƒ¼ãƒˆã‚·ãƒ£ãƒ¯ãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
  const createHeartShower = () => {
    const hearts = Array.from({ length: 20 }, (_, i) => ({
      id: `heart-${Date.now()}-${i}`,
      delay: i * 100,
      x: Math.random() * 200 - 100,
      y: Math.random() * 100,
      rotation: Math.random() * 360,
      scale: 0.5 + Math.random() * 0.5
    }));

    setEffects(prev => [...prev, ...hearts]);

    setTimeout(() => {
      setEffects(prev => prev.filter(e => !hearts.find(h => h.id === e.id)));
    }, 3000);
  };

  // ã‚³ãƒ³ãƒ•ã‚§ãƒƒãƒ†ã‚£ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
  const createConfetti = () => {
    confetti({
      particleCount: 100,
      spread: 70,
      origin: { 
        x: position.x / window.innerWidth,
        y: position.y / window.innerHeight 
      },
      colors: ['#ff69b4', '#ff1493', '#ff6347', '#ffd700', '#00ced1']
    });
  };

  // ã‚¹ãƒ‘ãƒ¼ã‚¯ãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
  const createSparkles = () => {
    const sparkles = Array.from({ length: 15 }, (_, i) => ({
      id: `sparkle-${Date.now()}-${i}`,
      delay: i * 50,
      x: Math.random() * 150 - 75,
      y: Math.random() * 150 - 75,
      size: Math.random() * 20 + 10
    }));

    setEffects(prev => [...prev, ...sparkles]);

    setTimeout(() => {
      setEffects(prev => prev.filter(e => !sparkles.find(s => s.id === e.id)));
    }, 2000);
  };

  // ã‚¹ã‚¿ãƒ¼ãƒãƒ¼ã‚¹ãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
  const createStarBurst = () => {
    const stars = Array.from({ length: 8 }, (_, i) => ({
      id: `star-${Date.now()}-${i}`,
      angle: (360 / 8) * i,
      distance: 100
    }));

    setEffects(prev => [...prev, ...stars]);

    setTimeout(() => {
      setEffects(prev => prev.filter(e => !stars.find(s => s.id === e.id)));
    }, 1500);
  };

  // ãƒ¬ã‚¤ãƒ³ãƒœãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
  const createRainbow = () => {
    setEffects(prev => [...prev, {
      id: `rainbow-${Date.now()}`,
      type: 'rainbow'
    }]);

    setTimeout(() => {
      setEffects(prev => prev.filter(e => !e.id.startsWith('rainbow')));
    }, 3000);
  };

  return (
    <AnimatePresence>
      {effects.map(effect => {
        if (effect.id.startsWith('heart')) {
          return (
            <motion.div
              key={effect.id}
              initial={{ 
                x: 0, 
                y: 0, 
                scale: 0, 
                rotate: 0,
                opacity: 0 
              }}
              animate={{ 
                x: effect.x,
                y: -effect.y - 100,
                scale: effect.scale,
                rotate: effect.rotation,
                opacity: [0, 1, 1, 0]
              }}
              transition={{ 
                duration: 2.5,
                delay: effect.delay / 1000,
                ease: 'easeOut'
              }}
              className="absolute pointer-events-none"
              style={{ 
                left: position.x,
                top: position.y,
                zIndex: 1000
              }}
            >
              <span className="text-3xl">ğŸ’•</span>
            </motion.div>
          );
        }

        if (effect.id.startsWith('sparkle')) {
          return (
            <motion.div
              key={effect.id}
              initial={{ 
                x: position.x,
                y: position.y,
                scale: 0,
                opacity: 0
              }}
              animate={{
                x: position.x + effect.x,
                y: position.y + effect.y,
                scale: [0, 1, 0],
                opacity: [0, 1, 0]
              }}
              transition={{
                duration: 1.5,
                delay: effect.delay / 1000,
                ease: 'easeOut'
              }}
              className="absolute pointer-events-none"
              style={{ zIndex: 1000 }}
            >
              <svg
                width={effect.size}
                height={effect.size}
                viewBox="0 0 24 24"
                fill="none"
              >
                <path
                  d="M12 2L15 9L22 10L17 15L18 22L12 18L6 22L7 15L2 10L9 9L12 2Z"
                  fill="url(#sparkle-gradient)"
                  stroke="white"
                  strokeWidth="1"
                />
                <defs>
                  <linearGradient id="sparkle-gradient">
                    <stop offset="0%" stopColor="#fbbf24" />
                    <stop offset="100%" stopColor="#f59e0b" />
                  </linearGradient>
                </defs>
              </svg>
            </motion.div>
          );
        }

        if (effect.id.startsWith('star')) {
          const rad = (effect.angle * Math.PI) / 180;
          const x = Math.cos(rad) * effect.distance;
          const y = Math.sin(rad) * effect.distance;

          return (
            <motion.div
              key={effect.id}
              initial={{
                x: position.x,
                y: position.y,
                scale: 0,
                opacity: 1
              }}
              animate={{
                x: position.x + x,
                y: position.y + y,
                scale: [0, 1.5, 0],
                opacity: [1, 1, 0],
                rotate: 360
              }}
              transition={{
                duration: 1.5,
                ease: 'easeOut'
              }}
              className="absolute pointer-events-none text-2xl"
              style={{ zIndex: 1000 }}
            >
              â­
            </motion.div>
          );
        }

        if (effect.type === 'rainbow') {
          return (
            <motion.div
              key={effect.id}
              initial={{ opacity: 0, scale: 0 }}
              animate={{ opacity: [0, 1, 1, 0], scale: [0, 1.5, 1.5, 0] }}
              transition={{ duration: 3 }}
              className="absolute pointer-events-none"
              style={{
                left: position.x - 100,
                top: position.y - 50,
                zIndex: 999
              }}
            >
              <div className="text-6xl">ğŸŒˆ</div>
            </motion.div>
          );
        }

        return null;
      })}
    </AnimatePresence>
  );
};
```

### 3ï¸âƒ£ **ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚¹ã‚¿ã‚¤ãƒ«è¨­å®šã‚·ã‚¹ãƒ†ãƒ **

```typescript
// src/services/message-styling.service.ts

export interface MessageStyle {
  bubbleGradient?: string;
  textColor?: string;
  fontSize?: string;
  fontWeight?: string;
  animation?: string;
  glowColor?: string;
  specialEffects?: string[];
}

export class MessageStylingService {
  // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã”ã¨ã®ã‚¹ã‚¿ã‚¤ãƒ«ãƒãƒƒãƒ—
  private characterStyles = new Map<string, MessageStyle>();

  // æ„Ÿæƒ…ã«åŸºã¥ãã‚¹ã‚¿ã‚¤ãƒ«
  private emotionStyles: Record<string, MessageStyle> = {
    happy: {
      bubbleGradient: 'from-yellow-400/30 to-orange-400/30',
      textColor: 'text-yellow-100',
      glowColor: '#fbbf24',
      specialEffects: ['sparkles', 'bounce']
    },
    love: {
      bubbleGradient: 'from-pink-500/30 to-red-500/30',
      textColor: 'text-pink-100',
      glowColor: '#ec4899',
      specialEffects: ['hearts', 'pulse']
    },
    excited: {
      bubbleGradient: 'from-purple-500/30 to-indigo-500/30',
      textColor: 'text-purple-100',
      fontSize: 'text-lg',
      animation: 'animate-bounce',
      glowColor: '#8b5cf6',
      specialEffects: ['confetti', 'shake']
    },
    mysterious: {
      bubbleGradient: 'from-gray-700/30 to-slate-800/30',
      textColor: 'text-gray-300',
      fontWeight: 'font-light',
      animation: 'animate-pulse',
      glowColor: '#475569',
      specialEffects: ['fog', 'fade']
    }
  };

  // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å†…å®¹ã‹ã‚‰æ„Ÿæƒ…ã‚’æ¨æ¸¬
  detectEmotion(content: string): string {
    const emotionKeywords = {
      happy: ['å¬‰ã—ã„', 'æ¥½ã—ã„', 'ã‚ãƒ¼ã„', 'ğŸ˜Š', 'ğŸ˜„', 'ã‚„ã£ãŸ'],
      love: ['æ„›', 'å¥½ã', 'å¤§åˆ‡', 'ğŸ’•', 'â¤ï¸', 'ãƒ©ãƒ–'],
      excited: ['ã™ã”ã„', 'æœ€é«˜', 'ï¼ï¼', 'ã‚ãŠ', 'èˆˆå¥®'],
      mysterious: ['...', 'è¬', 'ç§˜å¯†', 'æ·±å¤œ', 'é—‡']
    };

    for (const [emotion, keywords] of Object.entries(emotionKeywords)) {
      if (keywords.some(keyword => content.includes(keyword))) {
        return emotion;
      }
    }

    return 'default';
  }

  // ã‚¹ã‚¿ã‚¤ãƒ«ã®ç”Ÿæˆ
  generateStyle(
    content: string,
    characterId?: string,
    customStyle?: Partial<MessageStyle>
  ): MessageStyle {
    // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼å›ºæœ‰ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’å–å¾—
    const characterStyle = characterId ? 
      this.characterStyles.get(characterId) : {};

    // æ„Ÿæƒ…ã«åŸºã¥ãã‚¹ã‚¿ã‚¤ãƒ«ã‚’å–å¾—
    const emotion = this.detectEmotion(content);
    const emotionStyle = this.emotionStyles[emotion] || {};

    // ã‚¹ã‚¿ã‚¤ãƒ«ã‚’ãƒãƒ¼ã‚¸ï¼ˆå„ªå…ˆé †ä½: custom > character > emotionï¼‰
    return {
      ...emotionStyle,
      ...characterStyle,
      ...customStyle
    };
  }

  // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚¹ã‚¿ã‚¤ãƒ«ã®ç™»éŒ²
  registerCharacterStyle(characterId: string, style: MessageStyle): void {
    this.characterStyles.set(characterId, style);
  }
}
```

### 4ï¸âƒ£ **ä½¿ç”¨ä¾‹ï¼ˆçµ±åˆå®Ÿè£…ï¼‰**

```typescript
// src/app/chat/EnhancedChat.tsx

'use client';

import React, { useState, useRef } from 'react';
import { RichMessage } from '@/components/chat/RichMessage';
import { MessageEffects } from '@/components/chat/MessageEffects';
import { MessageStylingService } from '@/services/message-styling.service';
import { motion, AnimatePresence } from 'framer-motion';

export const EnhancedChat: React.FC = () => {
  const [messages, setMessages] = useState<any[]>([]);
  const [effectTrigger, setEffectTrigger] = useState<string>('');
  const [effectPosition, setEffectPosition] = useState({ x: 0, y: 0 });
  const stylingService = new MessageStylingService();
  const chatContainerRef = useRef<HTMLDivElement>(null);

  // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡æ™‚
  const handleSendMessage = (content: string) => {
    const newMessage = {
      id: Date.now(),
      content,
      role: 'user',
      timestamp: new Date().toISOString()
    };

    setMessages(prev => [...prev, newMessage]);

    // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ãƒˆãƒªã‚¬ãƒ¼
    if (chatContainerRef.current) {
      const rect = chatContainerRef.current.getBoundingClientRect();
      setEffectPosition({
        x: rect.left + rect.width / 2,
        y: rect.top + rect.height - 100
      });
      setEffectTrigger(content);
    }

    // AIå¿œç­”ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
    setTimeout(() => {
      const aiResponse = {
        id: Date.now() + 1,
        content: `ã€Œãªã‚‹ã»ã©ï¼ã€ãã‚Œã¯${content.includes('æ„›') ? 'ğŸ’•ç´ æ•µã§ã™ã­ğŸ’•' : 'é¢ç™½ã„ã§ã™ã­'}...ï¼`,
        role: 'assistant',
        characterId: 'char_001',
        timestamp: new Date().toISOString()
      };
      
      setMessages(prev => [...prev, aiResponse]);
    }, 1000);
  };

  return (
    <div className="relative h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900">
      {/* èƒŒæ™¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ */}
      <div className="absolute inset-0 overflow-hidden">
        <div className="absolute -top-40 -right-40 w-80 h-80 bg-purple-500 rounded-full mix-blend-multiply filter blur-3xl opacity-20 animate-blob" />
        <div className="absolute -bottom-40 -left-40 w-80 h-80 bg-pink-500 rounded-full mix-blend-multiply filter blur-3xl opacity-20 animate-blob animation-delay-2000" />
      </div>

      {/* ãƒãƒ£ãƒƒãƒˆã‚³ãƒ³ãƒ†ãƒŠ */}
      <div 
        ref={chatContainerRef}
        className="relative z-10 h-full flex flex-col p-4"
      >
        {/* ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒªã‚¹ãƒˆ */}
        <div className="flex-1 overflow-y-auto space-y-4 mb-4">
          <AnimatePresence>
            {messages.map((message, index) => (
              <motion.div
                key={message.id}
                initial={{ opacity: 0, x: message.role === 'user' ? 100 : -100 }}
                animate={{ opacity: 1, x: 0 }}
                exit={{ opacity: 0, scale: 0.8 }}
                transition={{ duration: 0.3, delay: index * 0.1 }}
                className={`flex ${message.role === 'user' ? 'justify-end' : 'justify-start'}`}
              >
                <RichMessage
                  content={message.content}
                  role={message.role}
                  characterColor={message.role === 'assistant' ? '#8b5cf6' : '#3b82f6'}
                  enableEffects={true}
                  typingSpeed={message.role === 'assistant' ? 30 : 0}
                />
              </motion.div>
            ))}
          </AnimatePresence>
        </div>

        {/* å…¥åŠ›ã‚¨ãƒªã‚¢ */}
        <div className="relative">
          <input
            type="text"
            placeholder="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›..."
            className="w-full px-4 py-3 bg-white/10 backdrop-blur-md rounded-full text-white placeholder-white/50 border border-white/20 focus:outline-none focus:border-purple-400"
            onKeyPress={(e) => {
              if (e.key === 'Enter' && e.currentTarget.value) {
                handleSendMessage(e.currentTarget.value);
                e.currentTarget.value = '';
              }
            }}
          />
        </div>
      </div>

      {/* ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ */}
      <MessageEffects trigger={effectTrigger} position={effectPosition} />
    </div>
  );
};
```

### 5ï¸âƒ£ **è¿½åŠ ã®CSSï¼ˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰**

```css
/* globals.css ã«è¿½åŠ  */

@keyframes blob {
  0%, 100% { transform: translate(0px, 0px) scale(1); }
  33% { transform: translate(30px, -50px) scale(1.1); }
  66% { transform: translate(-20px, 20px) scale(0.9); }
}

.animate-blob {
  animation: blob 7s infinite;
}

.animation-delay-2000 {
  animation-delay: 2s;
}

@keyframes shimmer {
  0% { background-position: -1000px 0; }
  100% { background-position: 1000px 0; }
}

.shimmer {
  background: linear-gradient(
    90deg,
    transparent,
    rgba(255, 255, 255, 0.3),
    transparent
  );
  background-size: 1000px 100%;
  animation: shimmer 2s infinite;
}

/* ãƒ†ã‚­ã‚¹ãƒˆã‚°ãƒ­ãƒ¼åŠ¹æœ */
.text-glow {
  text-shadow: 
    0 0 10px currentColor,
    0 0 20px currentColor,
    0 0 30px currentColor;
}

/* ãƒ‘ãƒ«ã‚¹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
@keyframes pulse-glow {
  0%, 100% { 
    box-shadow: 0 0 20px rgba(139, 92, 246, 0.5);
  }
  50% { 
    box-shadow: 0 0 40px rgba(139, 92, 246, 0.8);
  }
}

.animate-pulse-glow {
  animation: pulse-glow 2s infinite;
}
```

ã“ã‚Œã‚‰ã®å®Ÿè£…ã«ã‚ˆã‚Šã€ä»¥ä¸‹ã®ã‚ˆã†ãªæ©Ÿèƒ½ãŒå®Ÿç¾ã§ãã¾ã™ï¼š

1. **ã‚«ãƒ©ãƒ•ãƒ«ãªå¹ãå‡ºã—**: ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³èƒŒæ™¯ã€ã‚°ãƒ­ãƒ¼åŠ¹æœ
2. **ç‰¹æ®Šæ–‡å­—è£…é£¾**: ã€Œã€ã‚„ã€ã€ã€â€»ãªã©ã®è‡ªå‹•æ¤œå‡ºã¨è£…é£¾
3. **ã‚¿ã‚¤ãƒ—ãƒ©ã‚¤ã‚¿ãƒ¼åŠ¹æœ**: æ–‡å­—ã‚’1ã¤ãšã¤è¡¨ç¤º
4. **ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ**: ãƒãƒ¼ãƒˆã€æ˜Ÿã€è™¹ãªã©ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
5. **æ„Ÿæƒ…æ¤œå‡º**: ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å†…å®¹ã‹ã‚‰æ„Ÿæƒ…ã‚’æ¨æ¸¬ã—ã¦ã‚¹ã‚¿ã‚¤ãƒ«å¤‰æ›´
6. **ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒˆãƒªã‚¬ãƒ¼**: ç‰¹å®šã®è¨€è‘‰ã§ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç™ºå‹•

ã•ã‚‰ã«é«˜åº¦ãªæ¼”å‡ºã‚‚å¯èƒ½ã§ã™ã®ã§ã€ã”è¦æœ›ãŒã‚ã‚Œã°ãŠçŸ¥ã‚‰ã›ãã ã•ã„ï¼