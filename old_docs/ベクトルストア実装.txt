2️⃣ ベクトルストア実装
typescript// src/services/memory/vector-store.ts

import { Message, SearchResult } from './types';

/**
 * FAISSをTypeScriptで使用するためのブリッジクラス
 * 実際の実装では、PythonバックエンドまたはWebAssemblyバージョンを使用
 */
export class VectorStore {
  private embeddings: Map<string, number[]> = new Map();
  private messages: Map<string, Message> = new Map();
  private dimension: number = 1536; // OpenAI embedding dimension
  
  // FAISSインデックス（実際はPython側で管理）
  private indexInitialized: boolean = false;

  constructor() {
    this.initializeIndex();
  }

  /**
   * ベクトルインデックスの初期化
   * 実際の実装では、Python側のFAISSまたはJS向けライブラリを使用
   */
  private async initializeIndex(): Promise<void> {
    // FAISSの初期化をシミュレート
    // 実際は: await this.pythonBridge.initializeFaiss(this.dimension);
    this.indexInitialized = true;
  }

  /**
   * テキストをベクトル化
   * OpenAI Embedding APIまたはローカルモデルを使用
   */
  private async embed(text: string): Promise<number[]> {
    try {
      // 実際のOpenAI API呼び出し
      const response = await fetch('/api/embeddings', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ text })
      });
      
      const data = await response.json();
      return data.embedding;
    } catch (error) {
      console.error('Embedding error:', error);
      // フォールバック: 簡易的なハッシュベースの疑似ベクトル
      return this.createFallbackEmbedding(text);
    }
  }

  /**
   * フォールバック用の簡易ベクトル生成
   * 本番環境では使用しない
   */
  private createFallbackEmbedding(text: string): number[] {
    const vector = new Array(this.dimension).fill(0);
    const words = text.toLowerCase().split(/\s+/);
    
    words.forEach((word, i) => {
      const hash = this.hashCode(word);
      const index = Math.abs(hash) % this.dimension;
      vector[index] = (vector[index] + 1) / Math.sqrt(words.length);
    });
    
    return vector;
  }

  private hashCode(str: string): number {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return hash;
  }

  /**
   * メッセージを追加してインデックス化
   * コスト最適化: バッチ処理で embedding API呼び出しを削減
   */
  async addMessage(message: Message): Promise<void> {
    // 既存のメッセージはスキップ（コスト削減）
    if (this.messages.has(message.id)) {
      return;
    }

    // 重要度が低いメッセージは embedding をスキップ（コスト最適化）
    if (message.importance !== undefined && message.importance < 0.3) {
      this.messages.set(message.id, message);
      return;
    }

    // ベクトル化とインデックス追加
    const embedding = await this.embed(message.content);
    this.embeddings.set(message.id, embedding);
    this.messages.set(message.id, { ...message, embedding });

    // FAISSインデックスに追加
    // 実際: await this.pythonBridge.addToIndex(message.id, embedding);
  }

  /**
   * バッチ処理でメッセージを追加（コスト最適化）
   */
  async addMessagesBatch(messages: Message[]): Promise<void> {
    // 重要なメッセージのみフィルタリング
    const importantMessages = messages.filter(
      m => !this.messages.has(m.id) && 
           (m.importance === undefined || m.importance >= 0.3)
    );

    if (importantMessages.length === 0) return;

    // バッチでembedding取得（API呼び出し削減）
    const texts = importantMessages.map(m => m.content);
    const embeddings = await this.embedBatch(texts);

    // インデックスに追加
    importantMessages.forEach((message, i) => {
      const embedding = embeddings[i];
      this.embeddings.set(message.id, embedding);
      this.messages.set(message.id, { ...message, embedding });
    });
  }

  /**
   * バッチembedding（コスト削減）
   */
  private async embedBatch(texts: string[]): Promise<number[][]> {
    try {
      const response = await fetch('/api/embeddings/batch', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ texts })
      });
      
      const data = await response.json();
      return data.embeddings;
    } catch (error) {
      // フォールバック
      return texts.map(text => this.createFallbackEmbedding(text));
    }
  }

  /**
   * 類似メッセージを検索
   * クエリ拡張とリランキングで精度向上
   */
  async search(
    query: string, 
    k: number = 5,
    threshold: number = 0.7
  ): Promise<SearchResult[]> {
    const queryEmbedding = await this.embed(query);
    
    // コサイン類似度計算
    const results: SearchResult[] = [];
    
    for (const [id, messageEmbedding] of this.embeddings) {
      const similarity = this.cosineSimilarity(queryEmbedding, messageEmbedding);
      
      if (similarity >= threshold) {
        const message = this.messages.get(id)!;
        results.push({
          message,
          score: similarity,
          relevance: similarity > 0.9 ? 'high' : 
                    similarity > 0.8 ? 'medium' : 'low'
        });
      }
    }

    // スコアでソートしてトップk件を返す
    return results
      .sort((a, b) => b.score - a.score)
      .slice(0, k);
  }

  /**
   * ハイブリッド検索（ベクトル + キーワード）
   */
  async hybridSearch(
    query: string,
    keywords: string[],
    k: number = 5
  ): Promise<SearchResult[]> {
    // ベクトル検索
    const vectorResults = await this.search(query, k * 2);
    
    // キーワードマッチングでブースト
    const boostedResults = vectorResults.map(result => {
      const content = result.message.content.toLowerCase();
      const keywordMatches = keywords.filter(kw => 
        content.includes(kw.toLowerCase())
      ).length;
      
      // キーワードマッチでスコアブースト
      const boostedScore = result.score + (keywordMatches * 0.1);
      
      return {
        ...result,
        score: Math.min(boostedScore, 1.0)
      };
    });

    return boostedResults
      .sort((a, b) => b.score - a.score)
      .slice(0, k);
  }

  /**
   * コサイン類似度計算
   */
  private cosineSimilarity(a: number[], b: number[]): number {
    let dotProduct = 0;
    let normA = 0;
    let normB = 0;
    
    for (let i = 0; i < a.length; i++) {
      dotProduct += a[i] * b[i];
      normA += a[i] * a[i];
      normB += b[i] * b[i];
    }
    
    return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
  }

  /**
   * インデックスのクリーンアップ（メモリ管理）
   */
  async cleanup(maxMessages: number = 1000): Promise<void> {
    if (this.messages.size <= maxMessages) return;

    // 古いメッセージを削除（重要度とピン留めを考慮）
    const sortedMessages = Array.from(this.messages.values())
      .filter(m => !m.pinned)
      .sort((a, b) => {
        // 重要度優先
        if (a.importance !== b.importance) {
          return (b.importance || 0) - (a.importance || 0);
        }
        // タイムスタンプで比較
        return new Date(b.timestamp).getTime() - 
               new Date(a.timestamp).getTime();
      });

    // 削除対象を決定
    const toDelete = sortedMessages.slice(maxMessages);
    
    toDelete.forEach(message => {
      this.messages.delete(message.id);
      this.embeddings.delete(message.id);
    });
  }
}
3️⃣ メモリレイヤー管理
typescript// src/services/memory/memory-layers.ts

import { Message, MemoryLayer } from './types';

/**
 * 階層的メモリ管理
 * 認知科学のメモリモデルに基づく実装
 */
export class MemoryLayerManager {
  private layers: Map<string, MemoryLayer>;
  
  constructor() {
    this.layers = new Map([
      ['immediate', {
        type: 'immediate',
        messages: [],
        maxSize: 3,
        retentionPolicy: 'fifo'
      }],
      ['working', {
        type: 'working', 
        messages: [],
        maxSize: 10,
        retentionPolicy: 'importance'
      }],
      ['episodic', {
        type: 'episodic',
        messages: [],
        maxSize: 50,
        retentionPolicy: 'relevance'
      }],
      ['semantic', {
        type: 'semantic',
        messages: [],
        maxSize: 200,
        retentionPolicy: 'importance'
      }]
    ]);
  }

  /**
   * メッセージを適切なレイヤーに追加
   */
  addMessage(message: Message): void {
    // 即時記憶に追加
    this.addToLayer('immediate', message);
    
    // 重要度に基づいて他のレイヤーにも追加
    if (this.shouldAddToWorking(message)) {
      this.addToLayer('working', message);
    }
    
    if (this.shouldAddToEpisodic(message)) {
      this.addToLayer('episodic', message);
    }
    
    if (this.shouldAddToSemantic(message)) {
      this.addToLayer('semantic', message);
    }
  }

  /**
   * レイヤーにメッセージを追加（保持ポリシーに従う）
   */
  private addToLayer(layerName: string, message: Message): void {
    const layer = this.layers.get(layerName);
    if (!layer) return;

    // 重複チェック
    if (layer.messages.some(m => m.id === message.id)) {
      return;
    }

    layer.messages.push(message);
    
    // サイズ制限を超えた場合の処理
    if (layer.messages.length > layer.maxSize) {
      this.enforceRetentionPolicy(layer);
    }
  }

  /**
   * 保持ポリシーを適用
   */
  private enforceRetentionPolicy(layer: MemoryLayer): void {
    switch (layer.retentionPolicy) {
      case 'fifo':
        // 最も古いものを削除
        layer.messages.shift();
        break;
        
      case 'importance':
        // 重要度が最も低いものを削除
        layer.messages.sort((a, b) => 
          (b.importance || 0) - (a.importance || 0)
        );
        layer.messages = layer.messages.slice(0, layer.maxSize);
        break;
        
      case 'relevance':
        // 最も関連性の低いものを削除（時間減衰を考慮）
        const now = Date.now();
        layer.messages.sort((a, b) => {
          const scoreA = this.calculateRelevanceScore(a, now);
          const scoreB = this.calculateRelevanceScore(b, now);
          return scoreB - scoreA;
        });
        layer.messages = layer.messages.slice(0, layer.maxSize);
        break;
    }
  }

  /**
   * 関連性スコアの計算（時間減衰を含む）
   */
  private calculateRelevanceScore(message: Message, now: number): number {
    const age = now - new Date(message.timestamp).getTime();
    const ageInHours = age / (1000 * 60 * 60);
    
    // 時間減衰関数（指数関数的減衰）
    const timeDecay = Math.exp(-ageInHours / 24); // 24時間で約37%に減衰
    
    // 基本スコア（重要度 + ピン留め + 時間減衰）
    const baseScore = (message.importance || 0.5) * timeDecay;
    const pinnedBonus = message.pinned ? 1.0 : 0;
    
    return baseScore + pinnedBonus;
  }

  /**
   * Working Memoryに追加すべきか判定
   */
  private shouldAddToWorking(message: Message): boolean {
    return (message.importance || 0) >= 0.4 || 
           message.pinned === true ||
           message.role === 'user'; // ユーザー入力は常に保持
  }

  /**
   * Episodic Memoryに追加すべきか判定
   */
  private shouldAddToEpisodic(message: Message): boolean {
    // 感情的な内容や特定のイベントを含む場合
    const hasEmotionalContent = message.metadata?.emotion_state !== undefined;
    const hasTrackerUpdate = message.metadata?.tracker_updates !== undefined;
    
    return hasEmotionalContent || 
           hasTrackerUpdate || 
           (message.importance || 0) >= 0.6;
  }

  /**
   * Semantic Memoryに追加すべきか判定
   */
  private shouldAddToSemantic(message: Message): boolean {
    // 事実や定義を含む場合
    const keywords = message.metadata?.keywords || [];
    const hasFactualContent = keywords.some(k => 
      ['定義', '説明', '理由', '方法', '手順'].includes(k)
    );
    
    return hasFactualContent || 
           (message.importance || 0) >= 0.7;
  }

  /**
   * 各レイヤーから関連メッセージを取得
   */
  getLayeredContext(currentQuery: string): {
    immediate: Message[];
    working: Message[];
    episodic: Message[];
    semantic: Message[];
  } {
    return {
      immediate: this.layers.get('immediate')?.messages || [],
      working: this.layers.get('working')?.messages || [],
      episodic: this.layers.get('episodic')?.messages.slice(-5) || [],
      semantic: this.layers.get('semantic')?.messages.slice(-3) || []
    };
  }

  /**
   * メモリの統計情報を取得
   */
  getStatistics(): Record<string, any> {
    const stats: Record<string, any> = {};
    
    this.layers.forEach((layer, name) => {
      stats[name] = {
        count: layer.messages.length,
        maxSize: layer.maxSize,
        utilization: (layer.messages.length / layer.maxSize * 100).toFixed(1) + '%'
      };
    });
    
    return stats;
  }
}
4️⃣ 動的要約システム
typescript// src/services/memory/summarizer.ts

import { Message } from './types';

/**
 * 動的要約生成システム
 * チャンク単位での要約と階層的要約を実装
 */
export class DynamicSummarizer {
  private summaryCache: Map<string, string> = new Map();
  private chunkSize: number = 10; // 10メッセージごとに要約
  private maxSummaryLength: number = 300; // 要約の最大文字数
  
  /**
   * メッセージチャンクの要約を生成
   * コスト最適化: キャッシュを活用してAPI呼び出しを削減
   */
  async summarizeChunk(messages: Message[]): Promise<string> {
    // キャッシュキーの生成
    const cacheKey = this.generateCacheKey(messages);
    
    // キャッシュチェック
    if (this.summaryCache.has(cacheKey)) {
      return this.summaryCache.get(cacheKey)!;
    }

    // 要約プロンプトの構築
    const prompt = this.buildSummaryPrompt(messages);
    
    try {
      // LLMによる要約生成
      const summary = await this.callSummaryAPI(prompt);
      
      // キャッシュに保存
      this.summaryCache.set(cacheKey, summary);
      
      // キャッシュサイズ管理
      this.manageCacheSize();
      
      return summary;
    } catch (error) {
      console.error('Summarization error:', error);
      // フォールバック: 簡易要約
      return this.fallbackSummarize(messages);
    }
  }

  /**
   * 階層的要約の生成
   * 複数のチャンク要約をさらに要約
   */
  async createHierarchicalSummary(
    messages: Message[],
    level: number = 2
  ): Promise<string> {
    if (messages.length <= this.chunkSize) {
      return this.summarizeChunk(messages);
    }

    // メッセージをチャンクに分割
    const chunks = this.splitIntoChunks(messages, this.chunkSize);
    const chunkSummaries: string[] = [];

    // 各チャンクを要約
    for (const chunk of chunks) {
      const summary = await this.summarizeChunk(chunk);
      chunkSummaries.push(summary);
    }

    // レベル2の要約（チャンク要約の要約）
    if (level >= 2 && chunkSummaries.length > 1) {
      const metaSummaryPrompt = `
以下の要約をさらに${this.maxSummaryLength}文字以内で要約してください：

${chunkSummaries.join('\n---\n')}

重要な事実と文脈のみを保持し、詳細は省略してください。
`;
      
      return this.callSummaryAPI(metaSummaryPrompt);
    }

    return chunkSummaries.join(' ');
  }

  /**
   * インクリメンタル要約更新
   * 既存の要約に新しいメッセージを追加
   */
  async updateSummary(
    existingSummary: string,
    newMessages: Message[]
  ): Promise<string> {
    if (newMessages.length === 0) {
      return existingSummary;
    }

    const updatePrompt = `
既存の要約:
${existingSummary}

新しいメッセージ:
${this.formatMessages(newMessages)}

上記の既存要約に新しいメッセージの内容を統合し、
${this.maxSummaryLength}文字以内で更新された要約を作成してください。
古い詳細は削除し、重要な情報のみを保持してください。
`;

    try {
      return await this.callSummaryAPI(updatePrompt);
    } catch (error) {
      // フォールバック: 既存要約 + 新規要約の結合
      const newSummary = await this.summarizeChunk(newMessages);
      return this.combineSummaries(existingSummary, newSummary);
    }
  }

  /**
   * 要約プロンプトの構築
   */
  private buildSummaryPrompt(messages: Message[]): string {
    const formattedMessages = this.formatMessages(messages);
    
    return `
以下の会話を${this.maxSummaryLength}文字以内で要約してください。

要約のガイドライン:
- 重要な事実と決定事項を優先
- 感情的な詳細は省略
- 時系列の流れを保持
- キャラクターの関係性の変化を記録

会話:
${formattedMessages}

要約:
`;
  }

  /**
   * メッセージのフォーマット
   */
  private formatMessages(messages: Message[]): string {
    return messages.map(m => {
      const role = m.role === 'user' ? 'ユーザー' : 'アシスタント';
      return `${role}: ${m.content}`;
    }).join('\n');
  }

  /**
   * API呼び出し（実際の実装）
   */
  private async callSummaryAPI(prompt: string): Promise<string> {
    const response = await fetch('/api/ai/summarize', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        prompt,
        max_tokens: 150,
        temperature: 0.3 // 要約は低温度で安定性重視
      })
    });

    const data = await response.json();
    return data.summary;
  }

  /**
   * フォールバック要約（API失敗時）
   */
  private fallbackSummarize(messages: Message[]): string {
    // 最初と最後のメッセージを抽出
    const first = messages[0];
    const last = messages[messages.length - 1];
    
    // キーワード抽出
    const keywords = this.extractKeywords(messages);
    
    return `会話開始: ${first.content.slice(0, 50)}... ` +
           `キーワード: ${keywords.join(', ')}. ` +
           `最新: ${last.content.slice(0, 50)}...`;
  }

  /**
   * キーワード抽出（簡易版）
   */
  private extractKeywords(messages: Message[]): string[] {
    const text = messages.map(m => m.content).join(' ');
    const words = text.split(/\s+/);
    
    // 単語頻度計算
    const frequency: Record<string, number> = {};
    words.forEach(word => {
      if (word.length > 3) { // 3文字以上の単語
        frequency[word] = (frequency[word] || 0) + 1;
      }
    });

    // 頻度順にソートして上位を返す
    return Object.entries(frequency)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map(([word]) => word);
  }

  /**
   * チャンク分割
   */
  private splitIntoChunks(messages: Message[], size: number): Message[][] {
    const chunks: Message[][] = [];
    for (let i = 0; i < messages.length; i += size) {
      chunks.push(messages.slice(i, i + size));
    }
    return chunks;
  }

  /**
   * キャッシュキー生成
   */
  private generateCacheKey(messages: Message[]): string {
    const ids = messages.map(m => m.id).join('-');
    return `summary-${ids}`;
  }

  /**
   * キャッシュサイズ管理
   */
  private manageCacheSize(): void {
    const maxCacheSize = 100;
    if (this.summaryCache.size > maxCacheSize) {
      // 最も古いエントリを削除
      const firstKey = this.summaryCache.keys().next().value;
      this.summaryCache.delete(firstKey);
    }
  }

  /**
   * 要約の結合
   */
  private combineSummaries(summary1: string, summary2: string): string {
    const combined = `${summary1} ${summary2}`;
    if (combined.length <= this.maxSummaryLength) {
      return combined;
    }
    
    // 文字数制限を超える場合は新しい方を優先
    return summary2.slice(0, this.maxSummaryLength);
  }
}
5️⃣ 統合ConversationManager
typescript// src/services/memory/conversation-manager.ts

import { VectorStore } from './vector-store';
import { MemoryLayerManager } from './memory-layers';
import { DynamicSummarizer } from './summarizer';
import { Message, ConversationContext, SearchResult } from './types';

/**
 * 統合会話管理システム
 * 階層的メモリ、ベクトル検索、動的要約を統合
 */
export class ConversationManager {
  private vectorStore: VectorStore;
  private memoryLayers: MemoryLayerManager;
  private summarizer: DynamicSummarizer;
  
  // 設定パラメータ
  private config = {
    maxImmediateContext: 3,
    maxWorkingMemory: 6,
    maxRelevantMemories: 5,
    summarizeInterval: 10,      // 10メッセージごとに要約
    vectorSearchThreshold: 0.7,
    enablePinning: true,
    costOptimization: {
      batchEmbedding: true,
      cacheEnabled: true,
      lowImportanceThreshold: 0.3
    }
  };

  // 内部状態
  private allMessages: Message[] = [];
  private sessionSummary: string = '';
  private pinnedMessages: Set<string> = new Set();
  private messageCount: number = 0;

  constructor(config?: Partial<typeof ConversationManager.prototype.config>) {
    this.config = { ...this.config, ...config };
    this.vectorStore = new VectorStore();
    this.memoryLayers = new MemoryLayerManager();
    this.summarizer = new DynamicSummarizer();
  }

  /**
   * メッセージを追加して処理
   */
  async addMessage(
    role: 'user' | 'assistant',
    content: string,
    metadata?: Record<string, any>
  ): Promise<Message> {
    // メッセージオブジェクトの作成
    const message: Message = {
      id: this.generateMessageId(),
      role,
      content,
      timestamp: new Date().toISOString(),
      metadata,
      importance: this.calculateImportance(content, metadata)
    };

    // 全メッセージリストに追加
    this.allMessages.push(message);
    this.messageCount++;

    // 階層的メモリに追加
    this.memoryLayers.addMessage(message);

    // ベクトルストアに追加（コスト最適化考慮）
    if (this.shouldIndexMessage(message)) {
      await this.vectorStore.addMessage(message);
    }

    // 自動要約のトリガー
    if (this.messageCount % this.config.summarizeInterval === 0) {
      await this.updateSessionSummary();
    }

    // 重要な情報の自動抽出とピン留め
    if (await this.shouldAutoPinMessage(message)) {
      this.pinMessage(message.id);
    }

    return message;
  }

  /**
   *再試行K続ける編集typescript /**
  * 応答生成用のコンテキストを構築
  * 階層的メモリとベクトル検索を組み合わせた最適なコンテキスト生成
  */
 async buildContext(currentInput: string): Promise<ConversationContext> {
   // 1. 階層的メモリから取得
   const layeredMemory = this.memoryLayers.getLayeredContext(currentInput);
   
   // 2. ベクトル検索で関連メッセージを取得
   const relevantMemories = await this.searchRelevantMemories(currentInput);
   
   // 3. ピン留めされたメッセージを取得
   const pinnedMessages = this.getPinnedMessages();
   
   // 4. コンテキストの構築
   const context: ConversationContext = {
     currentMessage: currentInput,
     immediateContext: layeredMemory.immediate,
     workingMemory: layeredMemory.working.slice(-this.config.maxWorkingMemory),
     relevantMemories: relevantMemories.map(r => r.message),
     sessionSummary: this.sessionSummary,
     pinnedMemories: pinnedMessages
   };

   // 5. トークン数の最適化
   return this.optimizeContextTokens(context);
 }

 /**
  * プロンプトの生成
  * タグシステムを使用して構造化
  */
 async generatePrompt(
   userInput: string,
   character?: any,
   persona?: any
 ): Promise<string> {
   const context = await this.buildContext(userInput);
   
   let prompt = '';

   // システムプロンプト
   if (character?.system_prompt) {
     prompt += `<system>\n${character.system_prompt}\n</system>\n\n`;
   }

   // ピン留めされた重要な記憶
   if (context.pinnedMemories.length > 0) {
     prompt += '<pinned_memories>\n';
     context.pinnedMemories.forEach(msg => {
       prompt += `${msg.role}: ${msg.content}\n`;
     });
     prompt += '</pinned_memories>\n\n';
   }

   // 関連する長期記憶（ベクトル検索結果）
   if (context.relevantMemories.length > 0) {
     prompt += '<relevant_memories>\n';
     context.relevantMemories.slice(0, 3).forEach(msg => {
       prompt += `${msg.role}: ${msg.content}\n`;
     });
     prompt += '</relevant_memories>\n\n';
   }

   // セッション要約
   if (context.sessionSummary) {
     prompt += `<session_summary>\n${context.sessionSummary}\n</session_summary>\n\n`;
   }

   // 直近の会話（Working Memory）
   prompt += '<recent_conversation>\n';
   context.workingMemory.forEach(msg => {
     const role = msg.role === 'user' ? 'ユーザー' : 'アシスタント';
     prompt += `${role}: ${msg.content}\n`;
   });
   prompt += '</recent_conversation>\n\n';

   // 現在の入力
   prompt += `<current_input>\nユーザー: ${userInput}\n</current_input>\n\n`;

   // 応答指示
   prompt += this.buildResponseInstructions();

   return prompt;
 }

 /**
  * 関連メッセージの検索
  * ハイブリッド検索（ベクトル + キーワード）を使用
  */
 private async searchRelevantMemories(query: string): Promise<SearchResult[]> {
   // キーワード抽出
   const keywords = this.extractKeywords(query);
   
   // ハイブリッド検索
   const results = await this.vectorStore.hybridSearch(
     query,
     keywords,
     this.config.maxRelevantMemories
   );

   // 時間減衰を適用
   const now = Date.now();
   return results.map(result => ({
     ...result,
     score: this.applyTimeDecay(result.score, result.message.timestamp, now)
   })).sort((a, b) => b.score - a.score);
 }

 /**
  * メッセージの重要度計算
  * 複数の要因を考慮した総合スコア
  */
 private calculateImportance(content: string, metadata?: any): number {
   let importance = 0.5; // ベーススコア

   // コンテンツの長さ（情報量の指標）
   if (content.length > 200) importance += 0.1;
   if (content.length > 500) importance += 0.1;

   // 感情的な内容
   if (metadata?.emotion_state) {
     importance += 0.15;
   }

   // トラッカー更新を含む
   if (metadata?.tracker_updates) {
     importance += 0.2;
   }

   // 質問文を含む
   if (content.includes('？') || content.includes('?')) {
     importance += 0.1;
   }

   // 固有名詞や数値を含む（事実的内容の可能性）
   const hasNumbers = /\d+/.test(content);
   const hasProperNouns = /[A-Z][a-z]+/.test(content);
   if (hasNumbers || hasProperNouns) {
     importance += 0.1;
   }

   return Math.min(importance, 1.0);
 }

 /**
  * メッセージのピン留め
  * ユーザーが明示的に重要とマークした情報
  */
 pinMessage(messageId: string): void {
   const message = this.allMessages.find(m => m.id === messageId);
   if (message) {
     message.pinned = true;
     this.pinnedMessages.add(messageId);
     
     // ベクトルストアにも追加（重要なので必ず索引化）
     this.vectorStore.addMessage(message);
   }
 }

 /**
  * メッセージのピン留め解除
  */
 unpinMessage(messageId: string): void {
   const message = this.allMessages.find(m => m.id === messageId);
   if (message) {
     message.pinned = false;
     this.pinnedMessages.delete(messageId);
   }
 }

 /**
  * ピン留めされたメッセージの取得
  */
 private getPinnedMessages(): Message[] {
   return this.allMessages.filter(m => m.pinned === true);
 }

 /**
  * 自動ピン留めの判定
  * AIが重要と判断した情報を自動的にピン留め
  */
 private async shouldAutoPinMessage(message: Message): Promise<boolean> {
   // 重要度が高い場合
   if (message.importance && message.importance >= 0.8) {
     return true;
   }

   // 特定のキーワードを含む場合
   const importantKeywords = ['約束', '重要', '忘れないで', '覚えて'];
   const containsImportant = importantKeywords.some(keyword => 
     message.content.includes(keyword)
   );

   if (containsImportant) {
     // LLMに判定を委ねる（コスト考慮）
     return this.askLLMForImportance(message);
   }

   return false;
 }

 /**
  * LLMによる重要度判定
  * コスト最適化: バッチ処理可能
  */
 private async askLLMForImportance(message: Message): Promise<boolean> {
   const prompt = `
以下のメッセージが将来の会話で重要になる可能性があるか判定してください。
重要な場合は"yes"、そうでない場合は"no"とだけ答えてください。

メッセージ: ${message.content}

判定:`;

   try {
     const response = await fetch('/api/ai/judge', {
       method: 'POST',
       headers: { 'Content-Type': 'application/json' },
       body: JSON.stringify({
         prompt,
         max_tokens: 10,
         temperature: 0.1
       })
     });

     const data = await response.json();
     return data.result.toLowerCase().includes('yes');
   } catch (error) {
     // エラー時は保守的に判定
     return false;
   }
 }

 /**
  * セッション要約の更新
  * インクリメンタル更新で効率化
  */
 private async updateSessionSummary(): Promise<void> {
   const recentMessages = this.allMessages.slice(-this.config.summarizeInterval);
   
   if (this.sessionSummary) {
     // 既存要約の更新
     this.sessionSummary = await this.summarizer.updateSummary(
       this.sessionSummary,
       recentMessages
     );
   } else {
     // 新規要約の作成
     this.sessionSummary = await this.summarizer.summarizeChunk(recentMessages);
   }
 }

 /**
  * コンテキストのトークン数最適化
  * トークン制限を超えないように調整
  */
 private optimizeContextTokens(context: ConversationContext): ConversationContext {
   const maxTokens = 2000; // 想定最大トークン数
   let currentTokens = this.estimateTokens(context);

   // トークン数が制限を超える場合は削減
   while (currentTokens > maxTokens) {
     // 優先度の低い順に削減
     if (context.relevantMemories.length > 2) {
       context.relevantMemories.pop();
     } else if (context.workingMemory.length > 3) {
       context.workingMemory.shift();
     } else if (context.sessionSummary.length > 200) {
       context.sessionSummary = context.sessionSummary.slice(0, 200) + '...';
     } else {
       break; // これ以上削減できない
     }
     
     currentTokens = this.estimateTokens(context);
   }

   return context;
 }

 /**
  * トークン数の推定
  * 実際はtiktokenライブラリを使用
  */
 private estimateTokens(context: ConversationContext): number {
   let totalChars = context.currentMessage.length;
   
   totalChars += context.immediateContext.reduce((sum, m) => sum + m.content.length, 0);
   totalChars += context.workingMemory.reduce((sum, m) => sum + m.content.length, 0);
   totalChars += context.relevantMemories.reduce((sum, m) => sum + m.content.length, 0);
   totalChars += context.sessionSummary.length;
   totalChars += context.pinnedMemories.reduce((sum, m) => sum + m.content.length, 0);

   // 日本語は1文字≒1トークン、英語は4文字≒1トークンで概算
   return Math.ceil(totalChars / 2);
 }

 /**
  * 時間減衰の適用
  */
 private applyTimeDecay(
   baseScore: number,
   timestamp: string,
   now: number
 ): number {
   const messageTime = new Date(timestamp).getTime();
   const ageInHours = (now - messageTime) / (1000 * 60 * 60);
   
   // 24時間で約0.7倍、48時間で約0.5倍に減衰
   const decayFactor = Math.exp(-ageInHours / 48);
   
   return baseScore * (0.5 + 0.5 * decayFactor);
 }

 /**
  * キーワード抽出
  */
 private extractKeywords(text: string): string[] {
   // 簡易的な実装（実際は形態素解析を使用）
   const words = text.split(/[\s、。！？,.!?]+/);
   return words.filter(word => 
     word.length > 2 && 
     !['です', 'ます', 'した', 'ある', 'いる', 'する', 'なる'].includes(word)
   ).slice(0, 5);
 }

 /**
  * メッセージIDの生成
  */
 private generateMessageId(): string {
   return `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
 }

 /**
  * インデックスすべきメッセージか判定
  * コスト最適化
  */
 private shouldIndexMessage(message: Message): boolean {
   // ピン留めされたメッセージは必ずインデックス
   if (message.pinned) return true;
   
   // 重要度が閾値以上
   if (message.importance && message.importance >= this.config.costOptimization.lowImportanceThreshold) {
     return true;
   }
   
   // ユーザーメッセージは基本的にインデックス
   if (message.role === 'user') return true;
   
   return false;
 }

 /**
  * 応答指示の構築
  */
 private buildResponseInstructions(): string {
   return `
【応答の優先順位】
1. 最優先: <current_input>への直接的で自然な応答
2. 補助的: <recent_conversation>の文脈を考慮した一貫性
3. 必要時のみ: <relevant_memories>や<pinned_memories>の参照

【禁止事項】
- 突然古い話題に戻ること
- 文脈を無視した応答
- <session_summary>の内容を直接言及すること

【指示】
上記の情報を参考に、現在の入力に対して自然に応答してください。
`;
 }

 /**
  * 会話のリセット
  */
 reset(): void {
   this.allMessages = [];
   this.sessionSummary = '';
   this.pinnedMessages.clear();
   this.messageCount = 0;
   this.memoryLayers = new MemoryLayerManager();
 }

 /**
  * 統計情報の取得
  */
 getStatistics(): Record<string, any> {
   return {
     totalMessages: this.allMessages.length,
     pinnedMessages: this.pinnedMessages.size,
     sessionSummaryLength: this.sessionSummary.length,
     memoryLayers: this.memoryLayers.getStatistics(),
     messageCount: this.messageCount
   };
 }

 /**
  * エクスポート用データの生成
  */
 exportData(): any {
   return {
     messages: this.allMessages,
     summary: this.sessionSummary,
     pinnedIds: Array.from(this.pinnedMessages),
     statistics: this.getStatistics()
   };
 }

 /**
  * インポートからの復元
  */
 async importData(data: any): Promise<void> {
   this.allMessages = data.messages || [];
   this.sessionSummary = data.summary || '';
   this.pinnedMessages = new Set(data.pinnedIds || []);
   
   // メモリレイヤーの再構築
   for (const message of this.allMessages) {
     this.memoryLayers.addMessage(message);
     
     // ベクトルストアへの追加（バッチ処理）
     if (this.shouldIndexMessage(message)) {
       await this.vectorStore.addMessage(message);
     }
   }
 }
}
6️⃣ 使用例
typescript// src/app/example-usage.ts

import { ConversationManager } from '@/services/memory/conversation-manager';

async function example() {
  // 初期化
  const manager = new ConversationManager({
    maxImmediateContext: 3,
    maxWorkingMemory: 6,
    summarizeInterval: 10,
    costOptimization: {
      batchEmbedding: true,
      cacheEnabled: true,
      lowImportanceThreshold: 0.3
    }
  });

  // メッセージの追加
  await manager.addMessage('user', 'こんにちは！私は太郎です。');
  await manager.addMessage('assistant', 'こんにちは、太郎さん！');
  
  // 重要なメッセージをピン留め
  const importantMsg = await manager.addMessage(
    'user', 
    '私の誕生日は8月15日です。覚えておいてください。'
  );
  manager.pinMessage(importantMsg.id);

  // コンテキストの構築
  const context = await manager.buildContext('私の名前を覚えていますか？');
  
  // プロンプトの生成
  const prompt = await manager.generatePrompt(
    '私の名前を覚えていますか？',
    { system_prompt: 'あなたは親切なアシスタントです。' }
  );
  
  console.log('Generated Prompt:', prompt);
  
  // 統計情報の取得
  console.log('Statistics:', manager.getStatistics());
  
  ## 🔧 型定義の修正と改善

### 1️⃣ **message.types.ts の修正**

```typescript
// src/types/message.types.ts

// メッセージ型（完全版）
export interface Message {
  id: string;
  session_id: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  character_id?: string;
  character_name?: string;
  timestamp: string;
  edited?: boolean;
  edited_at?: string;
  regenerated?: boolean;
  voice_url?: string;
  attachments?: MessageAttachment[];
  metadata?: MessageMetadata;
  reactions?: MessageReaction[];
  memo?: string;
  is_bookmarked?: boolean;
  is_deleted?: boolean;
  parent_message_id?: string;
  branch_messages?: Message[];
  importance?: number;  // 会話履歴管理システムとの整合性のため追加
  pinned?: boolean;     // 会話履歴管理システムとの整合性のため追加
  embedding?: number[]; // ベクトル検索用