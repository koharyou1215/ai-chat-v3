📁 ファイル構造
src/
├── components/inspiration/
│   ├── ReplysuggestionButton.tsx
│   ├── TextEnhanceButton.tsx
│   ├── SuggestionModal.tsx
│   └── ExpandableMessageInput.tsx
├── services/inspiration/
│   ├── inspiration.service.ts
│   └── prompt-templates.ts
└── store/slices/
    └── inspiration.slice.ts
1️⃣ インスピレーションサービス
typescript// src/services/inspiration/inspiration.service.ts

import { Message } from '@/types';

export class InspirationService {
  /**
   * 会話履歴から返信候補を生成
   * @param recentMessages 直近の会話（3ラウンド）
   * @param customPrompt カスタムプロンプト（ユーザー設定）
   * @param suggestionCount 生成する候補数
   */
  async generateReplySuggestions(
    recentMessages: Message[],
    customPrompt?: string,
    suggestionCount: number = 3
  ): Promise<string[]> {
    // デフォルトのアプローチ
    const defaultApproaches = [
      '共感的で温かい返信',
      '論理的で詳細な返信',
      'ユーモアを交えた軽快な返信',
      '質問で会話を深める返信',
      '簡潔で的確な返信'
    ];

    // 使用するアプローチを選択
    const approaches = defaultApproaches.slice(0, suggestionCount);

    // 会話コンテキストの構築
    const context = this.buildConversationContext(recentMessages);

    // プロンプトの構築
    const prompt = customPrompt || this.buildSuggestionPrompt(context, approaches);

    try {
      // API呼び出し
      const response = await fetch('/api/ai/inspiration/suggest', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          prompt,
          context,
          approaches,
          temperature: 0.8,
          max_tokens: 300
        })
      });

      const data = await response.json();
      return this.parseSuggestions(data.content);
    } catch (error) {
      console.error('Failed to generate suggestions:', error);
      return this.generateFallbackSuggestions(recentMessages);
    }
  }

  /**
   * テキストを強化・拡張
   * @param inputText 入力されたテキスト
   * @param recentMessages 直近の会話
   * @param enhancePrompt カスタムプロンプト
   */
  async enhanceText(
    inputText: string,
    recentMessages: Message[],
    enhancePrompt?: string
  ): Promise<string> {
    // デフォルトの強化プロンプト
    const defaultPrompt = `
以下のテキストを、会話の文脈を考慮して自然で丁寧な文章に拡張してください。
元の意図は保ちつつ、より詳細で表現豊かにしてください。

会話の文脈:
${this.formatRecentMessages(recentMessages)}

元のテキスト:
${inputText}

強化されたテキスト:
`;

    const prompt = enhancePrompt || defaultPrompt;

    try {
      const response = await fetch('/api/ai/inspiration/enhance', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          prompt,
          originalText: inputText,
          context: recentMessages,
          temperature: 0.7,
          max_tokens: 200
        })
      });

      const data = await response.json();
      return data.enhanced || inputText;
    } catch (error) {
      console.error('Failed to enhance text:', error);
      return this.fallbackEnhance(inputText);
    }
  }

  /**
   * 会話コンテキストの構築
   */
  private buildConversationContext(messages: Message[]): string {
    return messages.map(msg => {
      const role = msg.role === 'user' ? 'ユーザー' : 'アシスタント';
      return `${role}: ${msg.content}`;
    }).join('\n');
  }

  /**
   * 返信提案用プロンプトの構築
   */
  private buildSuggestionPrompt(context: string, approaches: string[]): string {
    return `
以下の会話に対して、${approaches.length}つの異なるアプローチで返信を生成してください。

会話の文脈:
${context}

生成する返信のアプローチ:
${approaches.map((approach, i) => `${i + 1}. ${approach}`).join('\n')}

各アプローチに基づいた返信を、以下の形式で出力してください:

[アプローチ1: ${approaches[0]}]
（ここに返信内容）

[アプローチ2: ${approaches[1]}]
（ここに返信内容）

${approaches.slice(2).map((approach, i) => `[アプローチ${i + 3}: ${approach}]\n（ここに返信内容）`).join('\n\n')}
`;
  }

  /**
   * 生成された提案のパース
   */
  private parseSuggestions(content: string): string[] {
    const suggestions: string[] = [];
    const regex = /\[アプローチ\d+:.*?\]\n([\s\S]*?)(?=\[アプローチ|$)/g;
    let match;

    while ((match = regex.exec(content)) !== null) {
      suggestions.push(match[1].trim());
    }

    // パースに失敗した場合は、改行で分割
    if (suggestions.length === 0) {
      return content.split('\n\n').filter(s => s.trim().length > 0);
    }

    return suggestions;
  }

  /**
   * フォールバック用の提案生成
   */
  private generateFallbackSuggestions(messages: Message[]): string[] {
    const lastMessage = messages[messages.length - 1];
    
    if (!lastMessage) {
      return ['こんにちは！', 'はい、どうぞ。', '承知いたしました。'];
    }

    // 簡単なパターンマッチング
    if (lastMessage.content.includes('？') || lastMessage.content.includes('?')) {
      return [
        'はい、そうですね。',
        'それについて詳しく説明します。',
        'ご質問ありがとうございます。'
      ];
    }

    return [
      'なるほど、わかりました。',
      'ありがとうございます。',
      'そうですね。'
    ];
  }

  /**
   * フォールバック用のテキスト強化
   */
  private fallbackEnhance(text: string): string {
    // 基本的な敬語変換
    let enhanced = text;
    
    // 簡単な置換ルール
    const replacements = [
      { from: /^はい$/i, to: 'はい、承知いたしました。' },
      { from: /^ありがとう$/i, to: 'ありがとうございます。' },
      { from: /^わかった$/i, to: 'わかりました。' },
      { from: /^OK$/i, to: '了解いたしました。' },
    ];

    replacements.forEach(rule => {
      enhanced = enhanced.replace(rule.from, rule.to);
    });

    // 文末に句読点がない場合は追加
    if (!/[。！？!?]$/.test(enhanced)) {
      enhanced += '。';
    }

    return enhanced;
  }

  /**
   * 最近のメッセージをフォーマット
   */
  private formatRecentMessages(messages: Message[]): string {
    return messages.slice(-6).map(msg => {
      const role = msg.role === 'user' ? 'ユーザー' : 'アシスタント';
      return `${role}: ${msg.content}`;
    }).join('\n');
  }
}
2️⃣ プロンプトテンプレート管理
typescript// src/services/inspiration/prompt-templates.ts

export interface PromptTemplate {
  id: string;
  name: string;
  description: string;
  prompt: string;
  variables?: string[];
  category: 'suggestion' | 'enhancement';
}

export const DEFAULT_PROMPT_TEMPLATES: PromptTemplate[] = [
  // 返信提案用テンプレート
  {
    id: 'friendly-suggestions',
    name: 'フレンドリーな返信',
    description: '親しみやすい雰囲気の返信を生成',
    category: 'suggestion',
    prompt: `
会話の文脈を踏まえて、親しみやすくフレンドリーな返信を3つ生成してください。
絵文字や感嘆符を適度に使い、温かい雰囲気を演出してください。

会話の文脈:
{{context}}

返信候補:
1. 
2. 
3. 
`,
    variables: ['context']
  },
  {
    id: 'professional-suggestions',
    name: 'プロフェッショナルな返信',
    description: 'ビジネスライクで丁寧な返信を生成',
    category: 'suggestion',
    prompt: `
会話の文脈を踏まえて、プロフェッショナルで丁寧な返信を生成してください。
敬語を適切に使い、論理的で明確な内容にしてください。

会話の文脈:
{{context}}

返信:
`,
    variables: ['context']
  },

  // テキスト強化用テンプレート
  {
    id: 'expand-detail',
    name: '詳細に拡張',
    description: '簡潔な入力を詳細で丁寧な文章に拡張',
    category: 'enhancement',
    prompt: `
以下の短いテキストを、会話の流れに合わせて詳細で丁寧な文章に拡張してください。
具体例や理由を追加し、相手に伝わりやすくしてください。

会話の文脈:
{{context}}

元のテキスト: {{text}}

拡張されたテキスト:
`,
    variables: ['context', 'text']
  },
  {
    id: 'add-emotion',
    name: '感情を追加',
    description: '感情表現を加えて温かみのある文章に',
    category: 'enhancement',
    prompt: `
以下のテキストに適切な感情表現を加えて、より人間味のある文章にしてください。
相手との関係性を考慮し、自然な感情表現を使ってください。

会話の文脈:
{{context}}

元のテキスト: {{text}}

感情を加えたテキスト:
`,
    variables: ['context', 'text']
  },
  {
    id: 'make-polite',
    name: '丁寧語に変換',
    description: 'カジュアルな文章を丁寧な敬語に変換',
    category: 'enhancement',
    prompt: `
以下のテキストを、適切な敬語を使った丁寧な文章に変換してください。

元のテキスト: {{text}}

丁寧な文章:
`,
    variables: ['text']
  }
];
3️⃣ 拡張可能なメッセージ入力コンポーネント
typescript// src/components/inspiration/ExpandableMessageInput.tsx

'use client';

import React, { useState, useRef, useEffect } from 'react';
import { Sparkles, Lightbulb, Maximize2, Minimize2, Send } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils';

interface ExpandableMessageInputProps {
  value: string;
  onChange: (value: string) => void;
  onSubmit: (value: string) => void;
  onSuggestClick: () => void;
  onEnhanceClick: () => void;
  placeholder?: string;
  isLoading?: boolean;
  className?: string;
}

export const ExpandableMessageInput: React.FC<ExpandableMessageInputProps> = ({
  value,
  onChange,
  onSubmit,
  onSuggestClick,
  onEnhanceClick,
  placeholder = 'メッセージを入力...',
  isLoading = false,
  className
}) => {
  const [isExpanded, setIsExpanded] = useState(false);
  const [rows, setRows] = useState(2);
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  // 自動高さ調整
  useEffect(() => {
    if (textareaRef.current) {
      textareaRef.current.style.height = 'auto';
      const scrollHeight = textareaRef.current.scrollHeight;
      const lineHeight = parseInt(window.getComputedStyle(textareaRef.current).lineHeight);
      const newRows = Math.max(2, Math.min(20, Math.ceil(scrollHeight / lineHeight)));
      
      if (!isExpanded) {
        setRows(Math.min(newRows, 5));
      } else {
        setRows(newRows);
      }
      
      textareaRef.current.style.height = `${scrollHeight}px`;
    }
  }, [value, isExpanded]);

  const handleKeyDown = (e: React.KeyboardEvent) => {
    // Shift+Enterで改行、Enterのみで送信（拡張モードでない場合）
    if (e.key === 'Enter' && !e.shiftKey && !isExpanded) {
      e.preventDefault();
      if (value.trim() && !isLoading) {
        onSubmit(value);
      }
    }
  };

  const toggleExpanded = () => {
    setIsExpanded(!isExpanded);
    // 拡張時にフォーカス
    setTimeout(() => {
      textareaRef.current?.focus();
    }, 100);
  };

  return (
    <div className={cn(
      'relative border rounded-lg bg-background transition-all duration-300',
      isExpanded ? 'border-primary shadow-lg' : 'border-input',
      className
    )}>
      {/* ヘッダー（拡張モード時のみ） */}
      {isExpanded && (
        <div className="flex items-center justify-between px-3 py-2 border-b">
          <span className="text-sm font-medium">メッセージエディター</span>
          <div className="flex gap-2">
            <Button
              size="sm"
              variant="ghost"
              onClick={onSuggestClick}
              disabled={isLoading}
              className="h-7"
            >
              <Lightbulb className="w-4 h-4 mr-1" />
              返信提案
            </Button>
            <Button
              size="sm"
              variant="ghost"
              onClick={onEnhanceClick}
              disabled={!value.trim() || isLoading}
              className="h-7"
            >
              <Sparkles className="w-4 h-4 mr-1" />
              文章強化
            </Button>
          </div>
        </div>
      )}

      {/* テキストエリア */}
      <div className="relative">
        <textarea
          ref={textareaRef}
          value={value}
          onChange={(e) => onChange(e.target.value)}
          onKeyDown={handleKeyDown}
          placeholder={placeholder}
          disabled={isLoading}
          rows={rows}
          className={cn(
            'w-full resize-none bg-transparent outline-none transition-all',
            'placeholder:text-muted-foreground',
            isExpanded 
              ? 'p-4 text-base min-h-[200px] max-h-[500px] overflow-y-auto'
              : 'p-3 pr-32 text-sm max-h-[120px] overflow-hidden'
          )}
          style={{
            height: isExpanded ? 'auto' : undefined,
            minHeight: isExpanded ? '200px' : undefined
          }}
        />

        {/* アクションボタン（通常モード） */}
        {!isExpanded && (
          <div className="absolute bottom-2 right-2 flex items-center gap-1">
            <Button
              size="icon"
              variant="ghost"
              onClick={onSuggestClick}
              disabled={isLoading}
              className="h-8 w-8"
              title="返信提案"
            >
              <Lightbulb className="w-4 h-4" />
            </Button>
            <Button
              size="icon"
              variant="ghost"
              onClick={onEnhanceClick}
              disabled={!value.trim() || isLoading}
              className="h-8 w-8"
              title="文章強化"
            >
              <Sparkles className="w-4 h-4" />
            </Button>
            <Button
              size="icon"
              variant="ghost"
              onClick={toggleExpanded}
              className="h-8 w-8"
              title="エディターを拡張"
            >
              <Maximize2 className="w-4 h-4" />
            </Button>
            <Button
              size="icon"
              variant="default"
              onClick={() => onSubmit(value)}
              disabled={!value.trim() || isLoading}
              className="h-8 w-8"
            >
              <Send className="w-4 h-4" />
            </Button>
          </div>
        )}
      </div>

      {/* フッター（拡張モード時） */}
      {isExpanded && (
        <div className="flex items-center justify-between px-3 py-2 border-t">
          <div className="text-xs text-muted-foreground">
            {value.length} 文字 • Shift+Enter で改行
          </div>
          <div className="flex gap-2">
            <Button
              size="sm"
              variant="ghost"
              onClick={toggleExpanded}
              className="h-8"
            >
              <Minimize2 className="w-4 h-4 mr-1" />
              縮小
            </Button>
            <Button
              size="sm"
              variant="default"
              onClick={() => onSubmit(value)}
              disabled={!value.trim() || isLoading}
              className="h-8"
            >
              <Send className="w-4 h-4 mr-1" />
              送信
            </Button>
          </div>
        </div>
      )}

      {/* ローディングオーバーレイ */}
      {isLoading && (
        <div className="absolute inset-0 bg-background/50 flex items-center justify-center rounded-lg">
          <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-primary" />
        </div>
      )}
    </div>
  );
};
4️⃣ 返信提案モーダル
typescript// src/components/inspiration/SuggestionModal.tsx

'use client';

import React, { useState } from 'react';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Card } from '@/components/ui/card';
import { Lightbulb, Copy, Edit, Check } from 'lucide-react';
import { cn } from '@/lib/utils';

interface SuggestionModalProps {
  isOpen: boolean;
  onClose: () => void;
  suggestions: string[];
  onSelect: (suggestion: string) => void;
  isLoading?: boolean;
  title?: string;
}

export const SuggestionModal: React.FC<SuggestionModalProps> = ({
  isOpen,
  onClose,
  suggestions,
  onSelect,
  isLoading = false,
  title = '返信候補'
}) => {
  const [selectedIndex, setSelectedIndex] = useState<number | null>(null);
  const [editingIndex, setEditingIndex] = useState<number | null>(null);
  const [editedSuggestions, setEditedSuggestions] = useState<string[]>([]);

  React.useEffect(() => {
    setEditedSuggestions(suggestions);
    setSelectedIndex(null);
    setEditingIndex(null);
  }, [suggestions]);

  const handleSelect = (index: number) => {
    const suggestion = editedSuggestions[index];
    onSelect(suggestion);
    onClose();
  };

  const handleEdit = (index: number) => {
    setEditingIndex(index);
  };

  const handleSaveEdit = (index: number, newText: string) => {
    const updated = [...editedSuggestions];
    updated[index] = newText;
    setEditedSuggestions(updated);
    setEditingIndex(null);
  };

  const handleCopy = (text: string) => {
    navigator.clipboard.writeText(text);
    // トースト通知を表示（実装省略）
  };

  const getApproachLabel = (index: number) => {
    const approaches = ['共感的', '論理的', 'ユーモア', '質問形式', '簡潔'];
    return approaches[index] || `候補 ${index + 1}`;
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-3xl max-h-[80vh] overflow-hidden flex flex-col">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <Lightbulb className="w-5 h-5" />
            {title}
          </DialogTitle>
        </DialogHeader>

        <div className="flex-1 overflow-y-auto space-y-3 py-4">
          {isLoading ? (
            <div className="flex items-center justify-center py-8">
              <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary" />
            </div>
          ) : (
            editedSuggestions.map((suggestion, index) => (
              <Card
                key={index}
                className={cn(
                  'p-4 cursor-pointer transition-all',
                  'hover:shadow-md hover:border-primary/50',
                  selectedIndex === index && 'border-primary bg-primary/5'
                )}
                onClick={() => setSelectedIndex(index)}
              >
                <div className="space-y-2">
                  <div className="flex items-center justify-between">
                    <span className="text-sm font-medium text-primary">
                      {getApproachLabel(index)}
                    </span>
                    <div className="flex gap-1">
                      <Button
                        size="icon"
                        variant="ghost"
                        className="h-7 w-7"
                        onClick={(e) => {
                          e.stopPropagation();
                          handleCopy(suggestion);
                        }}
                      >
                        <Copy className="w-3 h-3" />
                      </Button>
                      <Button
                        size="icon"
                        variant="ghost"
                        className="h-7 w-7"
                        onClick={(e) => {
                          e.stopPropagation();
                          handleEdit(index);
                        }}
                      >
                        <Edit className="w-3 h-3" />
                      </Button>
                    </div>
                  </div>

                  {editingIndex === index ? (
                    <div className="space-y-2">
                      <textarea
                        value={editedSuggestions[index]}
                        onChange={(e) => {
                          const updated = [...editedSuggestions];
                          updated[index] = e.target.value;
                          setEditedSuggestions(updated);
                        }}
                        className="w-full p-2 border rounded-md resize-none"
                        rows={4}
                        onClick={(e) => e.stopPropagation()}
                      />
                      <div className="flex gap-2">
                        <Button
                          size="sm"
                          onClick={(e) => {
                            e.stopPropagation();
                            handleSaveEdit(index, editedSuggestions[index]);
                          }}
                        >
                          保存
                        </Button>
                        <Button
                          size="sm"
                          variant="ghost"
                          onClick={(e) => {
                            e.stopPropagation();
                            setEditingIndex(null);
                            setEditedSuggestions(suggestions);
                          }}
                        >
                          キャンセル
                        </Button>
                      </div>
                    </div>
                  ) : (
                    <p className="text-sm whitespace-pre-wrap">{suggestion}</p>
                  )}
                </div>
              </Card>
            ))
          )}
        </div>

        <div className="flex justify-end gap-2 pt-4 border-t">
          <Button variant="ghost" onClick={onClose}>
            キャンセル
          </Button>
          <Button
            onClick={() => selectedIndex !== null && handleSelect(selectedIndex)}
            disabled={selectedIndex === null}
          >
            <Check className="w-4 h-4 mr-1" />
            選択した候補を使用
          </Button>
        </div>
      </DialogContent>
    </Dialog>
  );
};
5️⃣ 使用例（統合）
typescript// src/app/chat/ChatInterface.tsx

'use client';

import React, { useState } from 'react';
import { ExpandableMessageInput } from '@/components/inspiration/ExpandableMessageInput';
import { SuggestionModal } from '@/components/inspiration/SuggestionModal';
import { InspirationService } from '@/services/inspiration/inspiration.service';
import { useChat } from '@/hooks/useChat';

export const ChatInterface: React.FC = () => {
  const [message, setMessage] = useState('');
  const [showSuggestions, setShowSuggestions] = useState(false);
  const [suggestions, setSuggestions] = useState<string[]>([]);
  const [isGenerating, setIsGenerating] = useState(false);
  
  const { messages, sendMessage } = useChat();
  const inspirationService = new InspirationService();

  // 返信提案の生成
  const handleSuggestClick = async () => {
    setIsGenerating(true);
    setShowSuggestions(true);

    try {
      // 直近3ラウンド（6メッセージ）を取得
      const recentMessages = messages.slice(-6);
      
      // カスタムプロンプト（設定から取得）
      const customPrompt = localStorage.getItem('suggestionPrompt') || undefined;
      
      const newSuggestions = await inspirationService.generateReplySuggestions(
        recentMessages,
        customPrompt,
        3
      );
      
      setSuggestions(newSuggestions);
    } catch (error) {
      console.error('Failed to generate suggestions:', error);
      setSuggestions(['申し訳ございません。提案の生成に失敗しました。']);
    } finally {
      setIsGenerating(false);
    }
  };

  // テキスト強化
  const handleEnhanceClick = async () => {
    if (!message.trim()) return;

    setIsGenerating(true);
    try {
      const recentMessages = messages.slice(-6);
      const customPrompt = localStorage.getItem('enhancePrompt') || undefined;
      
      const enhanced = await inspirationService.enhanceText(
        message,
        recentMessages,
        customPrompt
      );
      
      setMessage(enhanced);
    } catch (error) {
      console.error('Failed to enhance text:', error);
    } finally {
      setIsGenerating(false);
    }
  };

  // メッセージ送信
  const handleSubmit = (text: string) => {
    if (text.trim()) {
      sendMessage(text);
      setMessage('');
    }
  };

  // 提案の選択
  const handleSelectSuggestion = (suggestion: string) => {
    setMessage(suggestion);
    setShowSuggestions(false);
  };

  return (
    <div className="flex flex-col h-full">
      {/* チャットメッセージ表示エリア */}
      <div className="flex-1 overflow-y-auto p-4">
        {/* メッセージリスト */}
      </div>

      {/* メッセージ入力エリア */}
      <div className="border-t p-4">
        <ExpandableMessageInput
          value={message}
          onChange={setMessage}
          onSubmit={handleSubmit}
          onSuggestClick={handleSuggestClick}
          onEnhanceClick={handleEnhanceClick}
          isLoading={isGenerating}
          placeholder="メッセージを入力..."
        />
      </div>

      {/* 返信提案モーダル */}
      <SuggestionModal
        isOpen={showSuggestions}
        onClose={() => setShowSuggestions(false)}
        suggestions={suggestions}
        onSelect={handleSelectSuggestion}
        isLoading={isGenerating}
      />
    </div>
  );
};

説明
---
仕様書とコードのレビューを行い、問題点の修正と改善提案をまとめました。

## 🔧 型定義の修正と改善

### 1️⃣ **message.types.ts の修正**

```typescript
// src/types/message.types.ts

// メッセージ型（完全版）
export interface Message {
  id: string;
  session_id: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  character_id?: string;
  character_name?: string;
  timestamp: string;
  edited?: boolean;
  edited_at?: string;
  regenerated?: boolean;
  voice_url?: string;
  attachments?: MessageAttachment[];
  metadata?: MessageMetadata;
  reactions?: MessageReaction[];
  memo?: string;
  is_bookmarked?: boolean;
  is_deleted?: boolean;
  parent_message_id?: string;
  branch_messages?: Message[];
  importance?: number;  // 会話履歴管理システムとの整合性のため追加
  pinned?: boolean;     // 会話履歴管理システムとの整合性のため追加
  embedding?: number[]; // ベクトル検索用
}