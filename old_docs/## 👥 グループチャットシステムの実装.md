## ğŸ‘¥ ã‚°ãƒ«ãƒ¼ãƒ—ãƒãƒ£ãƒƒãƒˆã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…

```typescript
// src/services/chat/group-chat-manager.ts

import { GroupChat, Character, Message, Persona } from '@/types';
import { TrackerManager } from '@/services/tracker/tracker-manager';
import { VoicePreset } from '@/types/voice.types';

export class GroupChatManager {
  private groupChats: Map<string, GroupChat> = new Map();
  private trackerManager: TrackerManager;
  private messageQueue: Map<string, Message[]> = new Map();

  constructor(trackerManager: TrackerManager) {
    this.trackerManager = trackerManager;
  }

  /**
   * ã‚°ãƒ«ãƒ¼ãƒ—ãƒãƒ£ãƒƒãƒˆã®ä½œæˆ
   */
  createGroupChat(
    name: string,
    characterIds: string[],
    characters: Character[],
    persona: Persona,
    mode: 'sequential' | 'simultaneous' | 'random' = 'sequential'
  ): GroupChat {
    const groupChat: GroupChat = {
      id: this.generateId(),
      name,
      character_ids: characterIds,
      characters,
      active_characters: new Set(characterIds.slice(0, 3)), // æœ€å¤§3äºº
      character_tracker_sets: new Map(),
      persona_id: persona.id,
      persona,
      messages: [],
      speaking_order: [...characterIds],
      group_mode: mode,
      max_characters: 3,
      voice_settings: new Map(),
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
      last_message_at: new Date().toISOString()
    };

    // å„ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®ãƒˆãƒ©ãƒƒã‚«ãƒ¼ã‚’åˆæœŸåŒ–
    characters.forEach(character => {
      const trackerSet = this.trackerManager.initializeTrackerSet(
        character.id,
        character.trackers
      );
      groupChat.character_tracker_sets.set(character.id, trackerSet);
    });

    this.groupChats.set(groupChat.id, groupChat);
    return groupChat;
  }

  /**
   * ã‚°ãƒ«ãƒ¼ãƒ—ãƒãƒ£ãƒƒãƒˆã¸ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡
   */
  async sendMessageToGroup(
    groupChatId: string,
    userMessage: string
  ): Promise<Message[]> {
    const groupChat = this.groupChats.get(groupChatId);
    if (!groupChat) throw new Error('Group chat not found');

    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿½åŠ 
    const userMsg: Message = {
      id: this.generateId(),
      session_id: groupChatId,
      role: 'user',
      content: userMessage,
      timestamp: new Date().toISOString()
    };
    groupChat.messages.push(userMsg);

    // å„ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‹ã‚‰ã®è¿”ä¿¡ã‚’ç”Ÿæˆ
    const responses: Message[] = [];

    switch (groupChat.group_mode) {
      case 'sequential':
        responses.push(...await this.generateSequentialResponses(groupChat, userMessage));
        break;
      
      case 'simultaneous':
        responses.push(...await this.generateSimultaneousResponses(groupChat, userMessage));
        break;
      
      case 'random':
        responses.push(...await this.generateRandomResponse(groupChat, userMessage));
        break;
    }

    // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨ãƒˆãƒ©ãƒƒã‚«ãƒ¼ã®æ›´æ–°
    for (const response of responses) {
      groupChat.messages.push(response);
      
      // ãƒˆãƒ©ãƒƒã‚«ãƒ¼ã®è‡ªå‹•æ›´æ–°
      if (response.character_id) {
        await this.trackerManager.analyzeAndUpdateTrackers(
          response.character_id,
          response
        );
      }
    }

    groupChat.last_message_at = new Date().toISOString();
    groupChat.updated_at = new Date().toISOString();

    return responses;
  }

  /**
   * é †æ¬¡å¿œç­”ã®ç”Ÿæˆ
   */
  private async generateSequentialResponses(
    groupChat: GroupChat,
    userMessage: string
  ): Promise<Message[]> {
    const responses: Message[] = [];
    const activeCharacters = Array.from(groupChat.active_characters);

    for (const characterId of activeCharacters) {
      const character = groupChat.characters.find(c => c.id === characterId);
      if (!character) continue;

      const response = await this.generateCharacterResponse(
        groupChat,
        character,
        userMessage,
        responses // å‰ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®å¿œç­”ã‚‚è€ƒæ…®
      );
      
      responses.push(response);
      
      // å°‘ã—é…å»¶ã‚’å…¥ã‚Œã‚‹ï¼ˆãƒªã‚¢ãƒ«ãªä¼šè©±æ„Ÿï¼‰
      await this.delay(500);
    }

    return responses;
  }

  /**
   * åŒæ™‚å¿œç­”ã®ç”Ÿæˆ
   */
  private async generateSimultaneousResponses(
    groupChat: GroupChat,
    userMessage: string
  ): Promise<Message[]> {
    const activeCharacters = Array.from(groupChat.active_characters);
    
    const responsePromises = activeCharacters.map(characterId => {
      const character = groupChat.characters.find(c => c.id === characterId);
      if (!character) return null;
      
      return this.generateCharacterResponse(
        groupChat,
        character,
        userMessage,
        []
      );
    });

    const responses = await Promise.all(responsePromises);
    return responses.filter(r => r !== null) as Message[];
  }

  /**
   * ãƒ©ãƒ³ãƒ€ãƒ ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®å¿œç­”ç”Ÿæˆ
   */
  private async generateRandomResponse(
    groupChat: GroupChat,
    userMessage: string
  ): Promise<Message[]> {
    const activeCharacters = Array.from(groupChat.active_characters);
    const randomIndex = Math.floor(Math.random() * activeCharacters.length);
    const characterId = activeCharacters[randomIndex];
    
    const character = groupChat.characters.find(c => c.id === characterId);
    if (!character) return [];

    const response = await this.generateCharacterResponse(
      groupChat,
      character,
      userMessage,
      []
    );

    return [response];
  }

  /**
   * ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼å€‹åˆ¥ã®å¿œç­”ç”Ÿæˆ
   */
  private async generateCharacterResponse(
    groupChat: GroupChat,
    character: Character,
    userMessage: string,
    previousResponses: Message[]
  ): Promise<Message> {
    // ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã®æ§‹ç¯‰
    const prompt = this.buildGroupChatPrompt(
      groupChat,
      character,
      userMessage,
      previousResponses
    );

    try {
      const response = await fetch('/api/ai/generate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          prompt,
          character,
          persona: groupChat.persona,
          temperature: 0.8,
          max_tokens: 200
        })
      });

      const data = await response.json();

      return {
        id: this.generateId(),
        session_id: groupChat.id,
        role: 'assistant',
        content: data.content,
        character_id: character.id,
        character_name: character.name,
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      console.error(`Failed to generate response for ${character.name}:`, error);
      
      return {
        id: this.generateId(),
        session_id: groupChat.id,
        role: 'assistant',
        content: '...',
        character_id: character.id,
        character_name: character.name,
        timestamp: new Date().toISOString()
      };
    }
  }

  /**
   * ã‚°ãƒ«ãƒ¼ãƒ—ãƒãƒ£ãƒƒãƒˆç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã®æ§‹ç¯‰
   */
  private buildGroupChatPrompt(
    groupChat: GroupChat,
    character: Character,
    userMessage: string,
    previousResponses: Message[]
  ): string {
    const otherCharacters = groupChat.characters
      .filter(c => c.id !== character.id && groupChat.active_characters.has(c.id))
      .map(c => c.name)
      .join('ã€');

    const trackerSet = groupChat.character_tracker_sets.get(character.id);
    const trackerInfo = trackerSet ? 
      Array.from(trackerSet.trackers.values())
        .map(t => `${t.display_name}: ${t.current_value}`)
        .join('\n') : '';

    let prompt = `
ã‚ãªãŸã¯${character.name}ã¨ã—ã¦ã€ã‚°ãƒ«ãƒ¼ãƒ—ãƒãƒ£ãƒƒãƒˆã«å‚åŠ ã—ã¦ã„ã¾ã™ã€‚
ä»–ã®å‚åŠ è€…: ${otherCharacters}
ãƒ¦ãƒ¼ã‚¶ãƒ¼: ${groupChat.persona.name}

${character.system_prompt}

ç¾åœ¨ã®çŠ¶æ…‹:
${trackerInfo}

ä¼šè©±ã®æ–‡è„ˆ:
${groupChat.messages.slice(-6).map(m => {
  const speaker = m.role === 'user' ? groupChat.persona.name : 
                  m.character_name || 'ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ';
  return `${speaker}: ${m.content}`;
}).join('\n')}
`;

    // ä»–ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®å¿œç­”ãŒã‚ã‚‹å ´åˆ
    if (previousResponses.length > 0) {
      prompt += `\n\nç›´å‰ã®ä»–ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®å¿œç­”:\n`;
      previousResponses.forEach(r => {
        prompt += `${r.character_name}: ${r.content}\n`;
      });
      prompt += `\nã“ã‚Œã‚‰ã®å¿œç­”ã‚‚è€ƒæ…®ã—ã¦ã€${character.name}ã¨ã—ã¦è‡ªç„¶ã«å¿œç­”ã—ã¦ãã ã•ã„ã€‚`;
    }

    prompt += `\n\n${groupChat.persona.name}: ${userMessage}\n${character.name}: `;

    return prompt;
  }

  /**
   * ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®åˆ‡ã‚Šæ›¿ãˆ
   */
  toggleActiveCharacter(groupChatId: string, characterId: string): void {
    const groupChat = this.groupChats.get(groupChatId);
    if (!groupChat) return;

    if (groupChat.active_characters.has(characterId)) {
      groupChat.active_characters.delete(characterId);
    } else if (groupChat.active_characters.size < groupChat.max_characters) {
      groupChat.active_characters.add(characterId);
    }
  }

  /**
   * éŸ³å£°è¨­å®šã®è¨­å®š
   */
  setVoicePreset(
    groupChatId: string,
    characterId: string,
    voicePreset: VoicePreset
  ): void {
    const groupChat = this.groupChats.get(groupChatId);
    if (!groupChat) return;

    groupChat.voice_settings.set(characterId, voicePreset);
  }

  /**
   * ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
   */
  private generateId(): string {
    return `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * ã‚°ãƒ«ãƒ¼ãƒ—ãƒãƒ£ãƒƒãƒˆã®å–å¾—
   */
  getGroupChat(id: string): GroupChat | undefined {
    return this.groupChats.get(id);
  }

  /**
   * å…¨ã‚°ãƒ«ãƒ¼ãƒ—ãƒãƒ£ãƒƒãƒˆã®å–å¾—
   */
  getAllGroupChats(): GroupChat[] {
    return Array.from(this.groupChats.values());
  }
}
```

## ğŸ“ çµ±åˆä½¿ç”¨ä¾‹

```typescript
// src/app/chat/page.tsx

'use client';

import React, { useState, useEffect } from 'react';
import { ConversationManager } from '@/services/memory/conversation-manager';
import { TrackerManager } from '@/services/tracker/tracker-manager';
import { GroupChatManager } from '@/services/chat/group-chat-manager';
import { useCharacterStore } from '@/store/character.store';
import { usePersonaStore } from '@/store/persona.store';

export default function ChatPage() {
  const [conversationManager] = useState(() => new ConversationManager());
  const [trackerManager] = useState(() => new TrackerManager());
  const [groupChatManager] = useState(() => new GroupChatManager(trackerManager));
  
  const { characters, selectedCharacters } = useCharacterStore();
  const { currentPersona } = usePersonaStore();
  
  const [isGroupMode, setIsGroupMode] = useState(false);
  const [groupChat, setGroupChat] = useState(null);

  // ã‚°ãƒ«ãƒ¼ãƒ—ãƒãƒ£ãƒƒãƒˆã®åˆæœŸåŒ–
  const initGroupChat = () => {
    if (selectedCharacters.length > 1 && currentPersona) {
      const chat = groupChatManager.createGroupChat(
        'ã‚°ãƒ«ãƒ¼ãƒ—ãƒãƒ£ãƒƒãƒˆ',
        selectedCharacters.map(c => c.id),
        selectedCharacters,
        currentPersona,
        'sequential'
      );
      setGroupChat(chat);
      setIsGroupMode(true);
    }
  };

  // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡
  const sendMessage = async (content: string) => {
    if (isGroupMode && groupChat) {
      // ã‚°ãƒ«ãƒ¼ãƒ—ãƒãƒ£ãƒƒãƒˆãƒ¢ãƒ¼ãƒ‰
      const responses = await groupChatManager.sendMessageToGroup(
        groupChat.id,
        content
      );
      
      // å„å¿œç­”ã‚’ä¼šè©±ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã«è¨˜éŒ²
      for (const response of responses) {
        await conversationManager.addMessage(
          'assistant',
          response.content,
          {
            character_id: response.character_id,
            character_name: response.character_name
          }
        );
      }
    } else {
      // é€šå¸¸ã®ãƒãƒ£ãƒƒãƒˆ
      await conversationManager.addMessage('user', content);
      
      // AIã‹ã‚‰ã®å¿œç­”ã‚’ç”Ÿæˆ
      const prompt = await conversationManager.generatePrompt(
        content,
        selectedCharacters[0],
        currentPersona
      );
      
      // ... AIå¿œç­”å‡¦ç†
    }
  };

  // ãƒˆãƒ©ãƒƒã‚«ãƒ¼æ›´æ–°ã®ç›£è¦–
  useEffect(() => {
    trackerManager.onUpdate((update) => {
      console.log('Tracker updated:', update);
      // UIã‚’æ›´æ–°
    });
  }, [trackerManager]);

  return (
    <div className="flex h-screen">
      {/* ãƒãƒ£ãƒƒãƒˆã‚¨ãƒªã‚¢ */}
      <div className="flex-1">
        {/* ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒªã‚¹ãƒˆ */}
        {/* ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å…¥åŠ› */}
      </div>
      
      {/* ãƒˆãƒ©ãƒƒã‚«ãƒ¼ãƒ‘ãƒãƒ« */}
      <div className="w-80 border-l">
        {/* ãƒˆãƒ©ãƒƒã‚«ãƒ¼è¡¨ç¤º */}
      </div>
    </div>
  );
}
```

ã“ã‚Œã§ã€å‹å®šç¾©ã®æ•´åˆæ€§ãŒå–ã‚Œã€ãƒˆãƒ©ãƒƒã‚«ãƒ¼ã‚·ã‚¹ãƒ†ãƒ ã¨ã‚°ãƒ«ãƒ¼ãƒ—ãƒãƒ£ãƒƒãƒˆæ©Ÿèƒ½ãŒçµ±åˆã•ã‚ŒãŸå®Œå…¨ãªã‚·ã‚¹ãƒ†ãƒ ã«ãªã‚Šã¾ã™ã€‚
