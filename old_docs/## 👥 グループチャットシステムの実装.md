## 👥 グループチャットシステムの実装

```typescript
// src/services/chat/group-chat-manager.ts

import { GroupChat, Character, Message, Persona } from '@/types';
import { TrackerManager } from '@/services/tracker/tracker-manager';
import { VoicePreset } from '@/types/voice.types';

export class GroupChatManager {
  private groupChats: Map<string, GroupChat> = new Map();
  private trackerManager: TrackerManager;
  private messageQueue: Map<string, Message[]> = new Map();

  constructor(trackerManager: TrackerManager) {
    this.trackerManager = trackerManager;
  }

  /**
   * グループチャットの作成
   */
  createGroupChat(
    name: string,
    characterIds: string[],
    characters: Character[],
    persona: Persona,
    mode: 'sequential' | 'simultaneous' | 'random' = 'sequential'
  ): GroupChat {
    const groupChat: GroupChat = {
      id: this.generateId(),
      name,
      character_ids: characterIds,
      characters,
      active_characters: new Set(characterIds.slice(0, 3)), // 最大3人
      character_tracker_sets: new Map(),
      persona_id: persona.id,
      persona,
      messages: [],
      speaking_order: [...characterIds],
      group_mode: mode,
      max_characters: 3,
      voice_settings: new Map(),
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
      last_message_at: new Date().toISOString()
    };

    // 各キャラクターのトラッカーを初期化
    characters.forEach(character => {
      const trackerSet = this.trackerManager.initializeTrackerSet(
        character.id,
        character.trackers
      );
      groupChat.character_tracker_sets.set(character.id, trackerSet);
    });

    this.groupChats.set(groupChat.id, groupChat);
    return groupChat;
  }

  /**
   * グループチャットへのメッセージ送信
   */
  async sendMessageToGroup(
    groupChatId: string,
    userMessage: string
  ): Promise<Message[]> {
    const groupChat = this.groupChats.get(groupChatId);
    if (!groupChat) throw new Error('Group chat not found');

    // ユーザーメッセージを追加
    const userMsg: Message = {
      id: this.generateId(),
      session_id: groupChatId,
      role: 'user',
      content: userMessage,
      timestamp: new Date().toISOString()
    };
    groupChat.messages.push(userMsg);

    // 各アクティブキャラクターからの返信を生成
    const responses: Message[] = [];

    switch (groupChat.group_mode) {
      case 'sequential':
        responses.push(...await this.generateSequentialResponses(groupChat, userMessage));
        break;
      
      case 'simultaneous':
        responses.push(...await this.generateSimultaneousResponses(groupChat, userMessage));
        break;
      
      case 'random':
        responses.push(...await this.generateRandomResponse(groupChat, userMessage));
        break;
    }

    // メッセージとトラッカーの更新
    for (const response of responses) {
      groupChat.messages.push(response);
      
      // トラッカーの自動更新
      if (response.character_id) {
        await this.trackerManager.analyzeAndUpdateTrackers(
          response.character_id,
          response
        );
      }
    }

    groupChat.last_message_at = new Date().toISOString();
    groupChat.updated_at = new Date().toISOString();

    return responses;
  }

  /**
   * 順次応答の生成
   */
  private async generateSequentialResponses(
    groupChat: GroupChat,
    userMessage: string
  ): Promise<Message[]> {
    const responses: Message[] = [];
    const activeCharacters = Array.from(groupChat.active_characters);

    for (const characterId of activeCharacters) {
      const character = groupChat.characters.find(c => c.id === characterId);
      if (!character) continue;

      const response = await this.generateCharacterResponse(
        groupChat,
        character,
        userMessage,
        responses // 前のキャラクターの応答も考慮
      );
      
      responses.push(response);
      
      // 少し遅延を入れる（リアルな会話感）
      await this.delay(500);
    }

    return responses;
  }

  /**
   * 同時応答の生成
   */
  private async generateSimultaneousResponses(
    groupChat: GroupChat,
    userMessage: string
  ): Promise<Message[]> {
    const activeCharacters = Array.from(groupChat.active_characters);
    
    const responsePromises = activeCharacters.map(characterId => {
      const character = groupChat.characters.find(c => c.id === characterId);
      if (!character) return null;
      
      return this.generateCharacterResponse(
        groupChat,
        character,
        userMessage,
        []
      );
    });

    const responses = await Promise.all(responsePromises);
    return responses.filter(r => r !== null) as Message[];
  }

  /**
   * ランダムキャラクターの応答生成
   */
  private async generateRandomResponse(
    groupChat: GroupChat,
    userMessage: string
  ): Promise<Message[]> {
    const activeCharacters = Array.from(groupChat.active_characters);
    const randomIndex = Math.floor(Math.random() * activeCharacters.length);
    const characterId = activeCharacters[randomIndex];
    
    const character = groupChat.characters.find(c => c.id === characterId);
    if (!character) return [];

    const response = await this.generateCharacterResponse(
      groupChat,
      character,
      userMessage,
      []
    );

    return [response];
  }

  /**
   * キャラクター個別の応答生成
   */
  private async generateCharacterResponse(
    groupChat: GroupChat,
    character: Character,
    userMessage: string,
    previousResponses: Message[]
  ): Promise<Message> {
    // プロンプトの構築
    const prompt = this.buildGroupChatPrompt(
      groupChat,
      character,
      userMessage,
      previousResponses
    );

    try {
      const response = await fetch('/api/ai/generate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          prompt,
          character,
          persona: groupChat.persona,
          temperature: 0.8,
          max_tokens: 200
        })
      });

      const data = await response.json();

      return {
        id: this.generateId(),
        session_id: groupChat.id,
        role: 'assistant',
        content: data.content,
        character_id: character.id,
        character_name: character.name,
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      console.error(`Failed to generate response for ${character.name}:`, error);
      
      return {
        id: this.generateId(),
        session_id: groupChat.id,
        role: 'assistant',
        content: '...',
        character_id: character.id,
        character_name: character.name,
        timestamp: new Date().toISOString()
      };
    }
  }

  /**
   * グループチャット用プロンプトの構築
   */
  private buildGroupChatPrompt(
    groupChat: GroupChat,
    character: Character,
    userMessage: string,
    previousResponses: Message[]
  ): string {
    const otherCharacters = groupChat.characters
      .filter(c => c.id !== character.id && groupChat.active_characters.has(c.id))
      .map(c => c.name)
      .join('、');

    const trackerSet = groupChat.character_tracker_sets.get(character.id);
    const trackerInfo = trackerSet ? 
      Array.from(trackerSet.trackers.values())
        .map(t => `${t.display_name}: ${t.current_value}`)
        .join('\n') : '';

    let prompt = `
あなたは${character.name}として、グループチャットに参加しています。
他の参加者: ${otherCharacters}
ユーザー: ${groupChat.persona.name}

${character.system_prompt}

現在の状態:
${trackerInfo}

会話の文脈:
${groupChat.messages.slice(-6).map(m => {
  const speaker = m.role === 'user' ? groupChat.persona.name : 
                  m.character_name || 'アシスタント';
  return `${speaker}: ${m.content}`;
}).join('\n')}
`;

    // 他のキャラクターの応答がある場合
    if (previousResponses.length > 0) {
      prompt += `\n\n直前の他キャラクターの応答:\n`;
      previousResponses.forEach(r => {
        prompt += `${r.character_name}: ${r.content}\n`;
      });
      prompt += `\nこれらの応答も考慮して、${character.name}として自然に応答してください。`;
    }

    prompt += `\n\n${groupChat.persona.name}: ${userMessage}\n${character.name}: `;

    return prompt;
  }

  /**
   * アクティブキャラクターの切り替え
   */
  toggleActiveCharacter(groupChatId: string, characterId: string): void {
    const groupChat = this.groupChats.get(groupChatId);
    if (!groupChat) return;

    if (groupChat.active_characters.has(characterId)) {
      groupChat.active_characters.delete(characterId);
    } else if (groupChat.active_characters.size < groupChat.max_characters) {
      groupChat.active_characters.add(characterId);
    }
  }

  /**
   * 音声設定の設定
   */
  setVoicePreset(
    groupChatId: string,
    characterId: string,
    voicePreset: VoicePreset
  ): void {
    const groupChat = this.groupChats.get(groupChatId);
    if (!groupChat) return;

    groupChat.voice_settings.set(characterId, voicePreset);
  }

  /**
   * ユーティリティ
   */
  private generateId(): string {
    return `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * グループチャットの取得
   */
  getGroupChat(id: string): GroupChat | undefined {
    return this.groupChats.get(id);
  }

  /**
   * 全グループチャットの取得
   */
  getAllGroupChats(): GroupChat[] {
    return Array.from(this.groupChats.values());
  }
}
```

## 📝 統合使用例

```typescript
// src/app/chat/page.tsx

'use client';

import React, { useState, useEffect } from 'react';
import { ConversationManager } from '@/services/memory/conversation-manager';
import { TrackerManager } from '@/services/tracker/tracker-manager';
import { GroupChatManager } from '@/services/chat/group-chat-manager';
import { useCharacterStore } from '@/store/character.store';
import { usePersonaStore } from '@/store/persona.store';

export default function ChatPage() {
  const [conversationManager] = useState(() => new ConversationManager());
  const [trackerManager] = useState(() => new TrackerManager());
  const [groupChatManager] = useState(() => new GroupChatManager(trackerManager));
  
  const { characters, selectedCharacters } = useCharacterStore();
  const { currentPersona } = usePersonaStore();
  
  const [isGroupMode, setIsGroupMode] = useState(false);
  const [groupChat, setGroupChat] = useState(null);

  // グループチャットの初期化
  const initGroupChat = () => {
    if (selectedCharacters.length > 1 && currentPersona) {
      const chat = groupChatManager.createGroupChat(
        'グループチャット',
        selectedCharacters.map(c => c.id),
        selectedCharacters,
        currentPersona,
        'sequential'
      );
      setGroupChat(chat);
      setIsGroupMode(true);
    }
  };

  // メッセージ送信
  const sendMessage = async (content: string) => {
    if (isGroupMode && groupChat) {
      // グループチャットモード
      const responses = await groupChatManager.sendMessageToGroup(
        groupChat.id,
        content
      );
      
      // 各応答を会話管理システムに記録
      for (const response of responses) {
        await conversationManager.addMessage(
          'assistant',
          response.content,
          {
            character_id: response.character_id,
            character_name: response.character_name
          }
        );
      }
    } else {
      // 通常のチャット
      await conversationManager.addMessage('user', content);
      
      // AIからの応答を生成
      const prompt = await conversationManager.generatePrompt(
        content,
        selectedCharacters[0],
        currentPersona
      );
      
      // ... AI応答処理
    }
  };

  // トラッカー更新の監視
  useEffect(() => {
    trackerManager.onUpdate((update) => {
      console.log('Tracker updated:', update);
      // UIを更新
    });
  }, [trackerManager]);

  return (
    <div className="flex h-screen">
      {/* チャットエリア */}
      <div className="flex-1">
        {/* メッセージリスト */}
        {/* メッセージ入力 */}
      </div>
      
      {/* トラッカーパネル */}
      <div className="w-80 border-l">
        {/* トラッカー表示 */}
      </div>
    </div>
  );
}
```

これで、型定義の整合性が取れ、トラッカーシステムとグループチャット機能が統合された完全なシステムになります。
